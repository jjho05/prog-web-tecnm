# 4.3 Tratamiento de Formularios

El 90% de los ataques ocurren aqu√≠.
Nunca conf√≠es en lo que env√≠a el usuario. **Nunca.**

---

## Recibiendo Datos (Body Parsers)

Express por defecto **NO** lee el cuerpo de las peticiones POST.
Necesitas ense√±arle.

### Body Parser (JSON)
Express no lee el cuerpo de los POST por defecto. Tienes que activarlo:
```javascript
app.use(express.json()); // Entiende JSON
app.use(express.urlencoded({ extended: true })); // Entiende Formularios cl√°sicos
```
Sin esto, `req.body` ser√° `undefined`.

---

## Validaci√≥n de Datos (Schema Validation)

Validar con `if` es sucio y propenso a errores.
Usa **Zod**.

### Validaci√≥n con Zod
No valides a mano con `if`. Usa esquemas.
```javascript
const { z } = require('zod');

const loginSchema = z.object({
    email: z.string().email(),
    password: z.string().min(8)
});

app.post('/login', (req, res) => {
    // safeParse no explota si falla, retorna √©xito o error
    const result = loginSchema.safeParse(req.body);
    
    if (!result.success) {
        return res.status(400).json(result.error.flatten());
    }
    
    const { email, password } = result.data;
    // Continuar login...
});
```

---

## Sanitizaci√≥n (Limpiando la Basura)

Validar es decir "Esto est√° mal". Sanitizar es decir "Voy a limpiar esto".

### Trim Strings
El usuario escribe " juan@gmail.com " (con espacios).
Zod puede hacerlo por ti:
```javascript
z.string().trim().email()
```

### XSS (Cross Site Scripting) Pasivo
Si guardas `<script>alert(1)</script>` en la DB:
*   **En la DB:** No pasa nada (es solo texto).
*   **Al mostrarlo en React:** React escapa por defecto (seguro).
*   **Al mostrarlo en HTML puro:** ¬°Peligro!
*   **Soluci√≥n:** Usa `DOMPurify` (o librer√≠as como `xss`) SOLO cuando vayas a renderizar HTML crudo. **No sanitices en la entrada** (vas a corromper datos leg√≠timos como contrase√±as con caracteres especiales).

---

## Subida de Archivos (Multipart/Form-Data)

JSON no soporta archivos binarios (bueno, en Base64 s√≠, pero es lento).
Usamos **Multer**.

### Configuraci√≥n B√°sica
```javascript
const multer = require('multer');
const upload = multer({ dest: 'uploads/' }); // Carpeta temporal

app.post('/avatar', upload.single('foto'), (req, res) => {
    console.log(req.file); 
    // { path: 'uploads/abc-123', originalname: 'foto.jpg', mimetype: 'image/jpeg' }
    res.send("Archivo subido");
});
```
*   **Nota:** Esto guarda el archivo con un nombre aleatorio sin extensi√≥n. Necesitas renombrarlo o subirlo a S3.

---

---

## Advanced File Uploads (Multer Pro)

Subir archivos sin validar es pedir a gritos un hackeo (Shell Upload).

### Filtrado de Archivos (File Filter)
Solo acepta im√°genes reales, no `.php` renombrado a `.jpg`.
```javascript
const fileFilter = (req, file, cb) => {
    if (file.mimetype === 'image/jpeg' || file.mimetype === 'image/png') {
        cb(null, true); // Aceptar
    } else {
        cb(new Error('Formato no soportado'), false); // Rechazar
    }
};

const upload = multer({ 
    storage: multer.memoryStorage(), // Guardar en RAM (Buffer)
    limits: { fileSize: 5 * 1024 * 1024 }, // 5MB m√°x
    fileFilter: fileFilter 
});
```

### Storage Engines (Cloud)
No guardes archivos en el disco del servidor (Heroku borra el disco cada 24h).
Usa `multer-s3`.

> **üíª C√≥digo en Acci√≥n:**
> Simulaci√≥n de c√≥mo se guardan datos en una "Base de Datos" (falsa) usando clases as√≠ncronas.
>
> üìÑ **Ver c√≥digo:** [03_acceso_datos_mock.js](codigos/03_acceso_datos_mock.js)

---

## CSRF (Cross-Site Request Forgery)

El ataque silencioso.
Si el usuario est√° logueado en tu banco y visita `hacker.com`, el hacker puede hacer un POST invisible a `tubanco.com/transferir`.

### Protecci√≥n CSRF
Evita que otra web env√≠e forms a tu servidor sin permiso.
*   **En SPAs:** Se usa el patr√≥n de doble cookie o headers de autorizaci√≥n.
*   **En MVC cl√°sico:** Usa tokens CSRF en formularios ocultos.
*   **Hoy:** Los frameworks modernos (Next.js, etc.) lo manejan, o el navegador con cookies `SameSite=Strict`.

---

## CAPTCHA (Protecci√≥n contra Bots)

Si tienes un formulario p√∫blico (Registro/Login), te van a spammear.

### Validaci√≥n Backend (ReCaptcha v3)
El Frontend te env√≠a un `token`. T√∫ debes preguntarle a Google si es v√°lido.

```javascript
app.post('/registro', async (req, res) => {
    const { token, email } = req.body;
    
    // Verificar con Google
    const url = `https://www.google.com/recaptcha/api/siteverify?secret=${SECRET}&response=${token}`;
    const googleRes = await fetch(url, { method: 'POST' }).then(r => r.json());
    
    if (!googleRes.success || googleRes.score < 0.5) {
        return res.status(400).json({ error: "Eres un Robot" });
    }
    
    // Si llegas aqu√≠, es humano
    crearUsuario(email);
});
```
*   **Nota:** Nunca conf√≠es solo en el frontend. La validaci√≥n real ocurre en el backend.

---

---

## Formularios Multi-paso (Wizards)

"Paso 1: Datos Personales" -> Siguiente -> "Paso 2: Direcci√≥n".
HTTP es stateless. Si refrescas la p√°gina, pierdes el Paso 1.

### Persistencia Temporal (Redis/Session)
No guardes en DB sql hasta el final. Guarda en un "Draft" en Redis.

```javascript
app.post('/wizard/step1', (req, res) => {
    req.session.draft = { ...req.session.draft, ...req.body };
    res.json({ ok: true });
});

app.post('/wizard/submit', async (req, res) => {
    const finalData = { ...req.session.draft, ...req.body };
    await db.users.create(finalData);
    req.session.draft = null; // Limpiar
});
```

---

## Validaci√≥n en Tiempo Real (Debounce)

El usuario escribe "usuar". ¬øVerificas si existe en cada tecla? **NO**.
Esperas a que deje de escribir (Debounce).

### Backend Check
Ruta ligera para verificar disponibilidad.
```javascript
app.get('/check-username/:username', async (req, res) => {
    const exists = await db.users.count({ username: req.params.username });
    res.json({ available: exists === 0 });
});
```
*   **Tip:** Usa √≠ndices en la DB (`CREATE INDEX ON users(username)`).

---

## Streaming Uploads (Busboy)

Multer carga el archivo en RAM o Disco.
¬øQu√© pasa si suben un archivo de 10GB? Se acaba la RAM.
Tus datos deben fluir como el agua (Streams).

```javascript
const Busboy = require('busboy');

app.post('/upload-big', (req, res) => {
    const busboy = Busboy({ headers: req.headers });
    
    busboy.on('file', (name, file, info) => {
        // 'file' es un ReadableStream
        // Con√©ctalo directo a S3 sin tocar el disco del servidor
        file.pipe(s3UploadStream(name));
    });
    
    busboy.on('finish', () => res.send('Subida Exitosa'));
    req.pipe(busboy);
});
```

---

---

## Procesamiento de Excel y CSV

Los usuarios aman Excel. Tu app debe amarlo tambi√©n.

### CSV Streams (Rendimiento)
Leer un CSV de 1GB l√≠nea por l√≠nea sin colapsar la RAM.
```javascript
const csv = require('csv-parser');

fs.createReadStream('usuarios.csv')
  .pipe(csv())
  .on('data', (row) => {
      // Procesar cada fila individualmente
      db.users.create(row);
  })
  .on('end', () => {
      console.log('CSV procesado exitosamente.');
  });
```

### Generando Excel (`xlsx`)
```javascript
const XLSX = require('xlsx');

const data = [{ nombre: "Juan", edad: 30 }, { nombre: "Ana", edad: 25 }];
const ws = XLSX.utils.json_to_sheet(data);
const wb = XLSX.utils.book_new();
XLSX.utils.book_append_sheet(wb, ws, "Usuarios");

// Enviar al cliente
const buffer = XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' });
res.setHeader('Content-Type', 'application/vnd.openxmlformats');
res.send(buffer);
```

---

## Formularios Din√°micos (JSON Driven)

Si tu formulario tiene 500 campos que cambian cada mes, no escribas HTML.
Guarda la estructura en DB.

### Schema Definition
```json
{
  "fields": [
    { "type": "text", "name": "nombre", "label": "Nombre Completo", "required": true },
    { "type": "select", "name": "pais", "options": ["MX", "CO", "AR"] }
  ]
}
```

### Validaci√≥n Din√°mica
Tu backend debe construir el validador Zod al vuelo bas√°ndose en el JSON.
```javascript
function buildValidator(schema) {
    const shape = {};
    schema.fields.forEach(field => {
        if (field.type === 'text') shape[field.name] = z.string();
        if (field.required) shape[field.name] = shape[field.name].min(1);
    });
    return z.object(shape);
}
```

---

## Rellanado de PDFs (`pdf-lib`)

Caso de uso: Contratos Legales.
El usuario llena un Form Web y t√∫ le devuelves el PDF firmado.

```javascript
const { PDFDocument } = require('pdf-lib');

const pdfBytes = await fs.readFile('contrato-plantilla.pdf'); // Con campos AcroForm
const pdfDoc = await PDFDocument.load(pdfBytes);
const form = pdfDoc.getForm();

form.getTextField('nombre_cliente').setText('Juan P√©rez');
form.getTextField('fecha').setText('26/01/2026');

form.flatten(); // Convertir campos a texto plano (no editables)
const pdfFinal = await pdfDoc.save();
```

---

## WebAuthn (Adi√≥s Passwords)

Usar FaceID / TouchID en tu web.
El formulario m√°s seguro es el que no tiene contrase√±a.

1.  **Registro:** Servidor env√≠a un "Challenge". Navegador pide huella. Servidor guarda la llave p√∫blica.
2.  **Login:** Servidor env√≠a "Challenge". Navegador firma con huella (llave privada). Servidor verifica con llave p√∫blica.
*   **Librer√≠a:** `@simplewebauthn/server`

---

---

## Honeypot (Anti-Spam sin molestar)

Los Captchas odian a tus usuarios. Usa un Honeypot.
Es un campo invisible que solo los bots llenan.

```html
<form action="/registro" method="POST">
    <!-- Visible -->
    <input type="email" name="email">
    
    <!-- Invisible para humanos, visible para bots -->
    <div style="display: none;">
        <input type="text" name="website" tabindex="-1" autocomplete="off">
    </div>
    
    <button type="submit">Enviar</button>
</form>
```

```javascript
app.post('/registro', (req, res) => {
    // Si el bot llen√≥ el campo oculto "website"
    if (req.body.website) {
        // Fingir √©xito para confundir al bot
        return res.json({ msg: "Registro exitoso" });
    }
    
    crearUsuario(req.body.email);
});
```

---

## Audit Logging (Auditor√≠a)

En sistemas empresariales, "Qui√©n hizo Qu√© y Cu√°ndo" es legalmente obligatorio.
No lo mezcles con `console.log`.

```javascript
/* audit.service.js */
async function logAudit(action, actorId, resourceId, metadata) {
    await db.auditLogs.create({
        action: action, // "UPDATE_PROFILE"
        actorId: actorId, // Usuario que hizo el cambio
        resourceId: resourceId,
        ip: metadata.ip,
        changes: JSON.stringify(metadata.diff), // Antes vs Despu√©s
        timestamp: new Date()
    });
}

/* controller.js */
app.patch('/users/:id', async (req, res) => {
    const oldUser = await db.users.find(req.params.id);
    await db.users.update(req.params.id, req.body);
    
    logAudit('UPDATE_USER', req.user.id, req.params.id, {
        diff: jsonDiff(oldUser, req.body),
        ip: req.ip
    });
});
```

---

## GDPR y Consentimiento

Si tienes usuarios en Europa, no puedes pre-marcar el checkbox de "Acepto Newsletter".

### Granularidad
*   Checkbox 1: Acepto T√©rminos (Obligatorio).
*   Checkbox 2: Marketing (Opcional, Desmarcado por defecto).
*   Checkbox 3: Compartir con Terceros (Opcional).

### Derecho al Olvido
Debes tener una ruta para borrar TODO rastro del usuario (incluyendo Logs y Backups).
```javascript
app.delete('/me/gdpr', async (req, res) => {
    // 1. Borrar DB
    await db.users.delete(req.user.id);
    // 2. Anonimizar Logs (Actualizar email por 'deleted@gdpr')
    await db.auditLogs.updateMany({ actorId: req.user.id }, { actorId: null });
    // 3. Borrar S3
    await s3.deleteFolder(`users/${req.user.id}`);
});
```

---

## Procesamiento de Im√°genes (`Sharp`)

Si el usuario sube una foto de 10MB (4000x3000px), no la guardes as√≠.
Redimensi√≥nala y convi√©rtela a WebP antes de guardar.

```javascript
const sharp = require('sharp');

app.post('/avatar', upload.single('foto'), async (req, res) => {
    // req.file.buffer tiene la imagen cruda
    const optimizedBuffer = await sharp(req.file.buffer)
        .resize(500, 500, { fit: 'cover' }) // Recortar al centro
        .webp({ quality: 80 }) // Comprimir
        .toBuffer();
        
    await s3.upload({ 
        Bucket: 'avatars', 
        Key: `${req.user.id}.webp`, 
        Body: optimizedBuffer 
    });
    
    res.json({ url: `https://cdn.com/${req.user.id}.webp` });
});
```
*   **Performance:** `Sharp` usa librer√≠as de C++ ultra r√°pidas (libvips). Es 5x m√°s r√°pido que ImageMagick.

---

---

## Streaming Downloads (Descargas)

Si generas un PDF de 50MB, no lo guardes en disco.
Env√≠alo directo al usuario mientras se genera.

```javascript
app.get('/download/report', async (req, res) => {
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', 'attachment; filename="reporte.csv"');
    
    const cursor = db.users.find().cursor();
    
    // Transform Stream: Objeto JS -> String CSV
    const transform = new Transform({
        objectMode: true,
        transform(user, encoding, callback) {
            this.push(`${user.id},${user.email}\n`);
            callback();
        }
    });

    cursor.pipe(transform).pipe(res);
});
```

---

## Zero-Trust Security (CSP)

Evita que los formularios carguen scripts maliciosos.
Header: `Content-Security-Policy`.

```javascript
const helmet = require('helmet');

app.use(helmet.contentSecurityPolicy({
    directives: {
        defaultSrc: ["'self'"],
        scriptSrc: ["'self'", "https://www.google.com/recaptcha/"],
        formAction: ["'self'", "https://checkout.stripe.com"]
    }
}));
```
*   **Form Action:** Impide que un `<form>` env√≠e datos a `hacker.com` incluso si logran inyectarlo.

---

## Replay Attacks (Ataques de Repetici√≥n)

Si un hacker captura tu petici√≥n de "Enviar $100" (incluso encriptada en HTTPS) y la reenv√≠a 50 veces... ¬øte quedas pobre?
Usa **Nonces** (Number Used Once) y **Timestamps**.

1.  **Header:** `X-Timestamp: 1700000000`.
2.  **Header:** `X-Nonce: abc-123`.
3.  **Firma:** HMAC(Body + Timestamp + Nonce).

**Validaci√≥n Backend:**
1.  Si `Timestamp` es m√°s viejo de 5min -> Rechazar.
2.  Si `Nonce` ya existe en Redis -> Rechazar.
3.  Si la Firma no coincide -> Rechazar.

---

<div align="center">

[‚¨ÖÔ∏è Anterior: 4.2 Estructuras de Control](4.2.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 4.4 Manejo de Objetos](4.4.md) ‚û°Ô∏è

</div>
