# 4.1 Introducci칩n al Lenguaje (Node.js)

Bienvenido al Backend. Aqu칤 no hay ventanas, ni botones, ni CSS.
Solo datos, l칩gica y velocidad.

---

## 쯈u칠 es Node.js?

Node.js **NO** es un lenguaje. Es un **Entorno de Ejecuci칩n (Runtime)** para JavaScript.
Permite correr JS fuera del navegador (en tu servidor, laptop, o tostadora inteligente).

### El Motor V8
Node.js usa el mismo motor que Google Chrome: **V8**.
*   Escrito en C++.
*   Compila JS a C칩digo de M치quina (JIT - Just In Time) nativo.
*   Es brutalmente r치pido.

### Libuv (El H칠roe Silencioso)
Si V8 ejecuta el c칩digo JS, **Libuv** maneja el Sistema Operativo.
*   Acceso al disco duro (File System).
*   Redes (TCP/UDP).
*   Event Loop.
*   Thread Pool (para tareas pesadas como Criptograf칤a).

---

### Single-Threaded vs Multi-Threaded
Esta es la clave de todo:
*   **Java/Python:** Crean un hilo nuevo por cada usuario. Si tienes 10k usuarios, necesitas mucha RAM.
*   **Node.js:** Usa **un solo hilo** para todos.
    *   *La Met치fora del Camarero:* Un solo camarero toma pedidos de 100 mesas. Manda los pedidos a la cocina (el sistema) y sigue atendiendo. No se queda esperando a que el cocinero termine.
    *   **Resultado:** Node.js es perfecto para cosas en tiempo real (Chats, APIs, Streaming). Malo para procesar video 8K (bloquear칤a al camarero).

---

## Instalaci칩n y Primeros Pasos

### NVM (Node Version Manager)
Nunca instales Node.js directo del instalador de la web. Usa NVM.
Te permite cambiar de versi칩n (v18, v20, v22) con un comando.
```bash
nvm install --lts  # Instala la versi칩n estable (Long Term Support)
nvm use --lts
node -v
```

### El REPL (Read-Eval-Print Loop)
Escribe `node` en tu terminal.
```javascript
> 1 + 1
2
> const os = require('os');
> os.cpus().length
8
```
Presiona `Ctrl + C` dos veces para salir.

---

## `global` vs `window`

En el navegador, el objeto global es `window`. En Node.js, eso no existe.
Tenemos `global`.

### Lo que NO existe en Node
*   `window`
*   `document` (No hay DOM)
*   `alert()`
*   `localStorage` (No hay navegador)
*   `fetch` (Antes de Node 18, necesitabas librer칤as. Ahora es nativo).

### Lo que S칈 existe (Variables Globales)
*   `__dirname`: Ruta absoluta de la carpeta actual.
*   `__filename`: Ruta absoluta del archivo actual.
*   `process`: Informaci칩n del proceso actual (variables de entorno, argumentos).
    ```javascript
    console.log(process.env.PORT); // Leer variables de entorno
    process.exit(1); // Matar el proceso (Error)
    ```
*   `Buffer`: Para manipular datos binarios (archivos).

---

---

## Sistema de M칩dulos (CommonJS vs ESM)

Node.js naci칩 en 2009 usando **CommonJS** (`require`).
Hoy en d칤a soporta **ES Modules** (`import`), pero el ecosistema est치 dividido.

### CommonJS (El Cl치sico)
Usa `require`. Es s칤ncrono.
```javascript
const { sumar } = require('./math');
module.exports = { sumar };
```

### ES Modules (El Moderno)
Usa `import`. Es el est치ndar oficial de JS.
Para usarlo en Node, a침ade `"type": "module"` en tu `package.json` o usa archivos `.mjs`.
```javascript
import { sumar } from './math.js';
export const sumar = (a, b) => a + b;
```

---

## NPM (Node Package Manager)

No reinventes la rueda. Alguien ya escribi칩 una librer칤a para eso.
Es el registro de software m치s grande del mundo.

### `package.json` y `node_modules`
*   **`package.json`:** El DNI de tu proyecto. Lista qu칠 librer칤as usas.
*   **`node_modules`:** La carpeta gigante donde se descarga el c칩digo de las librer칤as. **NUNCA la subas a Git**.
    *   Crea un archivo `.gitignore` y pon `node_modules` adentro.

---

## Variables de Entorno (`.env`)

Jam치s hardcodees contrase침as o API Keys en tu c칩digo.
Usa la librer칤a `dotenv` (o el flag `--env-file` en Node 20+).

```bash
# .env
DB_PASSWORD=secreto_super_seguro
PORT=3000
```

```javascript
// index.js
require('dotenv').config();
console.log(process.env.DB_PASSWORD);
```
**Regla de Oro:** Sube un `.env.example` a Git con valores vac칤os para que tus compa침eros sepan qu칠 configurar.

---

---

## El Event Loop (Versi칩n Backend)

En Node.js, entender las fases del Event Loop es vital para no bloquear el servidor.
A diferencia del navegador, aqu칤 hay fases espec칤ficas.

### El Event Loop Simplificado
Node.js delega las tareas pesadas (leer disco, red) al sistema (C++). Cuando terminan, Node ejecuta tu callback.
Fases principales:
1.  **Timers:** (`setTimeout`)
2.  **Poll:** (I/O, Red, Archivos) -> Aqu칤 pasa casi todo el tiempo.
3.  **Check:** (`setImmediate`)

*   **Microtasks:** (`Promise` y `process.nextTick`) tienen prioridad VIP y se cuelan antes de pasar de fase.

---

## File System (Sistema de Archivos)

En el navegador no puedes leer archivos del usuario (por seguridad). En Node.js tienes control total del disco.

### File System (fs)
No bloquees el hilo. Usa Promesas.
```javascript
const fs = require('node:fs/promises');

async function leer() {
    try {
        const data = await fs.readFile('archivo.txt', 'utf-8');
        console.log(data);
    } catch (e) {
        console.error("Error al leer");
    }
}
```
*   **Tip:** Para archivos gigantes (Videos, CSV grandes), usa **Streams**. No cargues 1GB en RAM.

---

## HTTP Server (Raw Node.js)

Antes de usar Express, mira c칩mo se hace "a mano".

```javascript
const http = require('node:http');

const server = http.createServer((req, res) => {
    // req: Request (Lo que pide el cliente)
    // res: Response (Lo que respondemos)

    if (req.url === '/' && req.method === 'GET') {
        res.writeHead(200, { 'Content-Type': 'text/plain' });
        res.end('Hola Mundo desde Node');
    } else if (req.url === '/json') {
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ mensaje: 'Soy un JSON' }));
    } else {
        res.writeHead(404);
        res.end('Not Found');
    }
});

server.listen(3000, () => {
    console.log('Servidor corriendo en puerto 3000');
});
```

> **游눹 C칩digo en Acci칩n:**
> Copia este c칩digo, gu치rdalo como `server.js` y ejec칰talo con `node server.js`. 춰Acabas de crear un servidor web!
>
> 游늯 **Ver c칩digo:** [01_servidor_http.js](codigos/01_servidor_http.js)

---

---

## Streams y Buffers (Manejo de Memoria)

Node.js es famoso por manejar Streams (Flujos de datos).
Netflix usa Node.js precisamente por esto.

### Buffers
Un pedazo de memoria cruda (bytes). JS maneja Strings (UTF-8), pero Node maneja Binarios.
```javascript
const buf = Buffer.from('Hola');
console.log(buf); // <Buffer 48 6f 6c 61>
console.log(buf.toJSON()); // { type: 'Buffer', data: [ 72, 111, 108, 97 ] }
```

### Pipes (Tuber칤as)
Conectar una entrada (Lectura) con una salida (Escritura).
```javascript
// Copiar archivo gigante sin usar RAM
const fs = require('node:fs');
const lectura = fs.createReadStream('origen.iso'); // 4GB
const escritura = fs.createWriteStream('destino.iso');

lectura.pipe(escritura);
// La memoria usada ser치 constante (~64KB), no 4GB.
```

---

## Debugging en el Backend

Aqu칤 no hay "Inspect Element".

### `node --inspect`
Abre Chrome -> `chrome://inspect`.
Ver치s tu proceso de Node.js y podr치s usar el Debugger de Chrome (Breakpoints, Console, Memory Profiler) para tu backend.

### `console.trace()`
Te dice exactamente qui칠n llam칩 a la funci칩n.
```javascript
function peligro() {
    console.trace("쯈ui칠n me llam칩?");
}
```

### `util.debuglog`
Para logs que solo quieres ver en desarrollo.
```javascript
const debug = require('node:util').debuglog('FOO');
debug('Esto solo sale si ejecutas: NODE_DEBUG=FOO node app.js');
```

---

## Deployment y Clusters (Escalabilidad)

Node es Single Threaded. Si tienes un CPU de 8 n칰cleos, est치s desperdiciando 7.

### Modulo Cluster
Clona tu aplicaci칩n en m칰ltiples hilos (Workers) que comparten el mismo puerto TCP.
```javascript
const cluster = require('node:cluster');
const os = require('node:os');

if (cluster.isPrimary) {
    const cpus = os.cpus().length;
    for (let i = 0; i < cpus; i++) cluster.fork();
    
    cluster.on('exit', (worker) => {
        console.log(`Worker ${worker.process.pid} muri칩. Reemplazando...`);
        cluster.fork(); // Auto-restart
    });
} else {
    // C칩digo del servidor normal (Express, etc)
    require('./server.js');
}
```

### PM2 (Process Manager 2)
La herramienta est치ndar para producci칩n.
*   **Keep Alive:** Si tu app crashea, la reinicia.
*   **Logs:** Maneja la rotaci칩n de logs.
*   **Cluster Nuxt:** `pm2 start app.js -i max` (Usa todos los n칰cleos autom치ticamente).

---

---

## M칩dulos Core Esenciales (`path` y `os`)

Node te da herramientas para interactuar con el servidor.

### `path` (Rutas universales)
Windows usa `\` y Linux usa `/`. Si hardcodeas `C:\Users`, tu c칩digo explota en Linux.
```javascript
const path = require('node:path');

// Unir rutas de forma segura
const rutaCompleta = path.join(__dirname, 'uploads', 'imagen.png');
// En Windows: C:\proyecto\uploads\imagen.png
// En Linux: /proyecto/uploads/imagen.png

// Obtener extensi칩n
console.log(path.extname('foto.jpg')); // ".jpg"
```

### `os` (Sistema Operativo)
Diagn칩stico del servidor.
```javascript
const os = require('node:os');

console.log(os.freemem()); // Memoria libre (Bytes)
console.log(os.platform()); // 'win32', 'linux', 'darwin' (Mac)
console.log(os.cpus()); // Info detallada de cada n칰cleo
```

---

## Patr칩n Observer (`EventEmitter`)

Casi todo en Node hereda de `EventEmitter` (Streams, HTTP Server, Sockets).
Es el sistema de publicaci칩n/suscripci칩n nativo.

```javascript
const EventEmitter = require('node:events');
const emisor = new EventEmitter();

// 1. Suscribirse (Escuchar)
emisor.on('compra', (total) => {
    console.log(`Se realiz칩 una compra de $${total}`);
    enviarEmailRecibo();
});

emisor.on('compra', (total) => {
    actualizarInventario();
});

// 2. Publicar (Emitir)
emisor.emit('compra', 500);
```
*   **Nota:** Es s칤ncrono por defecto. Si el listener falla, detiene el resto.

---

## Child Processes (Procesos Hijos)

Node es bueno gestionando I/O, pero malo comprimiendo video.
쯉oluci칩n? Llama a un programa externo (como `ffmpeg` o `python`).

### `exec` (Comandos simples)
Ejecuta un comando de terminal y guarda toda la salida en un buffer (RAM).
L칤mite por defecto: 1MB.
```javascript
const { exec } = require('node:child_process');

exec('ls -lh', (error, stdout, stderr) => {
    if (error) return console.error(error.message);
    console.log(`Salida: ${stdout}`);
});
```

### `spawn` (Flujos de datos)
Para procesos largos (ej. convertir video). Usa Streams.
```javascript
const { spawn } = require('node:child_process');

// Ejecuta "ping google.com"
const proceso = spawn('ping', ['google.com']);

proceso.stdout.on('data', (data) => {
    console.log(`Ping dice: ${data}`);
});

proceso.on('close', (code) => {
    console.log(`Proceso termin칩 con c칩digo ${code}`);
});
```
*   **Diferencia:** `exec` espera a que termine. `spawn` te da los datos en vivo.

---

---

## Manejo de Errores Cr칤ticos

Si un error no se captura (`catch`), Node.js crashea y el servidor se apaga.

### `uncaughtException`
El 칰ltimo recurso. Atrapa errores s칤ncronos no manejados.
```javascript
process.on('uncaughtException', (err) => {
    console.error('CRITICAL ERROR:', err);
    // Recomendaci칩n: Reiniciar el proceso limpiamente
    process.exit(1);
});

// Esto har칤a crashear el servidor sin el handler
funcionInexistente(); 
```

### `unhandledRejection`
Para Promesas que fallaron sin `.catch()`.
```javascript
process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
    // En versiones nuevas de Node, esto tambi칠n cerrar치 el proceso pronto.
});
```

---

## Worker Threads (El verdadero Multi-Threading)

A diferencia de `Child Process` (que es otro programa), los `Worker Threads` comparten memoria (ArrayBuffer) con el padre. S칰per r치pido.

```javascript
/* main.js */
const { Worker, isMainThread, parentPort } = require('node:worker_threads');

if (isMainThread) {
    // Hilo Principal
    const worker = new Worker(__filename);
    worker.on('message', msg => console.log('Worker dijo:', msg));
    worker.postMessage('Trabaja!');
} else {
    // Hilo Secundario
    parentPort.on('message', (msg) => {
        // Simular trabajo pesado CPU
        let x = 0;
        while(x < 1e9) x++;
        parentPort.postMessage('Termin칠 ' + x);
    });
}
```
*   **Uso:** Procesamiento de im치genes, Criptograf칤a, Machine Learning.

---

## Seguridad Basica en Node.js

### Evitar Eval
Nunca uses `eval()`. En el backend es acceso root garantizado para el hacker.

### Validar Entradas
Node no tiene tipos en tiempo de ejecuci칩n. Si esperas un n칰mero y recibes un objeto, puede explotar.
Usa librer칤as como **Zod** o **Joi** incluso antes de usar Express.

### Rate Limiting
Node es r치pido, pero un ataque DDoS s칤ncrono (ReDoS) puede tumbarlo.
Nunca uses Regex complejos con datos del usuario.

```javascript
// Malo (Vulnerable a ReDoS)
const regex = /(a+)+b/;
regex.test("aaaaaaaaaaaaaaaaaaaaaaaaaaaaa"); // Congela el CPU
```

---

---

## El Futuro del Runtime (Node vs Deno vs Bun)

Node.js ya no es el 칰nico rey. Ryan Dahl (creador de Node) se arrepinti칩 de sus errores y cre칩 Deno.

### Deno
*   **Seguro por defecto:** No tiene acceso a red ni disco a menos que le des permiso (`--allow-net`).
*   **TypeScript Nativo:** No necesitas `tsc`. Ejecuta `.ts` directo.
*   **Est치ndar Web:** Usa `fetch`, `window` igual que el navegador.

### Bun (El Demonio de Velocidad)
*   Escrito en **Zig**.
*   Start-up time instant치neo (x3 mas r치pido que Node).
*   Compatible con NPM (reemplaza `npm install` con `bun install` y vuela).
*   **Veredicto 2025:** Node sigue siendo el est치ndar empresarial. Bun es excelente para scripts y desarrollo local.

---

<div align="center">

[拘勇 Anterior: Unidad 3](../unidad3/README.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 4.2 Estructuras de Control](4.2.md) 俱뫮잺

</div>
