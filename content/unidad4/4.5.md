# 4.5 Creación de Clases (Arquitectura del Servidor)

Escribir todo en `app.get()` (Spaghetti Code) funciona para demos, pero es suicidio en producción.
Organizamos el código en **Clases** y **Capas**.

---

## ¿Por qué Clases en el Backend?

Node.js es funcional por naturaleza, pero la **Programación Orientada a Objetos (POO)** nos da:
1.  **Encapsulamiento:** Ocultar lógica compleja.
2.  **Inyección de Dependencias:** Facilita el testing.
3.  **Organización:** Agrupar métodos relacionados (`UserService.create`, `UserService.delete`).

---

## Las 3 Capas Sagradas (Controller - Service - Repository)

Esta es la arquitectura estándar en la industria (NestJS, Java Spring, C# .NET).

### 1. Controller (El Recepcionista)
*   Habla el idioma HTTP (`req`, `res`).
*   Valida los datos de entrada.
*   **No tiene lógica.** Solo llama al Servicio.

### 2. Service (El Cerebro)
*   Contiene toda la **Lógica de Negocio**.
*   No sabe qué es HTTP. Recibe datos puros y devuelve datos puros.
*   Ejemplo: "Si el usuario existe, lanza error. Si no, hashea password y llama al repo".

### 3. Repository (La Biblioteca)
*   Habla con la Base de Datos (SQL, Mongo).
*   Solo sabe guardar, buscar y borrar. Nada de lógica compleja.

---

## DTOs (Data Transfer Objects)

Nunca pases el objeto `req.body` crudo hasta la base de datos.
Crea clases que definan qué datos viajan.

```javascript
class CreateUserDto {
    constructor(data) {
        this.email = data.email;
        this.password = data.password;
        // Sanitización automática
        this.role = 'USER'; // Forzar rol, ignorar si el hacker envió role: 'ADMIN'
    }
}
```

---

---

## Inyección de Dependencias (El Contenedor)

Si haces `new UserService()` manualmente, estás creando acoplamiento.
Usa un **Container** (como Awilix o Inversify) o el nativo de NestJS.

### Composition Root (Donde se une todo)
Es el lugar donde instancias tus clases y las conectas entre sí.
```javascript
const repo = new UserRepository();
const service = new UserService(repo);
const controller = new UserController(service); // Inyección Manual

// Ahora Express usa el controller ya configurado
app.post('/users', (req, res) => controller.create(req, res));
```
Esto permite cambiar `repo` por un `MockRepository` en los tests fácilmente.

---

## Principios SOLID en Backend

Escribir clases no te hace buen programador OO. Seguir SOLID sí.

### Single Responsibility (SRP)
*   **Mal:** `UserController` valida el email, guarda en DB y envía el correo.
*   **Bien:** `UserController` llama a `Validator`, luego a `Service`.

### Open/Closed (OCP)
*   **Problema:** Tienes `PaymentService`. Quieres agregar PayPal. Si modificas la clase `PaymentService`, puedes romper Visa.
*   **Solución:**
    ```javascript
    class PaymentProcessor { pay(amount) { throw "Not Implemented"; } }
    
    class Visa extends PaymentProcessor { pay(amount) { ... } }
    class PayPal extends PaymentProcessor { pay(amount) { ... } }
    ```
    Tu código acepta cualquier hijo de `PaymentProcessor`.

### Dependency Inversion (DIP)
Los módulos de alto nivel (Controller) no deben depender de bajo nivel (MySQL Driver). Ambos deben depender de **Abstracciones**.
*   Tu Servicio no debe importar `mysql`. Debe importar `IRepository`.
*   Hoy es MySQL, mañana es Mongo. Si dependes de la abstracción, cambiar es cambiar una línea en el Container.

---

## Decoradores (Metaprogramación)

Popularizados por NestJS (y Angular). Son funciones que modifican clases.
En JS vainilla (sin TypeScript) requieren Babel, pero es el futuro estándar.

```javascript
@Controller('/users')
class UserCtrl {
    
    @Get('/:id')
    @Auth('ADMIN')
    getUser() { ... }
}
```
*   **¿Cómo funciona?** `@Auth` es una función que envuelve a `getUser` y ejecuta lógica antes (Middleware).

---

---

## Factory Pattern (Creación Compleja)

Cuando crear un objeto requiere lógica (ej. configurar un método de pago según el país).

```javascript
class PaymentFactory {
    static getProvider(country) {
        if (country === 'MX') return new ConectaProvider();
        if (country === 'US') return new StripeProvider();
        if (country === 'AR') return new MercadoPagoProvider();
        throw new Error("País no soportado");
    }
}

// Uso
const provider = PaymentFactory.getProvider(req.body.country);
await provider.charge(100);
```

---

## Adapter Pattern (Estandarización)

Tienes `Stripe` y `PayPal`. Tienen métodos diferentes (`stripe.charges.create` vs `paypal.payment.create`).
Crea un Adaptador para que tu sistema solo conozca una interfaz.

```javascript
class PaymentAdapter {
    pay(amount, currency) { throw "Implementar"; }
}

class StripeAdapter extends PaymentAdapter {
    constructor(sdk) { super(); this.sdk = sdk; }
    
    async pay(amount, currency) {
        return this.sdk.charges.create({ amount, currency });
    }
}

// Ahora tu Controller solo llama a adapter.pay(), le da igual si es Stripe o PayPal.
```

---

## Facade Pattern (Fachada)

Tu sistema de "Compra" es complejo:
1.  Verificar Stock.
2.  Calcular Impuestos.
3.  Cobrar Tarjeta.
4.  Generar Factura.
5.  Enviar Email.

No hagas todo eso en el Controller. Crea una **Facade**.

```javascript
class PurchaseFacade {
    async purchase(userId, itemId) {
        await this.inventory.reserve(itemId);
        const tax = await this.tax.calc(itemId);
        await this.bank.charge(userId, itemId, tax);
        await this.email.send(userId);
    }
}

// Controller
await purchaseFacade.purchase(req.user.id, req.body.itemId); // Una sola línea
```

---

---

## Observer Pattern (Desacoplar Lógica)

Cuando el usuario se registra, hay que enviar Email, crear Wallet, notificar a Slack...
Si pones todo en `UserService`, se vuelve un monstruo.

```javascript
/* user.events.js */
eventBus.on('USER_CREATED', async (user) => {
    await emailService.sendWelcome(user);
});

eventBus.on('USER_CREATED', async (user) => {
    await slack.notifyNewUser(user);
});

/* user.service.js */
async register(data) {
    const user = await repo.save(data);
    eventBus.emit('USER_CREATED', user); // ¡Listo! El Service no sabe qué pasa después.
}
```

---

## Strategy Pattern (Polimorfismo en Runtime)

¿Tu código tiene `switch(tipo)` gigantes?
"Si es PREMIUM, descuento 20%. Si es GOLD, descuento 50%...".

```javascript
// Estrategias
const strategies = {
    'FREE': (price) => price,
    'PREMIUM': (price) => price * 0.8,
    'GOLD': (price) => price * 0.5
};

// Contexto
function calcularPrecio(tipo, precioBase) {
    const estrategia = strategies[tipo] || strategies['FREE'];
    return estrategia(precioBase);
}
```
Eliminaste 20 `if/else` con un objeto.

---

## Command Pattern (Acciones como Objetos)

Convierte una acción (`crear_orden`) en un objeto (`CreateOrderCommand`).
Útil para:
*   Cola de tareas (RabbitMQ).
*   Deshacer (Undo).

```javascript
class CreateOrderCommand {
    constructor(orderId) { this.orderId = orderId; }
    
    execute() { db.orders.create(this.orderId); }
    undo() { db.orders.delete(this.orderId); }
}

const command = new CreateOrderCommand(123);
try {
    command.execute();
} catch (e) {
    command.undo(); // Rollback manual
}
```

---

---

## Active Record vs Data Mapper

¿Cómo hablan tus objetos con la BD?

### Active Record (Mongoose, Sequelize v5)
El modelo es la base de datos.
```javascript
// La clase Usuario tiene métodos .save()
const user = new User({ name: 'Juan' });
await user.save(); // El objeto se guarda a sí mismo
```
*   **Pro:** Rápido de escribir.
*   **Contra:** Mezcla lógica y persistencia. Viola SRP.

### Data Mapper (TypeORM, MikroORM)
El modelo es puro. El repositorio guarda.
```javascript
const user = new User();
user.name = 'Juan';
await userRepository.persist(user); // El objeto no sabe guardar
```
*   **Pro:** Desacoplamiento total.
*   **Contra:** Más verboso.

---

## Value Objects (Objetos de Valor)

En DDD, un `Email` no es un string. Es un objeto.
Si es un string, puede ser "tacos". Si es un `Email`, garantiza ser válido.

```javascript
class Email {
    constructor(address) {
        if (!address.includes('@')) throw new Error("Email inválido");
        this.address = address;
    }
    
    equals(other) {
        return this.address === other.address;
    }
}

class User {
    constructor(emailString) {
        this.email = new Email(emailString);
    }
}
```
Ahora es **imposible** tener un usuario con email inválido en tu sistema.

---

## Testing de Arquitectura (Mocking)

Gracias a la Inyección de Dependencias, testear el `UserService` es trivial.

```javascript
// Test Unitario de UserService
test('debe registrar usuario', async () => {
    // 1. Mockear dependencias
    const repoMock = { 
        exists: jest.fn().mockResolvedValue(false),
        save: jest.fn().mockResolvedValue({ id: 1 })
    };
    
    const service = new UserService(repoMock);
    
    // 2. Ejecutar
    await service.register('test@test.com', '123456');
    
    // 3. Verificar que llamó al repo
    expect(repoMock.save).toHaveBeenCalled();
});
```
Fíjate que **NO** levantamos base de datos. El test corre en 5ms.

---

---

## Singleton Pattern (Única Instancia)

Node.js cachea los módulos. `require('./config')` devuelve *el mismo objeto* siempre.
Ya es un Singleton. Pero si usas Clases:

```javascript
class DatabaseConnection {
    constructor() {
        if (!DatabaseConnection.instance) {
            this.connection = createConnection();
            DatabaseConnection.instance = this;
        }
        return DatabaseConnection.instance;
    }
}
// Siempre devuelve la misma instancia, no abre 1000 conexiones.
```

---

## Mixins (Composición sobre Herencia)

JavaScript no tiene herencia múltiple (`class A extends B, C` explota).
Solución: Mixins. Funciones que añaden métodos a una clase.

```javascript
const Timestampable = Base => class extends Base {
    getCreatedAt() { return this.createdAt; }
    getUpdatedAt() { return this.updatedAt; }
};

const SoftDeletable = Base => class extends Base {
    delete() { this.deletedAt = new Date(); }
};

class User extends Timestampable(SoftDeletable(Object)) {
    // Tiene getCreatedAt() Y delete()
}
```

---

## Template Method (Esqueleto de Algoritmo)

Define el esqueleto de un algoritmo en la clase padre, pero deja que los hijos implementen los pasos específicos.

```javascript
class DataImporter {
    // El método plantilla (Nadie lo toca)
    async import(file) {
        const rawData = await this.readFile(file);
        const data = this.parse(rawData);
        await this.save(data);
    }

    readFile() { throw "Implementar"; }
    parse() { throw "Implementar"; }
    save() { throw "Implementar"; }
}

class CsvImporter extends DataImporter {
    readFile(file) { return fs.readFile(file); }
    parse(raw) { return raw.split(','); }
    save(data) { return db.save(data); }
}
```

---

## Patrones de Microservicios (Strangler Fig)

¿Tienes un monolito gigante y quieres migrarlo a microservicios?
No lo reescribas desde cero.
1.  Pon un Proxy enfrente.
2.  Redirige `/api/users` nuevo microservicio Node.js.
3.  Todo lo demás sigue yendo al monolito viejo (Java/PHP).
4.  Repite hasta que el monolito desaparezca.

---

---

## Prototype Pattern (Clonación)

En JS, crear objetos nuevos es barato. Pero clonar una configuración compleja es útil.

```javascript
class GameConfig {
    constructor() {
        this.difficulty = 'medium';
        this.graphics = { shadow: true, antialias: true };
    }

    clone() {
        const clone = new GameConfig();
        clone.difficulty = this.difficulty;
        clone.graphics = { ...this.graphics }; // Deep copy manual
        return clone;
    }
}

const defaultConfig = new GameConfig();
const userConfig = defaultConfig.clone();
userConfig.difficulty = 'hard'; // No afecta a defaultConfig
```

---

---

## Chain of Responsibility (Cadena de Mando)

Express.js es una Chain of Responsibility gigante.
Cada middleware decide si pasa la pelota (`next()`) o la responde.

### Uso en Lógica de Negocio
Validar una compra compleja:
`StockCheck -> BalanceCheck -> FraudCheck -> FinalizeOrder`

```javascript
class Handler {
    setNext(handler) { this.next = handler; return handler; }
    handle(request) { if (this.next) return this.next.handle(request); }
}

class FraudCheck extends Handler {
    handle(req) {
        if (req.amount > 10000) throw new Error("Posible Fraude");
        return super.handle(req);
    }
}
```

---

## Proxy Pattern (Lazy Loading)

Tienes un objeto pesado `VideoConverter` que tarda 5s en iniciar.
No lo inicies si no lo vas a usar. Usa un Proxy.

```javascript
class RealConverter {
    constructor() { console.log("Cargando ffmpeg..."); }
    convert() { ... }
}

class ProxyConverter {
    convert() {
        if (!this.real) this.real = new RealConverter(); // Lazy
        return this.real.convert();
    }
}
```

---

## Bridge Pattern (Desacoplar Abstracción)

Separa "Qué haces" de "Cómo lo haces".
*   **Abstracción:** `Mensajeria` (enviar, recibir).
*   **Implementación:** `SMS`, `Email`, `WhatsApp`.

```javascript
class Mensajeria {
    constructor(canal) { this.canal = canal; } // Inyección
    enviar(msg) { this.canal.enviarTexto(msg); }
}

const sms = new SMSCanal();
const sistema = new Mensajeria(sms);
sistema.enviar("Hola"); // Envía SMS
```

---

## Arquitectura Hexagonal (Ports & Adapters)

Más allá de capas. Tu núcleo (Dominio) no debe saber NADA del mundo exterior.

*   **Dominio:** `User`, `Transfer`. Pura lógica JS. Sin `express`, sin `mongoose`.
*   **Puertos (Interfaces):** `UserRepositoryPort` (define qué necesita el dominio).
*   **Adaptadores (Infraestructura):** `MongoUserRepository` (implementa el puerto).

**Regla:** Las dependencias apuntan hacia ADENTRO.
La base de datos depende del Dominio. El Dominio NO depende de la DB.

---

<div align="center">

[⬅️ Anterior: 4.4 Manejo de Objetos](4.4.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 4.6 Acceso a Datos](4.6.md) ➡️

</div>
