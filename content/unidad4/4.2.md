# 4.2 Estructuras de Control (Backend Logic)

En el backend, no controlamos clicks del usuario. Controlamos **Peticiones HTTP**.
Tu código es una tubería (pipeline) por donde pasan los datos.

---

## El Patrón Middleware (Chain of Responsibility)

Es el corazón de Express, NestJS y Koa.
Imagina una línea de ensamblaje de coches.
1.  Pasa el chasis (Request).
2.  Un robot pone las ruedas (Middleware de Log).
3.  Otro robot pinta la puerta (Middleware de Auth).
4.  Si algo falla, se tira a la basura (Error Middleware).

### Anatomía de un Middleware
Imagina una línea de ensamblaje. Cada función puede hacer algo con la petición (`req`) y luego pasarla al siguiente (`next()`).
```javascript
// Middleware simple
app.use((req, res, next) => {
    console.log("Nueva petición!");
    next(); // ¡Indispensable! Si no, la petición se queda colgada.
});
```
*   **Uso:** Autenticación, Logs, validación de datos.

---

## Enrutamiento (Routing Logic)

El "Traffic Controller" de tu API. Decide qué función ejecuta qué URL.

### Verbos HTTP (Semántica)
Usa el verbo correcto para cada acción:
*   `GET`: Leer datos.
*   `POST`: Crear datos nuevos.
*   `PUT`: ACTUALIZAR todo el recurso.
*   `PATCH`: ACTUALIZAR solo una parte.
*   `DELETE`: Borrar.

### Parámetros Dinámicos
```javascript
// GET /users/123
app.get('/users/:id', (req, res) => {
    const id = req.params.id; // "123"
    buscarUsuario(id);
});
```

---

## Control de Flujo Asíncrono en Servidores

El servidor maneja 1000 usuarios a la vez. No puedes bloquear el hilo principal.

### Async / Await en Controladores
Controla el flujo sin bloquear el servidor.
```javascript
app.get('/productos', async (req, res, next) => {
    try {
        const data = await db.find();
        res.json(data);
    } catch (error) {
        next(error); // Pasa el error al middleware de manejo de errores
    }
});
```

### Promise.all (Paralelismo)
Si vas a consultar 3 cosas independientes, hazlo en paralelo.
```javascript
// Rápido: Lanza las dos a la vez
const [user, posts] = await Promise.all([
    db.users.find(id),
    db.posts.find(id)
]);
```

---

## Manejo de Errores Centralizado

Nunca llenes tu código de `try-catch` repetidos. Usa un Middleware de Error.

### Error Handler Centralizado
En lugar de repetir `res.status(500)` en todos lados, usa esto al final de tus rutas:
```javascript
app.use((err, req, res, next) => {
    console.error(err); // Log interno
    res.status(500).json({ error: "Algo salió mal" }); // Respuesta segura al cliente
});
```
**Regla:** Nunca envíes detalles técnicos (`err.stack`) al usuario final. Es peligroso.
---

---

## Guards e Interceptors (Patrones Avanzados)

Aunque son nativos de NestJS, puedes (y debes) aplicarlos en Express.

### Guards (Autorización)
¿Puede este usuario ver este recurso?
```javascript
const isAdmin = (req, res, next) => {
    // Asumimos que un middleware anterior decodificó el JWT
    if (req.user && req.user.role === 'ADMIN') {
        next();
    } else {
        res.status(403).json({ error: "Forbidden: Solo Admins" });
    }
};

app.delete('/users/:id', isAdmin, borrarUsuario);
```

### Interceptors (Transformación)
Modificar la respuesta *antes* de que le llegue al cliente.
En Express nativo es difícil (requiere monkey-patching `res.send`), pero es vital entender el concepto.
*   **Caso de Uso:** Ocultar el campo `password` de todos los JSON que salen del servidor.
*   **Solución:** Sobrescribir `res.json` temporalmente.

---

## Pipelines de Validación

No valides con `if (req.body.email)`. Usa esquemas.
El patrón "Schema Validation" separa la regla de validación de la lógica de negocio.

### Usando Zod (La mejor librería moderna)
```javascript
const { z } = require('zod');

const registroSchema = z.object({
    email: z.string().email(),
    password: z.string().min(8),
    age: z.number().min(18)
});

// Middleware de Validación Genérico
const validar = (schema) => (req, res, next) => {
    try {
        schema.parse(req.body); // Si falla, lanza error
        next();
    } catch (error) {
        res.status(400).json(error.errors);
    }
};

app.post('/registro', validar(registroSchema), registrarUsuario);
```
*   **Ventaja:** Tu controlador `registrarUsuario` ahora confía ciegamente en que los datos están limpios.

---

## Inyección de Dependencias (DI)

Control de Flujo para la Arquitectura.

### El Problema (Acoplamiento)
```javascript
// Mal: Controlador crea su propia conexión a DB
const db = require('./database'); 
// Si quieres testear esto, NO puedes (la DB es real).
```

### La Solución (Inversión de Control)
Pasar las dependencias como argumentos.
```javascript
class UserController {
    constructor(userService) {
        this.service = userService; // Inyectado
    }

    async get(req, res) {
        const user = await this.service.find(req.params.id);
        res.json(user);
    }
}

// Composition Root (Donde armas el rompecabezas)
const service = new UserService(dbReal); // O dbFalsa para tests
const controller = new UserController(service);
```

---

---

## Rate Limiting (Control de Tráfico)

Si no pones un límite, un script te tumbará el servidor en 1 segundo.
El control de flujo empieza en la puerta.

### Token Bucket Algorithm
Imagina una cubeta con monedas.
*   Cada petición cuesta 1 moneda.
*   La cubeta se rellena a 10 monedas por segundo.
*   Si la cubeta está vacía, rechazas la petición (`429 Too Many Requests`).

### Implementación básica
```javascript
const rateLimit = require('express-rate-limit');

const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutos
    max: 100, // Límite de 100 peticiones por IP
    message: "Calma, vaquero. Demasiadas peticiones."
});

app.use(limiter);
```

---

## Feature Flags (Toggles)

¿Cómo desplegar código nuevo sin romper nada? Apágalo.
Esto es un `if` glorificado, pero controlado remotamente.

```javascript
/* config/flags.js */
const flags = {
    NEW_DASHBOARD: false, // Apagado en producción
    BETA_USERS: true     // Encendido
};

/* controller.js */
app.get('/dashboard', (req, res) => {
    if (flags.NEW_DASHBOARD) {
        return res.json({ msg: "Bienvenido al Futuro" });
    }
    // Lógica Vieja
    res.json({ msg: "Dashboard Clásico" });
});
```
*   **Pro:** Puedes activar features para el 10% de usuarios (Canary Release).

---

## Circuit Breaker (Cortocircuito)

Si la API de Pagos está caída, **NO** sigas enviándole peticiones (y esperando 30s de timeout).
Corta el cable.

### Estados
1.  **Cerrado (Normal):** Las peticiones pasan.
2.  **Abierto (Error):** Si fallan 5 seguidas, bloqueamos el paso y respondemos error inmediato.
3.  **Semi-Abierto:** Después de 1 minuto, dejamos pasar 1 sola petición de prueba. Si funciona, cerramos el circuito.

```javascript
const breaker = new CircuitBreaker(hacerPago, {
    errorThresholdPercentage: 50,
    resetTimeout: 10000 // Esperar 10s antes de reintentar
});

breaker.fire({ monto: 100 })
    .then(console.log)
    .catch(err => console.error("Servicio de Pagos Caído"));
```

---

---

## Caching Strategies (Control de Flujo de Datos)

La mejor query es la que no se hace.

### Cache-Aside Pattern
1.  Servidor pregunta al Cache (Redis).
2.  ¿Existe? Devuelve dato.
3.  ¿No existe? Consulta DB, guarda en Cache, devuelve dato.

```javascript
/* Middleware de Caching */
const cachear = async (req, res, next) => {
    const key = `user:${req.params.id}`;
    const cached = await redis.get(key);
    
    if (cached) return res.json(JSON.parse(cached));
    
    // Si no hay cache, monkey-patch res.json para guardar al salir
    res.sendResponse = res.json;
    res.json = (body) => {
        redis.set(key, JSON.stringify(body), 'EX', 60); // TTL 60s
        res.sendResponse(body);
    };
    next();
};
```

---

## Webhooks (Control de Flujo Inverso)

En lugar de que tú llames a la API, la API te llama a ti.
Caso típico: Stripe te avisa que un pago fue exitoso.

### Recepción Segura
Cualquiera puede enviar una petición POST a tu ruta `/webhooks/stripe`.
Debes verificar la **Firma Criptográfica**.

```javascript
app.post('/webhook', express.raw({ type: 'application/json' }), (req, res) => {
    const sig = req.headers['stripe-signature'];
    
    try {
        // Stripe verifica que el body no fue alterado
        const event = stripe.webhooks.constructEvent(req.body, sig, endpointSecret);
        
        if (event.type === 'payment_intent.succeeded') {
            activarPlanUsuario(event.data.object);
        }
    } catch (err) {
        return res.status(400).send(`Webhook Error: ${err.message}`);
    }
    
    res.json({ received: true });
});
```

---

## Observability (Logging & Tracing)

Si el servidor falla a las 3 AM, `console.log` no sirve.
Necesitas saber **dónde** y **por qué** se rompió el flujo.

### Logging Estructurado (Winston/Pino)
Loguea objetos JSON, no strings.
```javascript
logger.info({ 
    event: 'login_attempt', 
    user_id: 123, 
    ip: '192.168.1.1' 
});
// ElasticSearch puede indexar esto. String plano no.
```

### Distributed Tracing (OpenTelemetry)
Si usas Microservicios:
A -> llama a -> B -> llama a -> C.
Si C falla, ¿cómo sabes que la culpa fue del dato que envió A?
El `Trace ID` viaja en los Headers (`x-request-id`) a través de toda la cadena.

---

---

## Colas de Mensajes (Message Queues)

Cuando una tarea tarda más de 500ms, **NO** la hagas en la petición HTTP.
Sácala del flujo principal.

### Producer-Consumer (BullMQ)
1.  **Producer:** API recibe el archivo y crea un "Job". Responde "OK, procesando".
2.  **Queue:** Redis guarda el Job.
3.  **Consumer:** Un Worker (proceso en segundo plano) toma el Job y lo procesa.

```javascript
/* controller.js */
app.post('/video', async (req, res) => {
    await videoQueue.add('transcode', { file: req.file.path });
    res.json({ msg: "Video en cola" }); // Respuesta instantánea
});

/* worker.js */
const worker = new Worker('video', async job => {
    await ffmpeg(job.data.file).convert();
});
```

---

## Server-Sent Events (SSE)

WebSockets son bidireccionales y complejos.
Si solo quieres enviar notificaciones del Servidor -> Cliente (ej. Crypto Ticker, Chat Feed), usa SSE.

```javascript
app.get('/events', (req, res) => {
    res.setHeader('Content-Type', 'text/event-stream');
    res.setHeader('Cache-Control', 'no-cache');
    res.setHeader('Connection', 'keep-alive');

    const intervalo = setInterval(() => {
        const data = { time: new Date() };
        res.write(`data: ${JSON.stringify(data)}\n\n`); // Formato especial "\n\n"
    }, 1000);

    req.on('close', () => clearInterval(intervalo));
});
```

---

## GraphQL (Flujo por Resolvers)

En REST, el flujo es lineal (Ruta -> Controller).
En GraphQL, el flujo es un árbol.

### Resolver Chain
El cliente pide `User { posts { comments } }`.
1.  **Query Resolver:** `getUser(id)` -> Retorna Objeto User.
2.  **Field Resolver:** `User.posts(parent)` -> Usa el `parent.id` para buscar Posts.
3.  **Field Resolver:** `Post.comments(parent)` -> Usa `parent.id` para buscar Comments.

```javascript
const resolvers = {
    Query: {
        user: (parent, args) => db.users.find(args.id),
    },
    User: {
        posts: (parent) => db.posts.filter(p => p.userId === parent.id),
    }
};
// N+1 Problem: Cuidado con hacer 100 queries a la DB aquí (Usa DataLoader).
```

---

---

## Sagas Pattern (Transacciones Distribuidas)

En Microservicios, no existe `BEGIN TRANSACTION` y `COMMIT` entre dos bases de datos distintas.
Si el Paso 1 (Cobrar tarjeta) funciona, pero el Paso 2 (Enviar email) falla... ¿cómo devuelves el dinero?

### Compensación
Cada acción debe tener una reacción inversa (Undo).
1.  **Ejecutar:** `ChargeCreditCard(100)` -> OK.
2.  **Ejecutar:** `CreateOrder()` -> ERROR.
3.  **Compensar:** `RefundCreditCard(100)` -> OK.

---

## Cron Jobs (Tareas Programadas)

El control de flujo en el tiempo.
"Ejecutar cada lunes a las 9 AM".

### Node-Cron
```javascript
const cron = require('node-cron');

// 0 9 * * 1 (Minuto 0, Hora 9, Cualquier día, Cualquier mes, Lunes)
cron.schedule('0 9 * * 1', () => {
    enviarReporteSemanal();
});
```
*   **Advertencia:** Si tu servidor se reinicia, pierdes la ejecución.
    *   **Solución Pro:** Usa Redis o una DB para guardar el estado de la tarea.

---

## Arquitecturas de Backend

¿Cómo organizas tus carpetas y tu flujo?

### MVC (Model-View-Controller)
El clásico. Simple, pero se vuelve espagueti en apps grandes.
*   **Controller:** Recibe HTTP, llama al Modelo, responde JSON.
*   **Model:** Logica de DB.

### Hexagonal / Clean Architecture (Domain Driven Design)
El estándar empresarial (NestJS).
*   **Domain:** La lógica pura (Entidades). No sabe nada de HTTP ni de SQL.
*   **Infrastructure:** Adaptadores (Repository impl con TypeORM, Controller con Express).
*   **Application:** Casos de uso (`CrearUsuarioUseCase`).

---

---

## Estándar de Errores (RFC 7807)

No inventes formatos de error (`{ err: "falla" }`). Usa el estándar.
**Problem Details for HTTP APIs.**

```json
{
  "type": "https://api.empresa.com/errors/saldo-insuficiente",
  "title": "Saldo Insuficiente",
  "status": 403,
  "detail": "Tu saldo actual es $5.00 y el producto cuesta $10.00",
  "instance": "/compras/123456"
}
```
Esto permite que el Frontend sepa *exactamente* qué mostrar.

---

## Idempotencia (Idempotency)

Si el usuario hace clic 2 veces en "Pagar", ¿cobras 2 veces?
Para operaciones críticas (POST), usa una `Idempotency-Key` en el Header.

1.  Cliente envía Header: `Idempotency-Key: abd-123-xyz`.
2.  Servidor revisa Redis: "¿Ya procesé la key abd-123-xyz?".
3.  Si sí: Devuelve la respuesta anterior guardada (sin cobrar de nuevo).
4.  Si no: Procesa y guarda el resultado.

---

## BFF Pattern (Backend For Frontend)

Si tienes Web, App Móvil y Smart Watch... ¿usas la misma API para todos?
El patrón BFF dice: **No**.
Crea una capa ligera para cada cliente.

*   **API Principal:** Gestiona datos crudos.
*   **BFF Mobile:** Recorta datos para ahorrar 4G.
*   **BFF Web:** Agrega datos para mostrar dashboards ricos.
*   **BFF Watch:** Solo envía notificaciones push.

---

---

## Documentación Viva (Swagger/OpenAPI)

Tu API no existe si no está documentada.
Olvídate de mantener un PDF o Word manual.

### Swagger UI
Genera una web interactiva donde puedes probar endpoints.
```javascript
const swaggerUi = require('swagger-ui-express');
const swaggerDoc = require('./swagger.json');

app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerDoc));
```
*   **Best Practice:** Genera el JSON automáticamente desde tu código (usando decoradores en NestJS o comentarios JSDoc en Express).

---

<div align="center">

[⬅️ Anterior: 4.1 Introducción al Lenguaje](4.1.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 4.3 Tratamiento de Formularios](4.3.md) ➡️

</div>
