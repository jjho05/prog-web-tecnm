# 4.4 Manejo de Objetos del Servidor (Request & Response)

Todo en la web es una conversación:
**Cliente:** "Pido X" (`req`)
**Servidor:** "Toma Y" (`res`)

---

## El Objeto Request (`req`)

### `req.params`, `req.query` y `req.body`
*   **`req.params`:** Parte de la URL. Obligatorio. (`/users/:id` -> `req.params.id`).
*   **`req.query`:** Después del signo `?`. Opcional. (`/users?sort=asc` -> `req.query.sort`).
*   **`req.body`:** Datos que viajan "ocultos" (JSON). Usado en POST/PUT.

### Headers y Metadata
`req` también tiene info técnica:
*   `req.ip`: La IP del cliente.
*   `req.headers`: Tokens (`Authorization`), Idioma (`Accept-Language`).

---

## El Objeto Response (`res`)

### Códigos de Estado (Status Codes)
*   **200 OK:** Todo bien.
*   **201 Created:** Creé algo nuevo (POST).
*   **400 Bad Request:** Envaste datos mal.
*   **401/403:** No puedes pasar (Auth).
*   **404 Not Found:** No existe.
*   **500:** Explotó el servidor (Bug nuestro).

### Metodos de Respuesta
```javascript
res.send("<h1>Hola</h1>");    // Envía HTML
res.json({ id: 1 });          // Envía JSON (API)
res.status(404).send("Bad");  // Cambia el status
```

### Res.locals (El bolsillo del Request)
Variable temporal que vive solo durante la petición. Ideal para pasar datos entre Middlewares.
```javascript
// Middleware
req.user = await db.findUser(); // Mal (Modificar req es sucio)
res.locals.user = await db.findUser(); // Bien
```

---

## Headers HTTP Esenciales

Controlan el comportamiento del navegador.

### Caching (`Cache-Control`)
Dile al navegador que guarde la imagen por 1 año.
```javascript
res.set('Cache-Control', 'public, max-age=31536000');
```

### Seguridad (Security Headers)
*   `Strict-Transport-Security`: Fuerza HTTPS.
*   `X-Content-Type-Options: nosniff`: Evita que el navegador adivine el tipo de archivo.
*   `X-Frame-Options: DENY`: Evita que te pongan en un iframe.

---

---

## Cookies (El Guardián del Estado)

### ¿Qué es una Cookie?
Un dato que el servidor le pega al navegador para que lo recuerde.
El navegador lo envía de vuelta **automáticamente** en cada petición.

### Seguridad Obligatoria
*   **`httpOnly: true`**: JS no puede leerla (Previene robo XSS).
*   **`secure: true`**: Solo viaja por HTTPS.
*   **`sameSite: 'strict'`**: Previene ataques CSRF.

```javascript
res.cookie('session_id', '123', { httpOnly: true, secure: true });
```

---

## Sesiones (Stateful Auth)

El método clásico. Guardas los datos del usuario en la RAM del servidor (o Redis).

### Flujo
1.  Usuario envia User/Pass.
2.  Servidor verifica y crea un ID único (`sess_abc123`).
3.  Servidor guarda `{ sess_abc123: { userId: 1, role: 'admin' } }` en Redis.
4.  Servidor envía cookie `session_id=sess_abc123`.
5.  En la siguiente petición, Servidor busca el ID en Redis.

### Implementación (`express-session`)
```javascript
app.use(session({
    secret: 'mi_secreto_super_seguro',
    store: new RedisStore({ client: redisClient }),
    resave: false,
    saveUninitialized: false,
    cookie: { secure: true, httpOnly: true }
}));

app.get('/me', (req, res) => {
    // req.session es mágico. Se carga desde Redis automáticamente.
    res.json(req.session.user);
});
```

---

## JWT (Stateless Auth)

Json Web Tokens. El servidor no guarda nada.
El token contiene los datos y está firmado criptográficamente.

### Anatomía (Header.Payload.Firma)
1.  **Header:** "Soy un JWT con algoritmo HS256".
2.  **Payload:** Datos (`{ userId: 1, role: 'admin' }`). **Es legible por cualquiera** (Base64), no guardes secretos aquí.
3.  **Firma:** Garantiza que nadie modificó el Payload. Solo el servidor puede generarla con su `SECRET`.

### Verificación
```javascript
const jwt = require('jsonwebtoken');

// Middleware de Auth
const verifyToken = (req, res, next) => {
    const token = req.headers['authorization']?.split(' ')[1]; // Bearer <token>
    if (!token) return res.sendStatus(401);

    jwt.verify(token, process.env.JWT_SECRET, (err, decoded) => {
        if (err) return res.sendStatus(403);
        req.user = decoded; // Inyectamos el usuario en el Request
        next();
    });
};
```

---

---

## Contexto Asíncrono (`AsyncLocalStorage`)

En otros lenguajes (Java/PHP), cada petición es un hilo, así que puedes crear variables "globales" que solo ve ese hilo.
En Node.js todo es un hilo compartido.
Si haces `global.userId = 1`, ¡todos los usuarios verán que son el usuario 1!

**Solución:** `AsyncLocalStorage` (nativo de Node).
Permite tener variables "globales" aisladas por petición.

```javascript
/* context.js */
const { AsyncLocalStorage } = require('node:async_hooks');
const storage = new AsyncLocalStorage();

/* middleware.js */
app.use((req, res, next) => {
    // Iniciamos un "almacén" para esta petición
    const store = { requestId: crypto.randomUUID(), userId: req.user?.id };
    storage.run(store, () => {
        next(); // Todo lo que ocurra después tiene acceso al store
    });
});

/* logger.js (Profundo en la app) */
function log(msg) {
    const store = storage.getStore();
    // ¡Magia! Accedemos al requestId sin pasarlo por parámetros
    console.log(`[${store.requestId}] ${msg}`);
}
```

---

## El Objeto Error Global

En JS, `throw "Error"` es legal pero terrible.
Extiende la clase `Error` para tener objetos de error sémanticos en tu servidor.

```javascript
class AppError extends Error {
    constructor(message, statusCode) {
        super(message);
        this.statusCode = statusCode;
        this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
        this.isOperational = true; // Errores esperados (input inválido) vs Bugs
        Error.captureStackTrace(this, this.constructor);
    }
}

// Uso
next(new AppError('No se encontró el usuario', 404));
```

---

## Negociación de Contenido (`Accept`)

Tu API puede hablar múltiples idiomas (JSON, XML, HTML) en la misma URL.

```javascript
app.get('/data', (req, res) => {
    res.format({
        'text/plain': () => res.send('Hola'),
        'text/html': () => res.send('<h1>Hola</h1>'),
        'application/json': () => res.json({ msg: 'Hola' }),
        default: () => res.status(406).send('Not Acceptable')
    });
});
```
*   **Cliente:** Envía header `Accept: application/json` -> Recibe JSON.

---

---

## HTTP Caching Avanzado (ETag)

Si el cliente pide `/users` y no ha cambiado nada, ¿para qué enviarle 1MB de JSON?

### ETag (Entity Tag)
Express genera un hash del body (`W/"123-abc"`) automáticamente.
1.  Cliente envía `If-None-Match: W/"123-abc"`.
2.  Servidor compara. Si es igual -> Responde `304 Not Modified` (Body vacío).
3.  Cliente carga desde su caché. Ahorras ancho de banda, pero gastas CPU generando el JSON.

### Stale-While-Revalidate
"Muestra el dato viejo (stale) mientras buscas el nuevo en background".
Header: `Cache-Control: s-maxage=1, stale-while-revalidate=59`.
Ideal para CDNs (Vercel/Cloudflare).

---

## Compresión (Brotli/Gzip)

JSON es texto puro. Se comprime muy bien (hasta 90%).

```javascript
const compression = require('compression');

// ¡Ponlo lo más arriba posible!
app.use(compression({
    // Filtro: No comprimir respuestas menores a 1kb (gasta mas CPU que lo que ahorra)
    treshhold: 1024 
}));
```
*   **Gzip:** Estándar (rápido).
*   **Brotli:** Moderno (más lento, pero comprime más). Node lo soporta nativo.

---

## Métricas del Servidor

Lo que no se mide, no se mejora. Node tiene hooks para medir latencia interna.

### Server-Timing API
Envía métricas al navegador para verlas en Network Tab.

```javascript
app.use((req, res, next) => {
    const start = process.hrtime();
    
    res.on('finish', () => {
        const diff = process.hrtime(start);
        const ms = (diff[0] * 1e3 + diff[1] * 1e-6).toFixed(2);
        // Header: Server-Timing: db;dur=53, total;dur=120
        res.setHeader('Server-Timing', `total;dur=${ms}`);
    });
    
    next();
});
```

---

---

## Proxy Inverso y Headers de Confianza

Cuando despliegas en AWS o DigitalOcean, tu Node.js está detrás de un Nginx o un Load Balancer.
La petición llega del Balancer (IP interna), no del usuario (IP pública).

### `X-Forwarded-For`
El estándar de facto para saber quién es el cliente real.
```javascript
// En Express
app.set('trust proxy', 1); // Confía en el primer salto (Nginx)

app.get('/ip', (req, res) => {
    // Sin trust proxy: IP LOCAL (127.0.0.1)
    // Con trust proxy: IP REAL (189.x.x.x)
    const ip = req.ip; 
});
```
**Peligro:** Si no usas proxy y activas esto, un hacker puede falsificar su IP enviando el header falso.

---

## HATEOAS (Nivel 3 de REST)

"Hypermedia As The Engine Of Application State".
Tu API no solo devuelve datos, devuelve **el siguiente paso**.

```json
{
  "id": 1,
  "balance": 500,
  "links": [
    { "rel": "self", "method": "GET", "href": "/accounts/1" },
    { "rel": "deposit", "method": "POST", "href": "/accounts/1/deposit" },
    { "rel": "close", "method": "DELETE", "href": "/accounts/1" }
  ]
}
```
Esto permite que el Frontend sea más dinámico. Si el usuario no puede depositar, el link "deposit" desaparece.

---

## Request Upgrade (WebSockets)

¿Cómo pasas de HTTP (Request/Response) a WebSocket (Bidireccional)?
Ocurre un "Handshake Upgrade".

```javascript
server.on('upgrade', (req, socket, head) => {
    if (req.url === '/ws') {
        wss.handleUpgrade(req, socket, head, (ws) => {
             wss.emit('connection', ws, req);
        });
    } else {
        socket.destroy();
    }
});
```
Aquí el objeto `req` muere y nace un `socket` persistente.

---

---

## Health Checks (Monitoreo de Vida)

Kubernetes te preguntará cada 10s: "¿Estás vivo?". Si no respondes 200 OK, te mata y crea otro pod.

### Liveness vs Readiness
*   **Liveness (`/health/live`):** ¿El proceso Node está corriendo? (Suele ser un simple `res.send("OK")`).
*   **Readiness (`/health/ready`):** ¿Puede aceptar tráfico? (¿DB conectada? ¿Redis listo?).

```javascript
app.get('/health/ready', async (req, res) => {
    try {
        await db.$queryRaw`SELECT 1`; // Ping a DB
        res.status(200).send('READY');
    } catch (err) {
        res.status(503).send('NOT READY'); // K8s dejará de enviarte tráfico
    }
});
```

---

## Graceful Shutdown (Apagado Elegante)

Cuando haces deploy, el servidor viejo debe morir para dar paso al nuevo.
Si matas el proceso (`SIGTERM`) mientras un usuario está pagando, pierdes dinero.

```javascript
const server = app.listen(3000);

process.on('SIGTERM', () => {
    console.log('Recibido SIGTERM. Cerrando suavemente...');
    
    // 1. Dejar de recibir nuevas peticiones
    server.close(() => {
        console.log('Servidor HTTP cerrado.');
        // 2. Cerrar conexiones a DB
        db.disconnect().then(() => {
             process.exit(0); // Ahora sí, morimos en paz
        });
    });
});
```

---

## HTTP/2 y HTTP/3 (El futuro del Transport)

HTTP/1.1 es como una fila de supermercado (Head-of-Line Blocking).
HTTP/2 es multiplexado (varios carriles).

### Server Push (HTTP/2)
El servidor envía `index.html` y *proactivamente* le empuja `style.css` antes de que el navegador lo pida.
*   **Nota 2025:** Chrome depreció Server Push. Usa `103 Early Hints` en su lugar.

### HTTP/3 (QUIC / UDP)
TCP es lento por el handshake. HTTP/3 usa UDP.
Node.js soporta QUIC experimentalmente.
```bash
node --experimental-quic app.js
```

---

---

## Serialización (JSON vs Protobuf)

JSON es lento de parsear y muy verboso (repite keys: "nombre, nombre, nombre").
Para alto rendimiento, usa formatos binarios.

### Protocol Buffers
Usado por Google en gRPC.
*   **Schema:** Define la estructura de antemano (`message User { string name = 1; }`).
*   **Binario:** Envía `0x0A 0x05 0x4A 0x75 0x61 0x6E` en lugar de `{"name":"Juan"}`.
*   **Resultado:** 5x más rápido y 50% menos ancho de banda.

---

## 103 Early Hints (Acelerando la Web)

El servidor tarda 200ms en pensar (`db.query`).
¿Por qué no le dices al navegador "Oye, vas a necesitar `style.css`" mientras piensas?

```javascript
app.get('/', (req, res) => {
    // 1. Enviar Hint Inmediato (res.writeEarlyHints en Node 18+)
    res.writeEarlyHints({
        'Link': '</style.css>; rel=preload; as=style'
    });
    
    // 2. Hacer la query lenta
    const data = await db.heavyQuery();
    
    // 3. Enviar respuesta final
    res.send(render(data));
});
```
Cuando el navegador recibe el HTML final, ¡ya descargó el CSS!

---

## Patrones de Tiempo Real (Comparativa)

Si necesitas un chat, ¿qué usas?

### Short Polling (El Novato)
*   **Cliente:** "¿Hay mensajes?" (cada 1s).
*   **Servidor:** "No".
*   **Problema:** Satura el servidor de peticiones vacías.

### Long Polling (El Astuto)
*   **Cliente:** "¿Hay mensajes?".
*   **Servidor:** (Se queda callado 30s...). "¡Ahora sí!".
*   **Ventaja:** Funciona en todos los navegadores viejos.

### Server-Sent Events (SSE)
*   **Cliente:** Abre conexión.
*   **Servidor:** Envía datos unidireccionales infinitamente.
*   **Uso:** Dashboards, Cotizaciones de Bolsa.

### WebSockets (El Rey)
*   Bidireccional real (TCP socket).
*   **Uso:** Juegos Multiplayer, Chat colaborativo.

---

---

## Serverless Context (AWS Lambda)

En Vercel/AWS, no hay un servidor corriendo 24/7.
El objeto `req` y `res` son diferentes.

### Event Object
```json
{
  "resource": "/",
  "path": "/api/users",
  "httpMethod": "POST",
  "headers": { "Accept": "*/*" },
  "body": "{\"name\": \"Juan\"}"
}
```
Aquí no existe `req.on('data')`. Todo el body ya llegó pre-cargado.

### Context Object
Información de la ejecución (cuánto tiempo te queda antes del timeout).
```javascript
exports.handler = async (event, context) => {
    console.log(`Quedan ${context.getRemainingTimeInMillis()}ms`);
    return { statusCode: 200, body: "OK" };
};
```

---

## Testing de Request/Response (`supertest`)

No pruebes APIs abriendo el navegador. Automatízalo.

```javascript
const request = require('supertest');
const app = require('./app');

describe('GET /users', () => {
    it('responde 200 JSON', async () => {
        const response = await request(app)
            .get('/users')
            .set('Accept', 'application/json');
            
        expect(response.status).toEqual(200);
        expect(response.body).toHaveProperty('users');
    });
});
```
Aquí `supertest` crea objetos `req` y `res` falsos sin abrir un puerto real.

---

## Debugging Avanzado (Correlation IDs)

Si tienes 50 microservicios, ¿cómo sigues una petición?
Usa el header `X-Request-ID` (o `X-Correlation-ID`).

1.  **Gateway:** Genera `uuid-123` y lo pone en el header.
2.  **Servicio A:** Lee header, loguea `[uuid-123] Procesando`. Llama a Servicio B enviando el mismo header.
3.  **Servicio B:** Lee header, loguea `[uuid-123] Guardando en DB`.

Si falla B, buscas `uuid-123` en los logs y ves la historia completa.

---

---

## Anatomía Profunda de Métodos HTTP

No uses POST para todo.

### Idempotencia
Una operación es **Idempotente** si ejecutarla 100 veces tiene el mismo efecto que ejecutarla 1 vez.
*   **PUT (Idempotente):** "Pon X en ID 1". Si lo envías 10 veces, el valor sigue siendo X.
*   **POST (No Idempotente):** "Crea un recurso". Si lo envías 10 veces, creas 10 recursos.
*   **PATCH (No Idempotente teóricamente):** "Incrementa edad en 1". Si lo envías 10 veces, aumenta 10 años. (Aunque a menudo se usa como Idempotente para updates parciales fijos).

### Safe Methods
Métodos que NO modifican el servidor (Solo lectura).
*   **GET, HEAD, OPTIONS.**
*   El navegador puede pre-cargarlos (prefetch) sin miedo a borrar tu base de datos.

---

## Códigos de Estado Exóticos (Pero Útiles)

Más allá del 200 y 404.

*   **409 Conflict:** "No puedo crear el usuario porque el email ya existe".
*   **422 Unprocessable Entity:** "El JSON es válido, pero la lógica no" (Ej. edad: -5).
*   **429 Too Many Requests:** "Calmado con el F5". (Rate Limiting).
*   **502 Bad Gateway:** "Node.js se cayó, Nginx está vivo pero no puede conectar".
*   **504 Gateway Timeout:** "Node.js tardó demasiado en responder a Nginx".

---

## Lógica Avanzada de Middlewares

El `next()` no es mágico. Es una Pila (Stack).

### Romper la Cadena
Si no llamas a `next()`, la petición se cuelga.
Si envías respuesta, NO llames a `next()` (Error: Headers already sent).

### Error Bubbling
Si pasas algo a `next(err)`, Express salta TODOS los middlewares normales y busca el primero con 4 argumentos: `(err, req, res, next)`.
```javascript
app.use((req, res, next) => {
    // Simulamos error asíncrono
    setTimeout(() => {
        next(new Error("Boom")); // Salta directo al Error Handler
    }, 100);
});
```

---

## Query Params: El Infierno de los Arrays

`?id=1&id=2`
Express lo parsea como `id: ['1', '2']`.
Si tu código espera un string `req.query.id.toUpperCase()`, **explota** cuando recibe un array.

**Solución:** Normalización defensiva.
```javascript
const ids = [].concat(req.query.id || []); // Siempre es array
// O usar Zod con preprocess
```

---

<div align="center">

[⬅️ Anterior: 4.3 Tratamiento de Formularios](4.3.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 4.5 Creación de Clases](4.5.md) ➡️

</div>
