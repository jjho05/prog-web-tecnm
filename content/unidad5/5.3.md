# 5.3 Patrones de Diseño en la Nube (Arquitectura Robusta)

Desarrollar para la nube es diferente a desarrollar para un servidor VPS.
Aquí los servidores mueren, las redes fallan y los discos son efímeros.
Necesitas patrones de diseño para sobrevivir.

---

## The 12-Factor App (La Biblia Cloud Native)

Heroku publicó esto en 2011. Sigue siendo la ley estándar para apps modernas.

### Principios Clave
1.  **Codebase:** Un repositorio por servicio.
2.  **Config:** La configuración (credenciales) va en variables de entorno, no en el código.
3.  **Backing Services:** Bases de datos y colas son recursos adjuntos (URLs), no parte de tu servidor.
4.  **Stateless:** No guardes sesiones en memoria. Usa Redis.
5.  **Dev/Prod Parity:** Mantén tu entorno local lo más parecido a producción (Usa Docker).
6.  **Logs:** Los logs son flujos de eventos (`console.log`), no archivos en disco.

---

---

## Patrones de Microservicios (Descomposición)

### Strangler Fig (Migración)
Rodea el Monolito con nuevos Microservicios.
1.  Todo el tráfico entrante pasa por un Proxy.
2.  Rediriges `/users` al nuevo microservicio.
3.  El resto sigue yendo al viejo monolito.
4.  Repites hasta que el monolito desaparece.

### Sidecar (El Ayudante)
Pon un contenedor auxiliar junto a tu app principal.
*   **Tu App:** Hace lo suyo (Backend).
*   **Sidecar:** Maneja SSL, Logs y Métricas automáticamente. (Ej. Istio Envoy).

### Backend for Frontend (BFF)
Crea APIs específicas para cada cliente.
*   `API-Mobile`: JSON ligero, sin imágenes grandes.
*   `API-Web`: JSON completo.

---

---

## Patrones de Resiliencia (Defensa Personal)

En la nube, fallar es la norma.

### Circuit Breaker (Cortocircuito)
Si un servicio falla, deja de llamarlo para que se recupere.
*   **Cerrado:** Todo funciona.
*   **Abierto:** Falla mucho. Bloquea el paso inmediatamente para no perder tiempo.
*   **Semi-Abierto:** Deja pasar una petición de prueba para ver si ya revivió.

### Retry (Reintento Inteligente)
Si falla, intenta de nuevo... pero espera un poco más cada vez (Exponential Backoff).
*   Intento 1 -> Falla.
*   Espera 1s -> Falla.
*   Espera 2s -> Falla.
*   Espera 4s -> Éxito.

### Fallback (Plan B)
Si la recomendación de IA falla, muestra "Los más vistos". Mejor una respuesta genérica que un error 500.

---

---

## Patrones de Datos (La parte difícil)

En un monolito tienes `JOIN`s. En microservicios no.

### CQRS (Command Query Responsibility Segregation)
Separa el modelo de LEER del modelo de ESCRIBIR.
*   **Write Model:** Optimizado para integridad (3FN). "Usuario compró".
*   **Read Model:** Optimizado para velocidad (Desnormalizado JSON). "Resumen de compras para dashboard".
*   **Sincronización:** Eventual (vía Kafka).

### Event Sourcing (La Fuente de la Verdad)
No guardes el estado actual (`Saldo: $100`).
Guarda los eventos que llevaron a él (`+50`, `-20`, `+70`).
*   **Ventaja:** Auditoría perfecta. Puedes "rebobinar" la base de datos a cualquier punto del tiempo.
*   **Desventaja:** Complejidad extrema.

### Saga Pattern (Transacciones Distribuidas)
No existe `BEGIN TRANSACTION... COMMIT` entre dos microservicios.
*   **Saga:** Una secuencia de transacciones locales.
    1.  Servicio Pedido: Crea Pedido (Pendiente). -> Evento "PedidoCreado".
    2.  Servicio Pago: Cobra Tarjeta. -> Evento "PagoExitoso".
    3.  Servicio Pedido: Cambia estado a "Pagado".
*   **Compensación:** Si el paso 2 falla (Tarjeta rechazada), debes ejecutar una "Undo Transaction" (Cancelar Pedido).

---

---

## Patrones de Observabilidad (Ojos y Oídos)

Si un usuario reporta un error, ¿sabes en cuál de los 100 servicios ocurrió?

### Distributed Tracing (Rastreo Distribuido)
Asigna un `Trace-ID` único (UUID) a cada petición en el momento que entra al sistema.
*   Pasa ese ID en los Headers HTTP (`x-request-id`) a todos los servicios downstream.
*   Herramientas: Jaeger, Zipkin, AWS X-Ray.
*   **Resultado:** Una gráfica de cascada que muestra exactamente dónde se tardó la petición.

### Log Aggregation (Centralización)
No te conectes por SSH a 50 servidores para leer logs (`tail -f`).
*   **Sidecar Log Shipper:** Un proceso (Fluentd) lee los logs del contenedor y los envía a Elastic.
*   **Kibana/Grafana:** Buscas errores en un solo dashboard.

### Health Check API
Cada servicio debe exponer `/health`.
*   **Liveness Probe:** "¿Estoy vivo?". Si falla, Kubernetes reinicia el contenedor.
*   **Readiness Probe:** "¿Estoy listo para recibir tráfico?". (Ej. Ya me conecté a la DB). Si falla, el Load Balancer deja de enviarle tráfico pero no lo mata.

---

---

## Patrones de Despliegue (Lanzar sin miedo)

### Blue/Green Deployment
Tienes dos entornos idénticos: Azul (Producción) y Verde (Nueva Versión).
1.  Despliegas en Verde. Nadie lo ve.
2.  Corres tests en Verde.
3.  Cambias el Load Balancer para apuntar a Verde.
4.  Si algo falla, reviertes el Load Balancer a Azul en 1 segundo.

### Canary Release (El Canario en la Mina)
Liberas la versión nueva solo al 5% de tus usuarios (o solo a los empleados).
*   Si no hay errores en 1 hora, subes al 50%.
*   Si sigue bien, subes al 100%.
*   Si hay errores, matas la versión nueva automáticamente.

### Rolling Update
Actualizas los servidores uno por uno.
*   De 10 servidores, bajas 1, lo actualizas, lo subes.
*   Repites 10 veces.
*   **Desventaja:** Durante el proceso, tienes versiones mezcladas (v1 y v2) corriendo simultáneamente.

### Feature Flags (Toggles)
Desacopla el "Deploy" del "Release".
*   Despliegas el código el lunes.
*   El código está oculto tras un `if (user.hasFlag('new-checkout'))`.
*   El viernes activas el Flag.

---

## Anti-Patrones (Lo que NO debes hacer)

### Distributed Monolith (El peor de todos)
Dividiste tu código en microservicios, pero:
*   Si el servicio A cae, caen todos.
*   Tienes que desplegarlos todos al mismo tiempo.
*   Comparten la misma base de datos.
*   **Resultado:** Tienes la complejidad de Microservicios sin ninguno de sus beneficios.

### Shared Database (Base de Datos Compartida)
5 microservicios leyendo las mismas tablas de MySQL.
*   Si el equipo A cambia el nombre de una columna, rompe a los equipos B, C, D y E.
*   **Solución:** Database per Service.

### Nanoservices
Servicios ridículamente pequeños.
*   "Microservicio de Sumar dos números".
*   El overhead de red (latencia) es mayor que el tiempo de cómputo.

---

---

## Patrones de Comunicación (Cómo hablar)

### Síncrono (Request/Response)
*   **Protocolos:** HTTP/REST, gRPC, GraphQL.
*   **Flujo:** Cliente pide -> Servidor procesa -> Servidor responde.
*   **Pros:** Simple, fácil de debuggear.
*   **Contras:** Acoblamiento temporal. Si el servidor está lento, el cliente se bloquea. Si el servidor está caído, la petición falla.

### Asíncrono (Event-Driven)
*   **Protocolos:** AMQP (RabbitMQ), Kafka, SQS/SNS.
*   **Flujo:** Cliente envía mensaje ("Pedido Creado") a una Cola -> Servidor lo procesa cuando puede.
*   **Pros:** Desacoplamiento total. Si el servidor está caído, el mensaje se guarda en la cola y se procesa cuando reviva. System resilience.
*   **Contras:** Complejidad. No sabes cuándo terminó la tarea. Necesitas mecanismos de feedback (Webhooks).

### Service Mesh (La Malla)
*   Delega la comunicación a la infraestructura.
*   En lugar de que tu código haga reintentos, el **Proxy (Envoy)** lo hace por ti.
*   Maneja mTLS (Encriptación mutua) automáticamente entre todos los servicios.

---

---

## Ejemplo de Código: Circuit Breaker en Node.js

No implementes esto desde cero. Usa una librería como `opossum`.

```javascript
const CircuitBreaker = require('opossum');
const axios = require('axios');

// 1. La función que puede fallar (Llamada a API externa)
async function callBillingService() {
  const response = await axios.get('http://billing-service/api/charge');
  return response.data;
}

// 2. Configuración del Breaker
const options = {
  timeout: 3000, // Si tarda > 3s, falla.
  errorThresholdPercentage: 50, // Si el 50% fallan, abre el circuito.
  resetTimeout: 10000 // Espera 10s antes de probar de nuevo (Half-Open).
};

const breaker = new CircuitBreaker(callBillingService, options);

// 3. Definir Fallback (Qué hacer si falla)
breaker.fallback(() => {
  return { status: "pending", message: "Billing is down, try later" };
});

// 4. Usar el breaker
app.get('/buy', async (req, res) => {
  const result = await breaker.fire(); // Dispara la función protegida
  res.json(result);
});

// Eventos para monitoreo
breaker.on('open', () => console.log('OPEN: Billing Service está caído'));
breaker.on('close', () => console.log('CLOSE: Billing Service revivió'));
```

---

---

## Service Discovery (¿Dónde están mis amigos?)

En la nube, las IPs cambian cada minuto. No puedes hardcodear `http://192.168.1.50`.

### Client-Side Discovery (Estilo Netflix)
*   El cliente (Microservicio A) consulta a un registro central (Eureka) "¿Dónde está el servicio B?".
*   Eureka responde: "Está en 10.0.0.5 y 10.0.0.6".
*   El cliente elige uno y llama.
*   **Desventaja:** El cliente debe ser inteligente. Acoplamiento al lenguaje (Eureka es Java).

### Server-Side Discovery (Estilo Kubernetes)
*   El cliente llama a un DNS estable: `http://my-service`.
*   Un Load Balancer interno (Kube-Proxy) intercepta la llamada y la redirige a un pod vivo.
*   **Ventaja:** Transparente para el programador. Funciona en cualquier lenguaje.

---

## API Gateway Pattern (El Portero)

No expongas tus 50 microservicios al público.
Pon un **API Gateway** enfrente (Kong, AWS API Gateway).

### Funciones Clave
1.  **Autenticación:** El Gateway valida el JWT una vez. Los microservicios internos confían en el Gateway.
2.  **Rate Limiting:** "Solo 100 req/seg por usuario". Protege al backend.
3.  **Protocol Translation:** El cliente habla HTTP/JSON externo, el Gateway habla gRPC interno.
4.  **Caching:** Guarda respuestas comunes para no molestar a la DB.

### Anti-Pattern: Gateway con Lógica de Negocio
*   **No hagas:** `if (user.isPremium) calculateTax()`.
*   El Gateway solo debe enrutar y proteger. La lógica vive en los servicios.

---

---

## Implementando una Saga (Código Conceptual)

Imagina comprar un viaje: Vuelo + Hotel. Si Vuelo ok pero Hotel falla, debes cancelar Vuelo.

```javascript
class TravelSaga {
  constructor(flightService, hotelService) {
    this.flight = flightService;
    this.hotel = hotelService;
  }

  async bookTrip(tripData) {
    // Paso 1: Reservar Vuelo
    let flightId;
    try {
      flightId = await this.flight.book(tripData);
      console.log(`Vuelo reservado: ${flightId}`);
    } catch (e) {
      throw new Error("Falló Vuelo, abortando.");
    }

    // Paso 2: Reservar Hotel
    let hotelId;
    try {
        hotelId = await this.hotel.book(tripData);
        console.log(`Hotel reservado: ${hotelId}`);
    } catch (e) {
      console.log("Falló Hotel. Iniciando Compensación...");
      // COMPENSACIÓN: Cancelar el vuelo ya reservado
      await this.flight.cancel(flightId);
      console.log("Vuelo cancelado exitosamente.");
      throw new Error("Viaje cancelado por fallo en hotel");
    }

    return { flightId, hotelId, status: "CONFIRMED" };
  }
}

// Uso
const saga = new TravelSaga(flightAPI, hotelAPI);
saga.bookTrip({ dest: "Cancun" })
  .then(console.log)
  .catch(console.error);
```

Este es un **Saga Basado en Orquestación**: Una clase central controla todo.
Alternativa: **Coreografía** (Eventos). El servicio de Vuelos emite `FlightBooked` y el servicio de Hoteles escucha ese evento.

---

---

## La Gran Batalla: Monolito vs Microservicios vs Serverless

| Característica | Monolito (Modular) | Microservicios (K8s) | Serverless (Lambda) |
| :--- | :--- | :--- | :--- |
| **Unidad de Despliegue** | Un gran .jar/.exe | Cientos de contenedores | Cientos de funciones |
| **Escalabilidad** | Escalas todo o nada | Escalas solo lo que se usa | Escala infinita por request |
| **Base de Datos** | Una DB centralizada | DB por servicio (aisladas) | DB por dominio (DynamoDB) |
| **Complejidad Dev** | **Baja** (Fácil debug local) | **Alta** (Necesitas Minikube) | **Media** (LocalStack) |
| **Complejidad Ops** | **Baja** (1 servidor) | **Extrema** (Orquestación) | **Baja** (No Ops, pero difícil monitoreo) |
| **Costo** | Fijo (Predecible) | Alto (Overhead de Cluster) | Variable (Pagas por uso) |
| **Mejor para** | Startups, equipos < 10 | Empresas grandes, equipos autónomos | Event-driven, Spikes |

*   **Nota:** No empieces con Microservicios. Empieza con un Monolito Modular. Solo rompe el monolito cuando el dolor de coordinar al equipo sea mayor que el dolor de gestionar microservicios.

---

## Arquitectura Orientada a Eventos (EDA)

Deja de llamarte por teléfono (HTTP) y empieza a mandarte cartas (Eventos).

### Componentes
1.  **Event Producer:** "Algo pasó" (Usuario Creado). No le importa quién escucha.
2.  **Event Router (Broker):** La oficina de correos (Kafka, SNS, EventBridge). Recibe el mensaje y ve a quién le interesa.
3.  **Event Consumer:** Escucha el mensaje y reacciona (Envía Email de bienvenida).

### Fan-Out Pattern
Un solo evento dispara múltiples acciones paralelas.
*   **Evento:** `UserSignedUp`.
*   **Consumer A (Email):** Envía correo.
*   **Consumer B (Analytics):** Registra en Mixpanel.
*   **Consumer C (Fraud):** Revisa si la IP es sospechosa.

### Idempotencia (Clave en EDA)
Como las colas pueden entregar mensajes duplicados ("At-least-once delivery"), tu consumidor debe ser **Idempotente**.
*   Si recibes el evento "Cobrar $10" dos veces, solo debes cobrar una vez.
*   **Solución:** Guarda el `message_id` en una tabla `ProcessedEvents`. Si ya existe, ignora el duplicado.

---

---

## Patrones de Seguridad (Zero Trust)

En la red vieja, "Adentro del Firewall" = Seguro.
En la nube, "Nadie es seguro".

### Zero Trust Network
*   Cada servicio debe autenticar a quien le habla, aunque sea otro microservicio interno.
*   Usa **mTLS** (Certificados en ambos lados).
*   Usa **OIDC** (OpenID Connect) para pasar la identidad del usuario a través de la cadena de servicios.

### Token Exchange
El Frontend envía un ID Token (Google).
El Gateway lo cambia por un Access Token interno con los permisos (Scopes) específicos para los microservicios.

---

## Patrones Operacionales (DevOps)

### Externalized Configuration
No reconstruyas el Docker container para cambiar una URL de base de datos.
*   El código lee de `ENV VARS`.
*   Las `ENV VARS` vienen de un servidor central (AWS Parameter Store / Spring Cloud Config).
*   Cambias la config en caliente y reinicias los pods, no re-compilas.

### GitOps (ArgoCD)
El estado deseado de la infraestructura vive en Git.
*   Un agente en el cluster (ArgoCD) compara Git vs La Realidad.
*   Si alguien borra un servicio manualmente, ArgoCD lo recrea automáticamente para coincidir con Git.

---

---

## Patrones Serverless (Funciones Efímeras)

### Queue-Based Load Leveling (Aplanamiento de Carga)
Si 10,000 usuarios suben fotos a la vez, no quieres disparar 10,000 Lambdas (te costará una fortuna y saturará la DB).
*   **Patrón:** Usuario -> API Gateway -> **SQS (Cola)** -> Lambda (Worker).
*   La Lambda procesa la cola a su ritmo (ej. 50 a la vez).
*   La cola actúa como un "amortiguador" (Buffer).

### Fan-Out / Fan-In
*   **Fan-Out:** Un evento dispara 10 funciones en paralelo (Procesar 10 páginas de un PDF).
*   **Fan-In:** Una función final espera a que las 10 terminen y consolida el resultado. (Difícil de hacer a mano, fácil con Step Functions).

---

## Patrones de Caché (Velocidad)

"La mejor petición a la base de datos es la que no se hace".

### Cache-Aside (Lazy Loading) - El Estándar
Tu código es responsable de llenar la caché.

```javascript
async function getUser(id) {
  // 1. Buscar en Redis
  const cached = await redis.get(`user:${id}`);
  if (cached) return JSON.parse(cached);

  // 2. Si no está (Cache Miss), buscar en DB
  const user = await db.findUser(id);

  // 3. Guardar en Redis para la próxima (con TTL de 1 hora)
  await redis.set(`user:${id}`, JSON.stringify(user), 'EX', 3600);

  return user;
}
```

### Write-Through
*   Escribes a la Caché y la Caché escribe a la DB sincrónicamente.
*   **Ventaja:** Los datos siempre están frescos y consistentes.
*   **Desventaja:** Escritura lenta (doble commit).

---

## Patrones de Sharding (Escalado de Datos)

Cuando tu tabla de Usuarios pesa 10 Terabytes y Postgres ya no aguanta.

### Sharding Horizontal (Partitioning)
Dividir la tabla `Users` en 3 bases de datos físicas diferentes.
*   **Shard A:** Usuarios A-J.
*   **Shard B:** Usuarios K-R.
*   **Shard C:** Usuarios S-Z.

### Directory Based Sharding
*   Una tabla "Lookup" dice dónde vive cada usuario.
*   `User 1` -> `Shard 3`.
*   Te permite mover usuarios entre Shards dinámicamente.

---

---

## Patrones de Testing en la Nube (QA)

Unit Tests no son suficientes cuando tienes 50 servicios.

### Contract Testing (Pact)
El problema: El Servicio A espera `{"id": 1}` pero el Servicio B cambió a `{"user_id": 1}`. Se rompe todo.
*   **Contract Testing:** Define un "Contrato" JSON.
*   El Servicio B (Provider) corre tests para asegurar que CUMPLE el contrato.
*   El Servicio A (Consumer) corre tests asumiendo el contrato.
*   Si B rompe el contrato, el CI/CD falla *antes* del deploy.

### Synthetic Monitoring (Canaries)
No esperes a que un usuario se queje.
*   Crea un "Usuario Robot" que corre cada minuto:
    1.  Login.
    2.  Añadir al carrito.
    3.  Checkout.
*   Si el Robot falla, despierta al ingeniero de guardia (PagerDuty).

### Chaos Engineering (Práctica)
Usa herramientas como **Gremlin** o **LitmusChaos** en Kubernetes.
*   "Simular caída de la Base de Datos".
*   "Inyectar 500ms de latencia en la red".
*   Verifica si tus Circuit Breakers se activan correctamente.

---

---

## Recursos Recomendados (Libros)

Para dominar estos patrones, lee estos libros:

1.  **"Building Microservices"** por Sam Newman. (El clásico).
2.  **"Release It!"** por Michael Nygard. (Sobre Circuit Breakers y Bulkheads).
3.  **"Designing Data-Intensive Applications"** por Martin Kleppmann. (La Biblia de las Bases de Datos Distribuidas).
4.  **"Accelerate"** por Nicole Forsgren. (Sobre métricas DORA y cultura DevOps).

---

<div align="center">

[⬅️ Anterior: 5.2 Tipos de Servicios](5.2.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 5.4 Estándares](5.4.md) ➡️

</div>
