# 5.4 Est치ndares en Servicios (Idiomas de Internet)

Para que dos computadoras hablen, necesitan un protocolo com칰n.
En los 90s era XML, hoy es JSON, ma침ana ser치 Binary.

---

## SOAP (Simple Object Access Protocol) - El Abuelo Estricto

### Lo B치sico
Es un protocolo estricto basado en XML. Fue el rey en los 2000s.
*   **Estructura:** Sobre (Envelope), Cabecera (Header), Cuerpo (Body).
*   **Contrato:** Todo se define en un archivo **WSDL**. Si cambias un tipo de dato, se rompe el cliente.
*   **Uso actual:** Bancos, Gobierno, Sistemas Legacy. **No lo uses para proyectos nuevos.**

---

## REST (Representational State Transfer) - El Est치ndar Actual

Tesis doctoral de Roy Fielding (2000). No es un protocolo, es un **Estilo Arquitect칩nico**.

### Principios
1.  **Recursos:** Todo es una URL (`/users/123`).
2.  **Verbos HTTP:** `GET` (Leer), `POST` (Crear), `PUT` (Reemplazar), `PATCH` (Editar), `DELETE` (Borrar).
3.  **Stateless:** El servidor no guarda "sesi칩n" entre requests. Cada request lleva su Auth Token.
4.  **Representaci칩n:** Puedes pedir el mismo recurso en JSON o XML (`Accept: application/json`).

### Richardson Maturity Model (Niveles de REST)
*   **Nivel 0 (The Swamp of POX):** Usas HTTP como t칰nel. Todo es `POST /apiService`.
*   **Nivel 1 (Recursos):** Tienes URLs distintas `/users`, `/products`.
*   **Nivel 2 (Verbos HTTP):** Usas `GET` para leer y `DELETE` para borrar (No `POST /deleteUser`).
*   **Nivel 3 (HATEOAS):** La respuesta incluye links a qu칠 hacer despu칠s.

### Ejemplo HATEOAS
```json
{
  "id": 123,
  "balance": 50.00,
  "links": [
    { "rel": "deposit", "href": "/accounts/123/deposit" },
    { "rel": "withdraw", "href": "/accounts/123/withdraw" }
  ]
}
```

---

---

## GraphQL (Graph Query Language) - El Retador de Facebook

Dise침ado por Facebook en 2012 para su App m칩vil.

### El Problema de REST
*   **Overfetching:** Pides un usuario y te da 50 campos que no necesitas.
*   **Underfetching:** Pides un usuario y luego tienes que hacer otra petici칩n para sus amigos.

### La Soluci칩n GraphQL
Pides exactamente lo que quieres en un solo request.

**Query:**
```graphql
query {
  user(id: "1") {
    name
    friends { name }
  }
}
```

**Respuesta:**
```json
{
  "data": {
    "user": {
      "name": "Jes칰s",
      "friends": [{ "name": "Ana" }]
    }
  }
}
```

### Schema & Types
GraphQL es fuertemente tipado.
```graphql
type User {
  id: ID!
  name: String!
  age: Int
  friends: [User]
}
```

---

## gRPC (Remote Procedure Call) - La Bestia de Google

Dise침ado por Google (Stubby). Usa **HTTP/2** y **Protocol Buffers**.

### Binario vs Texto
*   REST/JSON env칤a texto: `{"name": "Jes칰s"}` (18 bytes).
*   gRPC/Protobuf env칤a binario: `0A 05 4A 65 73 FA 73` (7 bytes).
*   **Resultado:** gRPC es 7x a 10x m치s r치pido que REST.

### Protocol Buffers (.proto)
Defines el contrato en un archivo neutro.
```protobuf
syntax = "proto3";

service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}
```
Luego **generas c칩digo** autom치ticamente para Python, Java, Go y Node.js.

### Streaming
gRPC soporta streaming bidireccional nativo.
*   El cliente sube un archivo (Stream) mientras el servidor va respondiendo progreso (Stream).

---

---

## Webhooks (Don't call us, we'll call you)

Las APIs tradicionales (REST) son pasivas. Webhooks son activos.

*   **Sin Webhooks:** Tu servidor pregunta a Stripe cada minuto: "쯏a pag칩 el usuario?" (Polling). Ineficiente.
*   **Con Webhooks:** Stripe te llama a TI (`POST https://tu-api.com/stripe-webhook`) cuando el usuario paga.

---

## Documentaci칩n de APIs (OpenAPI / Swagger)

Una API sin documentaci칩n no sirve.
**OpenAPI Specification (OAS)** es un est치ndar YAML/JSON para describir tu API.

```yaml
openapi: 3.0.0
info:
  title: Users API
  version: 1.0.0
paths:
  /users:
    get:
      summary: Returns a list of users.
      responses:
        '200':
          description: A JSON array of user names
```

*   **Herramientas:** Swagger UI lee este YAML y genera una p치gina web interactiva donde puedes probar la API.

---

## Matriz de Decisi칩n: 쮺u치l uso?

| Criterio | REST | GraphQL | gRPC | SOAP |
| :--- | :--- | :--- | :--- | :--- |
| **Formato** | JSON | JSON | Protobuf (Binario) | XML |
| **Velocidad** | Media | Media | **Extrema** | Lenta |
| **Tipado** | No (Flexible) | **S칤 (Schema)** | **S칤 (Proto)** | S칤 (WSDL) |
| **Apalancamiento** | CRUD simple | Grafos complejos | Microservicios internos | Legacy / Bancos |
| **Consumible por** | Cualquiera | Apps M칩viles | Backend-to-Backend | Mainframes |
| **Navegador Web** | Nativo | Librer칤a extra | Requiere Proxy (gRPC-Web) | Dif칤cil |

---

---

## Implementaci칩n de Referencia: REST (Node.js + Express)

C칩mo se ve una API REST profesional hoy en d칤a.

```javascript
const express = require('express');
const app = express();
app.use(express.json());

const users = [];

// GET /users (Collection Resource)
app.get('/users', (req, res) => {
  // Filtrado y Paginaci칩n (Best Practice)
  const limit = req.query.limit || 10;
  res.status(200).json(users.slice(0, limit));
});

// POST /users (Create)
app.post('/users', (req, res) => {
  const newUser = { id: Date.now(), ...req.body };
  users.push(newUser);
  // 201 Created + Location Header
  res.status(201)
     .header('Location', `/users/${newUser.id}`)
     .json(newUser);
});

// GET /users/:id (Member Resource)
app.get('/users/:id', (req, res) => {
  const user = users.find(u => u.id == req.params.id);
  if (!user) return res.status(404).json({ error: "User not found" });
  
  // HATEOAS Links
  res.json({
    ...user,
    links: [
      { rel: "self", method: "GET", href: `/users/${user.id}` },
      { rel: "delete", method: "DELETE", href: `/users/${user.id}` }
    ]
  });
});

// HTTP 405 Method Not Allowed
app.all('/users', (req, res) => {
  res.status(405).send("Method Not Allowed");
});
```

---

## Implementaci칩n de Referencia: GraphQL (Apollo Server)

N칩tese c칩mo el **Resolver** sustituye al **Router**.

```javascript
const { ApolloServer, gql } = require('apollo-server');

// 1. Schema (La Forma)
const typeDefs = gql`
  type Book {
    title: String
    author: String
  }

  type Query {
    books: [Book]
    book(title: String): Book
  }
`;

// 2. Data
const books = [
  { title: 'The Awakening', author: 'Kate Chopin' },
  { title: 'City of Glass', author: 'Paul Auster' },
];

// 3. Resolvers (La L칩gica)
const resolvers = {
  Query: {
    books: () => books,
    book: (_, args) => books.find(b => b.title === args.title)
  },
};

// 4. Server
const server = new ApolloServer({ typeDefs, resolvers });

server.listen().then(({ url }) => {
  console.log(`游  Server ready at ${url}`);
});
```

---

---

## Implementaci칩n de Referencia: gRPC (Node.js)

Requiere una definici칩n `.proto` y un loader din치mico.

**helloworld.proto**
```protobuf
syntax = "proto3";
package helloworld;
service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}
message HelloRequest {
  string name = 1;
}
message HelloReply {
  string message = 1;
}
```

**server.js**
```javascript
const grpc = require('@grpc/grpc-js');
const protoLoader = require('@grpc/proto-loader');

const packageDefinition = protoLoader.loadSync('helloworld.proto');
const hello_proto = grpc.loadPackageDefinition(packageDefinition).helloworld;

function sayHello(call, callback) {
  callback(null, { message: 'Hello ' + call.request.name });
}

const server = new grpc.Server();
server.addService(hello_proto.Greeter.service, { sayHello: sayHello });
server.bindAsync('0.0.0.0:50051', grpc.ServerCredentials.createInsecure(), () => {
  server.start();
});
```

---

## Estrategias de Versionado (C칩mo no romper clientes)

Tu API va a cambiar. 쮺칩mo lo manejas?

### URI Versioning (Twitter, Google)
*   `GET /api/v1/tweets`
*   `GET /api/v2/tweets`
*   **Pros:** Expl칤cito, f치cil de cachear.
*   **Contras:** Ensucia la URL.

### Header Versioning (GitHub, Stripe)
*   `GET /tweets`
*   Header: `Accept: application/vnd.myapi.v2+json`
*   **Pros:** URL limpia.
*   **Contras:** Dif칤cil de probar en el navegador.

---

## Seguridad en APIs (Lo M칤nimo Indispensable)

### Rate Limiting (Token Bucket)
Evita que un script te tire el servidor.
*   Uso: `express-rate-limit`.
*   Regla: "Max 100 requests por 15 minutos por IP".
*   Retorno: `HTTP 429 Too Many Requests`.

### CORS (Cross-Origin Resource Sharing)
Por defecto, el navegador BLOQUEA peticiones de `midominio.com` a `api.otro.com`.
*   El servidor debe enviar header: `Access-Control-Allow-Origin: *`.

### JWT (JSON Web Tokens)
El est치ndar de Auth Stateless.
*   **Header:** Algoritmo (`HS256`).
*   **Payload:** Datos (`user_id: 123`, `exp: 1710000000`).
*   **Signature:** Firma criptogr치fica para evitar tampering.

---

---

## Manejo de Errores (RFC 7807)

No inventes formatos de error (`{"err": "bad", "code": 99}`). Usa el est치ndar **Problem Details for HTTP APIs**.

```json
HTTP/1.1 403 Forbidden
Content-Type: application/problem+json

{
  "type": "https://example.com/probs/out-of-credit",
  "title": "You do not have enough credit.",
  "detail": "Your current balance is 30, but that costs 50.",
  "instance": "/account/12345/msgs/abc",
  "balance": 30,
  "accounts": ["/account/12345", "/account/67890"]
}
```

*   **type:** URI 칰nica del tipo de error.
*   **title:** T칤tulo humano corto.
*   **detail:** Explicaci칩n espec칤fica.
*   **instance:** D칩nde ocurri칩.

---

## AsyncAPI (Documentando Eventos)

OpenAPI es para REST. **AsyncAPI** es para Kafka/RabbitMQ.

```yaml
asyncapi: 2.0.0
info:
  title: Streetlights API
  version: 1.0.0
channels:
  light/measured:
    publish:
      message:
        payload:
          type: object
          properties:
            id:
              type: integer
            lumens:
              type: integer
```

*   Define **Canales** (Topics) en lugar de Paths (URLs).
*   Define **Publish/Subscribe** en lugar de GET/POST.

---

## Cheat Sheet de HTTP Status Codes (Los 칔tiles)

Hay 63 c칩digos. Solo necesitas estos 10:

### 2xx: 칄xito
*   **200 OK:** 칄xito.
*   **201 Created:** Creaste algo nuevo (POST).

### 4xx: Error del Cliente
*   **400 Bad Request:** Enviaste mal los datos.
*   **401 Unauthorized:** No tienes token (Login).
*   **403 Forbidden:** Tienes token, pero no permiso (Admin).
*   **404 Not Found:** No existe.

### 5xx: Error del Servidor
*   **500 Internal Server Error:** Bug en el backend.
*   **503 Unavailable:** Servidor ca칤do o saturado.

---

---

## Testing de Servicios (QA Automatizado)

No pruebes manual con Postman siempre. Automatiza.

### Supertest + Jest (Integration Tests)
Prueba tu API completa sin levantar el servidor en el puerto 3000.

```javascript
const request = require('supertest');
const app = require('./app');

describe('GET /users', () => {
  it('responds with json', async () => {
    const res = await request(app)
      .get('/users')
      .set('Accept', 'application/json')
      .expect('Content-Type', /json/)
      .expect(200);
      
    expect(res.body).toHaveLength(10);
  });
});
```

### k6 (Load Testing)
쯊u API aguanta 1000 usuarios?
Script en Javascript que simula carga masiva.

```javascript
import http from 'k6/http';
import { sleep } from 'k6';

export default function () {
  http.get('https://mi-api.com/users');
  sleep(1);
}
```
*   Ejecuta: `k6 run --vus 100 --duration 30s script.js`.
*   Resultado: "99% de los requests tardaron < 200ms".

---

---

## Real-Time Web (M치s all치 de REST)

REST es "Petici칩n-Respuesta" (Cliente habla, Servidor responde). Pero, 쯫 si el servidor quiere hablar?

### WebSockets (Bidireccional)
*   Un t칰nel TCP persistente.
*   **Uso:** Chats, Juegos Multiplayer, Cotizaciones de Bolsa.
*   **Pros:** Latencia ultra baja.
*   **Contras:** Dif칤cil de escalar (Stateful connection). Si tienes 1 mill칩n de usuarios, necesitas 1 mill칩n de conexiones abiertas.

### Server-Sent Events (SSE)
*   **Unidireccional:** El servidor env칤a datos al cliente (como una radio), pero el cliente no responde por ah칤.
*   **Uso:** Notificaciones de Facebook, Feed de Twitter.
*   **Ventaja:** Usa HTTP est치ndar, m치s f치cil que WebSockets.

---

## El Futuro: HTTP/3 (QUIC)

HTTP/2 arregl칩 muchos problemas, pero segu칤a usando TCP.
*   **Problema de TCP:** Si se pierde un paquete, TODO se detiene (Head-of-Line Blocking).
*   **Soluci칩n HTTP/3:** Usa **UDP** (el protocolo "inseguro" de los videojuegos).
*   Le a침ade una capa de confiabilidad y cifrado (TLS 1.3) integrada.
*   **Resultado:** Carga instant치nea en conexiones m칩viles inestables (4G/5G).

---

<div align="center">

[拘勇 Anterior: 5.3 Patrones de Dise침o](5.3.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 5.5 Plataformas](5.5.md) 俱뫮잺

</div>
