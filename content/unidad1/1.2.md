# 1.2 Arquitectura de las aplicaciones web

## Introducci칩n a la Arquitectura de Software

La arquitectura de software no se trata solo de escribir c칩digo; se trata de **tomar decisiones estructurales** que definir치n la vida 칰til, escalabilidad y mantenibilidad de un sistema. Como dir칤a Martin Fowler: *"La arquitectura es sobre las cosas importantes. Sea lo que sea eso"*.

En el desarrollo web, la arquitectura dicta c칩mo fluyen los datos desde la base de datos m치s profunda hasta la pantalla del usuario, pasando por m칰ltiples capas de l칩gica, seguridad y red. Una mala arquitectura convertir치 cualquier proyecto en una "Gran Bola de Lodo" (Big Ball of Mud) imposible de mantener.

---

## El Modelo Fundamental: Cliente-Servidor Estricto

Aunque hoy hablemos de la nube y el "Edge", todo se reduce al contrato fundamental **Cliente-Servidor**.

### La Anatom칤a de una Petici칩n
쯈u칠 pasa cuando escribes `google.com` y das Enter?

1.  **Cliente (Tu Navegador):** Inicia la charla. En la web, el cliente siempre empieza.
2.  **Red (El Camino):** DNS traduce el nombre a n칰meros (IP), TCP asegura que los datos lleguen bien.
3.  **Servidor (El Anfitri칩n):** Un programa (como Apache o Nginx) escucha, procesa y responde.

### Diagrama de Secuencia Detallado (Mermaid)

```mermaid
sequenceDiagram
    participant C as Cliente (Browser)
    participant DNS
    participant LB as Load Balancer
    participant S as Servidor Web (Nginx)
    participant App as App Server (Node/Python)
    participant DB as Base de Datos

    C->>DNS: 쯈ui칠n es "mi-sitio.com"?
    DNS-->>C: Es 203.0.113.5
    C->>LB: GET /api/usuarios (HTTPS)
    LB->>S: Reenv칤a tr치fico (Round Robin)
    S->>App: Invoca endpoint l칩gico
    App->>DB: SELECT * FROM users
    DB-->>App: Retorna JSON
    App-->>S: Renderiza o serializa
    S-->>LB: Respuesta HTTP 200 OK
    LB-->>C: Muestra datos al usuario
```
> **游눹 C칩digo en Acci칩n:**
> 쮺칩mo funciona realmente un servidor? Hemos creado una simulaci칩n en Node.js para que veas las respuestas HTTP.
>
> 游늯 **Ver c칩digo:** [03_arquitectura_cliente_servidor.js](codigos/03_arquitectura_cliente_servidor.js)
> (Copia, pega y ejecuta con `node 03_arquitectura_cliente_servidor.js`)

---

## Evoluci칩n de las Capas (Tiered Architecture)

La historia de la arquitectura web es la historia de la **separaci칩n de responsabilidades** (Separation of Concerns).

### Arquitectura Monol칤tica ("Todo en Uno")
En el pasado, met칤amos todo en una sola caja.
*   **Problema:** Si quer칤as cambiar una sola regla (ej. subir el IVA), ten칤as que actualizar el software en las 500 computadoras de la empresa. Dif칤cil de mantener.

### La Era Dorada: 3-Tier Architecture
Es el est치ndar de facto para la mayor칤a de las aplicaciones empresariales tradicionales.

1.  **Capa de Presentaci칩n (Presentation Tier):**
    *   *"El Frontend"*. HTML, CSS, JS, Frameworks (React, Vue).
    *   No toma decisiones, solo muestra y captura inputs.
2.  **Capa de L칩gica de Negocio (Logic/Application Tier):**
    *   *"El Backend"*. Node.js, Python, Java, C#.
    *   Aqu칤 viven las reglas: "Si el usuario no tiene saldo, rechazar pago", "Calcular env칤o basado en peso".
3.  **Capa de Datos (Data Tier):**
    *   *"La Persistencia"*. MySQL, PostgreSQL, MongoDB, Redis.
    *   Su 칰nico trabajo es guardar y recuperar datos de forma 칤ntegra.

**Ventaja Clave:** Independencia. Puedes cambiar la base de datos de Oracle a MySQL sin tocar una sola l칤nea de c칩digo del Frontend.

### Arquitectura N-Tier (Multicapa)
Para sistemas masivos, 3 capas no bastan.
*   **Capa de Caching:** Redis/Memcached antes de la BD para velocidad.
*   **Capa de Integraci칩n:** Enterprise Service Bus (ESB) para hablar con sistemas legacy (bancos antiguos).
*   **Capa de Almacenamiento de Objetos:** AWS S3 para fotos/videos, separ치ndolos de la BD transaccional.

---

## Patrones de Dise침o Arquitect칩nico

No confundir con la infraestructura. Esto es c칩mo organizamos el **c칩digo**.

### MVC (Model-View-Controller)
El patr칩n m치s famoso, nacido en Smalltalk en los 70s y adoptado por la web (Ruby on Rails, Django, Laravel, Spring MVC).

*   **Model (El Qu칠):** La verdad de los datos.
    *   *Ejemplo:* Una clase `Product` que sabe guardar su precio en la DB.
*   **View (El D칩nde):** La representaci칩n visual.
    *   *Ejemplo:* Un archivo `product_detail.html` que espera recibir variables `{{ price }}`.
*   **Controller (El C칩mo):** El director de orquesta.
    *   *Flujo:*
        1. Recibe petici칩n `GET /products/5`.
        2. Llama al Modelo: `Product.find(5)`.
        3. Si existe, llama a la Vista: `render('product_detail', data)`.
        4. Si no, devuelve error 404.

#### Ejemplo de C칩digo: MVC en Python (Pseudoc칩digo Flask)

```python
# --- MODELO ---
class Usuario(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    nombre = db.Column(db.String(80))
    email = db.Column(db.String(120))

    def es_admin(self):
        return self.email.endswith('@empresa.com')

# --- CONTROLADOR ---
@app.route('/perfil/<int:id>')
def ver_perfil(id):
    # 1. El controlador pide datos al Modelo
    usuario = Usuario.query.get(id)
    
    if not usuario:
        return abort(404)
        
    # 2. L칩gica de negocio
    permisos = "Total" if usuario.es_admin() else "Limitado"
    
    # 3. El controlador pasa datos a la Vista
    return render_template('perfil_usuario.html', u=usuario, p=permisos)

# --- VISTA (HTML + Jinja2) ---
<!-- perfil_usuario.html -->
<h1>Perfil de {{ u.nombre }}</h1>
<p>Email: {{ u.email }}</p>
<span class="badge">{{ p }}</span>
```

### MVVM (Model-View-ViewModel)
Dominante en el Frontend moderno (Angular, React -aunque React es m치s V-, Vue).
*   **Problema del MVC cl치sico:** El controlador engorda mucho ("Massive View Controller").
*   **Soluci칩n (Data Binding):** La Vista se actualiza autom치ticamente cuando cambia el Modelo, gracias al "ViewModel".
*   **Two-Way Data Binding:** Si escribes en un input, se actualiza la variable JS. Si cambias la variable JS, se actualiza el input. Sin c칩digo manual de eventos.

---

## De Monolitos a Microservicios

El debate arquitect칩nico m치s importante de la 칰ltima d칠cada.

### El Monolito (The Monolith)
Una sola App gigante que hace todo (Login, Ventas, Inventario).
*   **Pros:** F치cil de empezar. Todo el c칩digo est치 junto.
*   **Contras:**
    *   *Efecto Domin칩:* Un error en el Chat puede tumbar el sistema de Pagos.
    *   *Pesado:* Para escalar, tienes que duplicar TODO el servidor, no solo la parte lenta.

### Microservicios (Divide y Vencer치s)
Romper la App gigante en peque침as Apps independientes que hablan entre s칤.
*   **Filosof칤a:** "Haz una sola cosa, pero hazla perfecta".
*   **Pros:**
    *   *Escalado Fino:* 쯄ucha gente en el Chat? Levanta 50 servidores de Chat y deja 1 de Pagos.
    *   *Libertad:* Un equipo puede usar Python y otro Node.js.
*   **Contras:**
    *   *Complejidad:* Ahora tienes que cuidar 50 servidores en vez de 1.
    *   *Latencia:* Las partes tienen que hablarse por la red, que es m치s lenta que la memoria.

### Tabla Comparativa: Monolito vs Microservicios

| Caracter칤stica | Monolito | Microservicios |
| :--- | :--- | :--- |
| **Despliegue** | Todo o nada. Riesgoso. | Independiente. Bajo riesgo. |
| **Base de Datos** | Compartida y centralizada. | Descentralizada (Database per Service). |
| **Equipo** | Gran equipo trabajando sobre el mismo c칩digo. Bloqueos frecuentes. | Equipos peque침os (Squads) due침os de su servicio. |
| **Debug** | Stack trace simple. | "Distributed Tracing" (Sherlock Holmes digital). |
| **Costo Inicial** | Bajo. Ideal para Startups. | Alto. Requiere infraestructura robusta. |

## Arquitectura Serverless y Edge Computing

El t칠rmino "Serverless" es enga침oso. Hay servidores, pero **t칰 no los administras**.

### FaaS (Function as a Service)
En lugar de tener un servidor Node.js corriendo 24/7 esperando peticiones (y cobr치ndote dinero aunque nadie entre), subes funciones individuales.
*   **Funcionamiento:**
    1.  Subes una funci칩n `procesar_pago()` a AWS Lambda.
    2.  Nadie entra a tu web -> Costo $0.
    3.  Alguien compra -> AWS levanta un contenedor en 100ms, ejecuta tu funci칩n, te cobra por los 200ms de ejecuci칩n, y destruye el contenedor.

*   **El Problema del "Cold Start":** La primera vez que se ejecuta, tarda un poco m치s en "despertar" el contenedor.
*   **Casos de Uso:** Procesamiento de im치genes (subes foto -> se crea thumbnail), Webhooks, APIs con tr치fico impredecible.

### Edge Computing (Computaci칩n en el Borde)
Llevar el c칩digo lo m치s cerca posible del usuario f칤sico.
*   **Cloud Tradicional:** Tu servidor est치 en Virginia, EEUU. Un usuario en Chile tiene 150ms de latencia.
*   **Edge:** Tu c칩digo corre en una red de 300 datacenters alrededor del mundo (Cloudflare Workers, Vercel Edge).
*   **Magia:** Cuando el usuario chileno entra, su petici칩n es atendida por un servidor en Santiago de Chile. Latencia: 5ms.

---

## Cloud Native y los 12 Factores

Para que una aplicaci칩n sobreviva en la nube moderna, debe seguir la metodolog칤a **The Twelve-Factor App** (creada por Heroku).

1.  **Codebase:** Un solo repositorio controlado por versiones (Git), muchos despliegues.
2.  **Dependencias:** Declararlas expl칤citamente (package.json, requirements.txt). Nada de "instalar cosas a mano".
3.  **Configuraci칩n:** Guardar la configuraci칩n (claves, DB URL) en el **Entorno** (Variables de ENV), no en el c칩digo.
4.  **Backing Services:** Tratar bases de datos/ficheros como recursos conectables.
5.  **Build, Release, Run:** Separar estrictamente la etapa de construcci칩n de la de ejecuci칩n.
6.  **Procesos:** Ejecutar la app como uno o m치s procesos **sin estado** (stateless).
7.  **Port Binding:** La app debe exportar servicios v칤a puertos (ej. localhost:5000).
8.  **Concurrencia:** Escalar mediante el modelo de procesos (m치s copias del proceso, no procesos m치s grandes).
9.  **Desechabilidad:** Hacer el arranque r치pido y el cierre elegante (Graceful Shutdown).
10. **Paridad Dev/Prod:** Mantener desarrollo, staging y producci칩n lo m치s parecidos posible.
11. **Logs:** Tratar los logs como flujos de eventos (stream a consola), no archivos.
12. **Admin Processes:** Correr tareas de administraci칩n/mantenimiento como procesos "one-off".

---

## Infraestructura Cr칤tica de la Web

M치s all치 del c칩digo, la arquitectura web depende de piezas de hardware/software intermedias.

### Balanceadores de Carga (Load Balancers)
El polic칤a de tr치fico. Si tienes 3 servidores, el Balanceador distribuye las visitas para que ninguno se sature.
*   **Algoritmos:**
    *   *Round Robin:* Uno para ti, uno para 칠l, uno para aquel.
    *   *Least Connections:* Manda al que tenga menos trabajo ahora.
    *   *IP Hash:* Manda siempre al mismo usuario al mismo servidor (para mantener sesi칩n).

### Proxy Inverso (Reverse Proxy)
Un servidor que se pone "delante" de tu servidor de aplicaciones. El rey indiscutible es **Nginx**.
*   **Funciones:**
    *   **Seguridad:** Oculta la IP real de tu servidor de aplicaciones.
    *   **Terminaci칩n SSL:** El proxy descifra el HTTPS y le pasa HTTP plano a tu app (ahorra CPU a tu app).
    *   **Compresi칩n:** Gzip/Brotli autom치tico.

### Caching: El arte de no trabajar
La petici칩n m치s r치pida es la que no se hace.
*   **Regla:** Si ya calculaste algo (como el "Top 10 Ventas"), gu치rdalo en memoria (Redis). La pr칩xima vez, devu칠lvelo al instante sin preguntar a la Base de Datos.
*   **Resultado:** Respuestas en milisegundos en lugar de segundos.

---

## Arquitectura Orientada a Servicios (SOA)

Antes de que los microservicios se pusieran de moda (2014), exist칤a SOA (Service Oriented Architecture) en los a침os 2000. Es importante distinguirlos.

### El Concepto Enterprise (Bus Empresarial)
SOA naci칩 para resolver el caos en las grandes corporaciones (Bancos, Gobierno) que ten칤an software de 1980 (Mainframes) mezclado con Java y .NET.
*   **Componente Clave: ESB (Enterprise Service Bus).**
    *   Imagina un "Traductor Universal" gigante en el centro de la empresa.
    *   Si el sistema de Recursos Humanos (Java) quiere hablar con el de N칩mina (COBOL), manda el mensaje al ESB.
    *   El ESB traduce, transforma y entrega el mensaje.

### SOA vs Microservicios
| Caracter칤stica | SOA (2000s) | Microservicios (2015+) |
| :--- | :--- | :--- |
| **Coordinaci칩n** | Inteligente (ESB). El bus tiene l칩gica. | Tonta (Smart endpoints, dumb pipes). La l칩gica est치 en el servicio. |
| **Protocolo** | SOAP/XML (Pesado). | REST/JSON o gRPC (Ligero). |
| **Datos** | A menudo compart칤an bases de datos. | Database per Service (Estricto). |
| **Tama침o** | Servicios grandes (ej. "Gesti칩n de Clientes"). | Servicios diminutos (ej. "Validar Email"). |

---

## Arquitectura Peer-to-Peer (P2P) y Descentralizada

No todo es Cliente-Servidor. En P2P, todos son clientes y servidores a la vez.

### BitTorrent y la Web Distribuida
*   **Seeders (Semillas):** Tienen el archivo completo y lo env칤an.
*   **Leechers (Sanguijuelas):** Est치n descargando, pero a la vez suben los pedazos que ya tienen a otros leechers.
*   **Swarm (Enjambre):** La red de todos los usuarios compartiendo. Nadie es el due침o central. Si apagas un nodo, la red sigue viva.

### Blockchain y Web3
La arquitectura m치s resiliente jam치s creada.
*   **Ledger Distribuido:** En lugar de que el banco tenga el libro de cuentas (Base de Datos Centralizada), *todos* los usuarios tienen una copia del libro.
*   **Consenso:** Para escribir una nueva l칤nea (transacci칩n), la mayor칤a (51%) debe estar de acuerdo.
*   **Inmutabilidad:** Una vez escrito, no se puede borrar.

### WebRTC (Real Time Communication)
Permite que dos navegadores hablen directamente (Audio/Video/Datos) sin pasar por el servidor.
*   *Uso:* Google Meet, Zoom (versi칩n web), Discord.
*   *El Servidor:* Solo se usa para el "Handshake" inicial (presentar a las partes), luego se aparta y el video fluye P2P.

---

## Arquitectura PWA (Progressive Web Apps)

El intento de la web por matar a las Apps Nativas (iOS/Android).
Una PWA es una p치gina web que, al instalarse, se comporta como una App.

### Los 3 Pilares T칠cnicos
1.  **HTTPS:** Requisito obligatorio por seguridad.
2.  **Web App Manifest (`manifest.json`):**
    *   Un archivo JSON que le dice al celular: "Mi nombre es X, mi icono es Y, y quiero abrirme en pantalla completa sin barra de URL".
3.  **Service Workers (El Cerebro):**
    *   Un proxy programable en JS que vive en el navegador.
    *   **Capacidad Offline:** Intercepta todas las peticiones de red. Si no hay internet, devuelve los archivos cacheados.

#### Ejemplo de Service Worker B치sico
```javascript
// sw.js - Instalaci칩n
self.addEventListener('install', event => {
  event.waitUntil(
    caches.open('mi-app-v1').then(cache => {
      return cache.addAll(['/', '/index.html', '/styles.css', '/app.js']);
    })
  );
});

// Interceptaci칩n de red
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request).then(response => {
      // Si est치 en cach칠, devu칠lvelo. Si no, ve a internet.
      return response || fetch(event.request);
    })
  );
});
```

---

## Arquitecturas Avanzadas: M치s all치 de lo b치sico

### Event-Driven Architecture (EDA)
En microservicios, que el servicio A llame al servicio B (HTTP sincr칩nico) crea acoplamiento. Si B cae, A falla.
**Soluci칩n:** Eventos.
*   **Productor:** "Alguien compr칩 una entrada". (Dispara evento y se olvida).
*   **Consumidor:** El servicio de Email escucha el evento y manda el correo. El servicio de Analytics escucha y actualiza el dashboard.
*   **Ventaja:** Desacoplamiento total y escalabilidad masiva.
*   **Herramientas:** Apache Kafka, RabbitMQ, AWS SNS/SQS.

### Arquitectura Hexagonal (Puertos y Adaptadores)
Inventada por Alistair Cockburn.
*   **Filosof칤a:** Tu l칩gica de negocio (Dominio) debe vivir en el centro, aislada del mundo exterior.
*   **Puertos:** Interfaces que definen qu칠 necesita tu app (ej. `IUsuarioRepository`).
*   **Adaptadores:** Implementaciones reales (ej. `SqlUsuarioRepository`, `MockUsuarioRepository`).
*   **Resultado:** Puedes cambiar la Base de Datos de MySQL a Mongo sin tocar una sola l칤nea de tu l칩gica de negocio. Solo cambias el adaptador.

---

## Laboratorio de C칩digo: Implementando Microservicios

Es f치cil dibujar cajas en una pizarra. Vamos a ver c칩mo se ve la arquitectura de microservicios en c칩digo real (Node.js).

Imagina un sistema de E-commerce simplificado. No haremos una aplicaci칩n completa, sino dos servicios que hablan por HTTP.

### Servicio 1: Inventario (Puerto 3000)
Este servicio es el "due침o" de los datos de productos. Nadie m치s puede tocar la BD de productos.
```javascript
// inventory-service.js
const express = require('express');
const app = express();

const products = {
    '101': { name: 'Laptop Gamer', stock: 5 },
    '102': { name: 'Mouse 칍ptico', stock: 0 } // Agotado
};

app.get('/products/:id', (req, res) => {
    const product = products[req.params.id];
    if (product) {
        res.json(product);
    } else {
        res.status(404).json({ error: 'Producto no encontrado' });
    }
});

app.listen(3000, () => console.log('游닍 Servicio de Inventario corriendo en :3000'));
```

### Servicio 2: 칍rdenes (Puerto 4000)
Este servicio maneja las compras. Para vender, **necesita preguntar** al servicio de inventario si hay stock. No consulta la BD de inventario directamente (eso romper칤a el patr칩n).
```javascript
// order-service.js
const express = require('express');
const axios = require('axios'); // Librer칤a para hacer peticiones HTTP
const app = express();

app.post('/buy/:productId', async (req, res) => {
    const pid = req.params.productId;

    try {
        // Llamada S칤ncrona a otro microservicio (Comunicaci칩n Inter-Servicios)
        // En una app real, usar칤amos un Service Discovery para no harcodear 'localhost:3000'
        const response = await axios.get(`http://localhost:3000/products/${pid}`);
        const product = response.data;

        if (product.stock > 0) {
            // L칩gica compleja de negocio... cobrar tarjeta, etc.
            res.json({ message: `춰Compra exitosa de ${product.name}!` });
        } else {
            res.status(400).json({ error: 'Producto agotado :(' });
        }
    } catch (error) {
        if (error.response && error.response.status === 404) {
            res.status(404).json({ error: 'El producto no existe' });
        } else {
            res.status(500).json({ error: 'Error de comunicaci칩n interna' });
        }
    }
});

app.listen(4000, () => console.log('游 Servicio de 칍rdenes corriendo en :4000'));
```

**An치lisis del C칩digo:**
1.  **Desacoplamiento:** Si cambiamos la BD de Inventario de una simple variable a MongoDB, el servicio de 칍rdenes *no se entera* y *no se rompe*. Solo le importa que la API `/products/:id` siga respondiendo JSON.
2.  **Punto de Falla:** Si el servicio de Inventario se cae, el de 칍rdenes falla (error 500). Para arreglar esto, en arquitectura avanzada usamos **Circuit Breakers**.

---

## Estudios de Caso: Arquitectura a Escala Planetaria

### Caso 1: Netflix (El Campe칩n de los Microservicios)
Netflix no siempre fue as칤. En 2008, un error en su base de datos Oracle centralizada tumb칩 el servicio por 3 d칤as. No pod칤an enviar DVDs.

*   **La Migraci칩n:** Decidieron migrar a AWS y romper su monolito Java en microservicios.
*   **El Resultado (2024):**
    *   Tienen m치s de 1,000 microservicios.
    *   Un servicio solo para manejar el bot칩n de "Play".
    *   Un servicio solo para recordar d칩nde pausaste la pel칤cula.
*   **Caos Monkey:** Inventaron una herramienta que apaga servidores aleatoriamente en horario de oficina.
    *   *Filosof칤a:* "Si nos duele que se apague un servidor, apagu칠moslo seguido para obligarnos a dise침ar el sistema para que sobreviva".

### Caso 2: Uber (Domando la Complejidad)
Al principio (2011), Uber era un monolito simple en Python.
Con la expansi칩n global (UberEats, UberPool), el monolito era inmanejable.
*   **El Problema:** Para agregar una funci칩n a UberEats, ten칤as que recompilar y desplegar toda la app de Taxis. Riesgo alt칤simo.
*   **Arquitectura Actual:**
    *   **+4,000 Microservicios:** Escritos en Go, Java, Python y Node.
    *   **Edge Gateway:** Un punto de entrada 칰nico que enruta al usuario al servicio correcto.
    *   **Manejo de Geozonas:** Usan una librer칤a llamada H3 (칤ndice espacial hexagonal) para dividir el mundo en celdas y asignar conductores eficientemente.

### Caso 3: Instagram (Escalando el Monolito)
Contrario a la moda, Instagram es famoso por **mantener su Monolito**.
*   **Tecnolog칤a:** Python (Django). S칤, Instagram corre sobre Django.
*   **El Truco:** No rompieron el c칩digo en microservicios, pero rompieron la Base de Datos.
    *   **Sharding (Fragmentaci칩n):** Tienen miles de instancias de PostgreSQL. Tus fotos no est치n en la misma BD que las de un usuario en Jap칩n.
    *   **Cach칠 Agresivo:** Usan Memcached masivamente. Casi nada toca la DB directamente.
*   **Lecci칩n:** No siempre necesitas microservicios para escalar a 1,000 millones de usuarios. A veces, un monolito bien optimizado es mejor (y m치s barato de mantener).

---

---

## Gu칤a de Decisi칩n Arquitect칩nica: 쯈u칠 debo elegir?

Como arquitecto, tu trabajo es decir "Depende". Aqu칤 tienes un 치rbol de decisi칩n para elegir entre Monolito y Microservicios.

### Scorecard de Complejidad
Suma 1 punto por cada afirmaci칩n verdadera.
1.  [ ] 쯊ienes m치s de 50 desarrolladores trabajando en el Backend?
2.  [ ] 쯅ecesitas desplegar varias veces al d칤a sin riesgo de romper todo?
3.  [ ] 쯊ienes partes del sistema que requieren hardware muy distinto (ej. Una requiere GPU para IA, otra requiere mucha RAM para Cach칠)?
4.  [ ] 쮼l negocio est치 dispuesto a pagar por un equipo de DevOps dedicado (Kubernetes, Monitoring)?
5.  [ ] 쯃os dominios del negocio est치n claramente separados (ej. Ventas y Log칤stica son departamentos que ni se hablan)?

**Resultados:**
*   **0-2 Puntos:** **Monolito Modular.** Qu칠date con Django/Laravel/Spring Boot. No te compliques. Usa m칩dulos internos en lugar de servicios de red.
*   **3-5 Puntos:** **Microservicios.** La complejidad del problema justifica la complejidad de la soluci칩n.

### El Peligro del "Monolito Distribuido"
El peor error es crear microservicios que *necesitan* hablarse todo el tiempo para funcionar.
*   *S칤ntoma:* Si para listar usuarios, el Servicio A llama al B, y el B llama al C... has creado un Monolito Distribuido. Tienes todos los problemas de los microservicios (latencia, fallos de red) y ninguna de sus ventajas (independencia).

---

## Estrategias de Renderizado Moderno (M치s all치 de SSR/CSR)

La dicotom칤a SSR vs CSR ya es vieja. Hoy tenemos h칤bridos complejos.

### SSG (Static Site Generation)
El servidor **pre-calcula** todo el HTML en tiempo de compilaci칩n (Build Time), no cuando el usuario entra.
*   **Herramientas:** Gatsby, Next.js (modo est치tico), Hugo, Jekyll.
*   **Ventaja:** Velocidad absurda. El servidor solo entrega archivos HTML simples. Inmune a hackeos de base de datos (porque no hay base de datos conectada en tiempo real).
*   **Desventaja:** Si cambias un precio, tienes que reconstruir y desplegar todo el sitio (tarda minutos). No sirve para datos en tiempo real (ej. Stock de Amazon).

### ISR (Incremental Static Regeneration)
El Santo Grial inventado por **Vercel (Next.js)**. Combina lo mejor de todos los mundos.
*   **Funcionamiento:**
    1.  Generas tus 10,000 productos est치ticamente (SSG).
    2.  Le dices a Next.js: "Si alguien pide este producto y han pasado 60 segundos, regeneralo en segundo plano".
    3.  El usuario siempre ve una p치gina est치tica r치pida (cacheada), pero nunca est치 desactualizada por m치s de 1 minuto.

### Jamstack (JavaScript, APIs, Markup)
No es una tecnolog칤a, es una arquitectura.
*   **Filosof칤a:** Desacopla el Frontend del Backend completamente.
*   **J** (JavaScript): Toda la l칩gica din치mica corre en el cliente (Hydration).
*   **A** (APIs): Toda la base de datos se consulta v칤a APIs (Stripe, Contentful, Firebase).
*   **M** (Markup): HTML pre-renderizado.

---

---

## Patrones de Resiliencia y Teor칤a Distribuida

Cuando tienes un solo servidor, si se cae, se cae todo. En sistemas distribuidos, las fallas son parciales y constantes. Aqu칤 la teor칤a se pone seria.

### El Teorema CAP (Brewer's Theorem)
En cualquier sistema distribuido, solo puedes tener **2 de 3** propiedades simult치neamente:
1.  **C**onsistency (Consistencia): Todos los nodos ven los mismos datos al mismo tiempo.
2.  **A**vailability (Disponibilidad): Cada petici칩n recibe respuesta (sin garant칤a de que sean los datos m치s recientes).
3.  **P**artition Tolerance (Tolerancia a Particiones): El sistema sigue funcionando aunque se corte el cable de red entre dos nodos.

*   **Desglose:**
    *   **CP (Bancos):** Si se cae la red, prefiero denegar el pago (perder Disponibilidad) a que tengas saldo negativo fantasma (mantener Consistencia).
    *   **AP (Redes Sociales):** Si se cae la red, prefiero mostrarte un like viejo (mantener Disponibilidad) a mostrarte un error 500. La Consistencia llegar치 despu칠s.

### ACID vs BASE
El mundo SQL vs NoSQL.
*   **ACID (Atomicidad, Consistencia, Aislamiento, Durabilidad):**
    *   Transacciones "todo o nada". Exigente y dif칤cil de escalar.
*   **BASE (Basically Available, Soft state, Eventual consistency):**
    *   *Eventual Consistency:* "Al final, todos tendr치n el dato correcto". Si le das like a una foto, tu amigo en Jap칩n puede tardar 2 segundos en verlo. No pasa nada.

### Patr칩n SAGA (Deshacer el pasado)
En Microservicios, no puedes hacer "Rollback" f치cil porque cada servicio tiene su propia base de datos.
**Soluci칩n:** Si algo falla al final, debes ejecutar una "transacci칩n compensatoria" (un *Undo* manual) en todos los pasos anteriores.
*   Ejemplo: Si falla el env칤o, el sistema dispara autom치ticamente un "Reembolsar Dinero" al servicio de Pagos.

### Rate Limiting (Limitaci칩n de Velocidad)
Protege tu API de ataques DDoS o usuarios abusivos.
*   **Algoritmo Token Bucket:** Tienes una cubeta con 10 monedas. Cada petici칩n gasta una moneda. Se rellena 1 moneda por segundo. Si no hay monedas, rechazas la petici칩n (HTTP 429 Too Many Requests).

---

## Glosario T칠cnico de Arquitectura

*   **API Gateway:** Servidor 칰nico que act칰a como entrada para todos los clientes (m칩vil, web), enrutando peticiones a los microservicios adecuados.
*   **BFF (Backend for Frontend):** Patr칩n donde creas un backend espec칤fico para el m칩vil y otro para la web, optimizando los datos para cada pantalla.
*   **Circuit Breaker (Cortacircuitos):** Patr칩n de dise침o que detecta fallos y evita que la aplicaci칩n trate de ejecutar una acci칩n condenada al fracaso (ej. si el servicio de pagos est치 ca칤do, ni siquiera intenta llamarlo, devuelve error inmediato).
*   **Container (Contenedor):** Unidad est치ndar de software (Docker) que empaqueta el c칩digo y sus dependencias para que la aplicaci칩n corra r치pido y fiable en cualquier entorno.
*   **Daemon:** Proceso inform치tico que se ejecuta en segundo plano, en lugar de estar bajo el control directo de un usuario interactivo.
*   **Event-Driven (Orientado a Eventos):** Arquitectura donde los servicios se comunican emitiendo eventos ("UsuarioRegistrado") en lugar de llamadas directas.
*   **Horizontal Scaling (Escalado Horizontal):** A침adir m치s m치quinas al pool de recursos (m치s barato, m치s complejo).
*   **Idempotencia:** Propiedad de una operaci칩n que puede ejecutarse varias veces sin cambiar el resultado m치s all치 de la aplicaci칩n inicial (ej. Reintentar un pago fallido no deber칤a cobrarte dos veces).
*   **Legacy System:** Software antiguo que sigue siendo cr칤tico para el negocio pero es dif칤cil de mantener o migrar.
*   **Load Balancer:** Dispositivo que act칰a como proxy inverso y distribuye el tr치fico de red o aplicaci칩n entre varios servidores.
*   **Monorepo:** Estrategia donde el c칩digo de muchos proyectos (o microservicios) se guarda en un mismo repositorio de Git.
*   **Orquestaci칩n:** Gesti칩n automatizada de la configuraci칩n, coordinaci칩n y gesti칩n de sistemas inform치ticos y software (ej. Kubernetes).
*   **Vertical Scaling (Escalado Vertical):** A침adir m치s RAM/CPU a una sola m치quina (f치cil, pero tiene l칤mite f칤sico).

---

---

## La 칔ltima Frontera: Islands Architecture (Arquitectura de Islas)

Mientras SPA (Single Page Applications) domin칩 el 2015-2020, el problema del peso de JavaScript (JS Bloat) se volvi칩 cr칤tico.
*   **Problema:** Para mostrar un blog est치tico en React, el usuario descargaba 300KB de JavaScript. Absurdo.

### El Concepto de "Islas"
La web moderna a veces carga demasiado JavaScript innecesario.
**Soluci칩n (Astro):** Env칤a casi todo como HTML est치tico (r치pido) y solo "enciende" (hidrata) el JavaScript en las partes interactivas, como un carrusel de im치genes o un bot칩n de compra. El resto de la p치gina es est치tica y ligera.

---

## Ejercicios y Retos de Dise침o

### Reto 1: Dise침ando "Uber Clon"
Eres el arquitecto jefe. Tienes que dise침ar el sistema.
1.  **Requerimiento:** El conductor debe ver su posici칩n actual y la del pasajero en tiempo real.
    *   *Pregunta:* 쯋sar칤as HTTP REST o WebSockets? 쯇or qu칠?
2.  **Requerimiento:** Si el servicio de "Mapas" falla, la app no debe crashear, solo debe mostrar "Mapa no disponible" pero permitir cancelar el viaje.
    *   *Pregunta:* 쯈u칠 patr칩n de microservicios usar칤as aqu칤? (Pista: Circuit Breaker).

### Reto 2: Migraci칩n Legacy
Tienes una Tienda Online hecha en PHP puro (2008) sin frameworks. Es un caos de c칩digo espagueti. El due침o quiere "pasarlo a React".
*   *Estrategia:* No puedes reescribir todo en un mes. Prop칩n una estrategia usando el "Strangler Fig Pattern" (Patr칩n de la Higuera Estranguladora) para ir migrando pieza por pieza.

---

## Referencias

*   **Libros:** "Clean Architecture" de Robert C. Martin, "Building Microservices" de Sam Newman, "Designing Data-Intensive Applications" de Martin Kleppmann.
*   **Webs:** The Twelve-Factor App Official Site, MartinFowler.com, AWS Whitepapers, Astro Docs.

<div align="center">

[拘勇 Anterior: 1.1 Evoluci칩n](1.1.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 1.3 Tecnolog칤as](1.3.md) 俱뫮잺

</div>
