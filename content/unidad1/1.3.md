# 1.3 Tecnolog√≠as para el desarrollo de aplicaciones web

## El Panorama Tecnol√≥gico
El desarrollo web cambia r√°pido. Para navegar este caos, dividimos las tecnolog√≠as en capas.
> **Regla de Oro:** "No aprendas herramientas, aprende fundamentos. Las herramientas cambian, los fundamentos (HTTP, DNS) permanecen."

---

## El Frontend Moderno: Ingenier√≠a de Interfaces

El Frontend ha pasado de ser "dise√±o gr√°fico" a ser ingenier√≠a de software compleja.

### Los Tres Mosqueteros (La Base Inevitable)
No importa qu√© framework uses, al final todo se compila a estos tres:

1.  **HTML5 (Sem√°ntica y Estructura):**
    *   No es solo `<div>`. Es accesibilidad (`aria-labels`), SEO (`<meta>`) y APIs de dispositivo (C√°mara, Geolocalizaci√≥n).
    *   *Evoluci√≥n:* De `<div id="header">` a `<header>`.
2.  **CSS3 (Presentaci√≥n y Animaci√≥n):**
    *   Ya no necesitamos jQuery para animar. Flexbox y Grid revolucionaron el layout.
    *   *Variables CSS:* `--main-color: #ff0000;` nativo.
3.  **JavaScript (ES6+ / TypeScript):**
    *   Desde 2015 (ES6), JS es un lenguaje maduro (Clases, M√≥dulos, Promesas, Async/Await).
    *   **TypeScript:** Es JavaScript con tipos (`string`, `int`). Se ha convertido en el est√°ndar industrial para evitar errores ("undefined is not a function").

> **üíª C√≥digo en Acci√≥n:**
> Mira la diferencia abismal entre escribir JavaScript "Antiguo" y "Moderno".
>
> üìÑ **Ver c√≥digo:** [04_comparativa_lenguajes.js](codigos/04_comparativa_lenguajes.js)
> (Ejecuta con `node 04_comparativa_lenguajes.js` para ver la salida limpia)

### Frameworks de Componentes (React vs Vue vs Angular)
Hoy en d√≠a construimos con **Componentes** (piezas reutilizables), no p√°ginas enteras.

| Framework | Filosof√≠a | Uso Ideal |
| :--- | :--- | :--- |
| **React** | "Es solo una librer√≠a". Flexibilidad total. | Est√°ndar de la industria. Trabajo seguro. |
| **Vue.js** | F√°cil y progresivo. | Startups y aprendizaje r√°pido. |
| **Angular** | Todo incluido (Router, HTTP). Robusto. | Bancos y empresas gigantes. |
| **Svelte** | Sin framework en el navegador. | Apps ultra-r√°pidas. |

### Build Tools (Los Empaquetadores)
El navegador no entiende archivos `.vue` o `.jsx` o TypeScript. Alguien tiene que traducirlos.
*   **Webpack:** El rey antiguo. Poderoso pero configuraci√≥n infernal.
*   **Vite (El Nuevo Est√°ndar):** Creado por el autor de Vue. Es instant√°neo. Usa ES Modules nativos. Si empiezas hoy, usa Vite.
*   **Babel:** El traductor. Convierte c√≥digo JS moderno (2025) a c√≥digo que entienda Internet Explorer (si es que alguien lo usa).

### La Guerra del CSS: Tailwind vs Bootstrap

| Caracter√≠stica | Bootstrap (Cl√°sico) | Tailwind CSS (Moderno) |
| :--- | :--- | :--- |
| **Estilo** | Componentes listos (`btn-primary`). | Utilidades (`bg-blue-500 p-4`). |
| **Personalizaci√≥n** | Dif√≠cil. Todos los sitios se ven igual. | Total. Creas tu propio dise√±o. |
| **Veredicto** | R√°pido para prototipos. | Est√°ndar moderno. |

### Gesti√≥n del Estado (State Management)
El problema eterno: "¬øC√≥mo le paso datos del componente A al componente Z sin pasar por todos los del medio (Prop Drilling)?"
*   **Context API (Nativo de React):** Bueno para datos simples (Usuario logueado, Tema Oscuro/Claro).
*   **Redux (El Gigante):** Potente pero muy complejo (Boilerplate). Un solo "Store" inmutable. Ideal para apps financieras o muy grandes.
*   **Zustand / Jotai:** La nueva ola. Simples, minimalistas y sin tanto c√≥digo.
*   **TanStack Query (React Query):** No es gesti√≥n de estado global, es gesti√≥n de estado **as√≠ncrono** (Servidor). Elimina el 90% del uso de useEffect para fetch de datos.

---

## El Backend Moderno: Motores de L√≥gica

Aqu√≠ ocurre la magia: Pagos, Base de Datos, Autenticaci√≥n, IA.

### Node.js (JavaScript en el Servidor)
*   *Filosof√≠a:* Non-blocking I/O. Un solo hilo que nunca se detiene.
*   *Ventaja:* "Isomorfismo". Usas el mismo lenguaje (JS) en Frontend y Backend. Compartes c√≥digo.
*   *Uso:* Apps en tiempo real (Chats, Uber), APIs REST, Streaming (Netflix usa Node).

### Python (Django / FastAPI)
*   *Filosof√≠a:* "Bater√≠as incluidas" (Django) o "Velocidad pura" (FastAPI).
*   *Ventaja:* El lenguaje de la Inteligencia Artificial. Librer√≠as infinitas.
*   *Uso:* Data Science, Instagram (Django), Pinterest, ML Integrations.

### Go (Golang)
*   *Filosof√≠a:* Creado por Google para reemplazar a C++. Simple, compilado, concurrencia nativa (Goroutines).
*   *Ventaja:* Rendimiento brutal con sintaxis f√°cil.
*   *Uso:* Microservicios de alto tr√°fico (Uber migr√≥ de Node a Go), Docker y Kubernetes est√°n hechos en Go.

### Java (Spring Boot) / C# (.NET)
*   *Filosof√≠a:* Robustez, Tipado est√°tico fuerte, Entorno corporativo.
*   *Ventaja:* Estabilidad y ecosistema maduro.
*   *Uso:* Bancos, Aseguradoras, Gobiernos. Software que debe durar 20 a√±os.

### PHP (Laravel)
*   *Filosof√≠a:* "La web es su hogar".
*   *Realidad:* Mueve el 70% de la web (WordPress). Laravel lo moderniz√≥ y es una joya de productividad.
*   *Uso:* Freelancing, Agencias, E-commerce r√°pido.

### Comparativa R√°pida
*   **Node.js:** Perfecto para Startups y apps en tiempo real (Chats, Ubers).
*   **Python:** El rey de la Inteligencia Artificial y Data Science.
*   **Go:** Para sistemas que necesitan aguantar millones de visitas (Alto rendimiento).
*   **Java/C#:** El est√°ndar de las grandes corporaciones y bancos.
*   **PHP:** El rey de la web f√°cil y r√°pida (Freelancers, Agencias).

---

## Bases de Datos: El Oro del Siglo XXI

No existe una "mejor base de datos". Existe la adecuada para tus datos.

### Relacionales (SQL - ACID)
Datos estructurados, tablas fijas, relaciones estrictas.
*   **PostgreSQL:** El est√°ndar open source moderno. Soporta JSON tambi√©n.
*   **MySQL / MariaDB:** El cl√°sico. R√°pido para lecturas.

### No Relacionales (NoSQL - BASE)
Escalabilidad horizontal, esquemas flexibles.
*   **Documental (MongoDB):** Guardas JSONs. Ideal para cat√°logos de productos variados.
*   **Key-Value (Redis):** RAM pura. Cach√©, sesiones, colas.
*   **Grafos (Neo4j):** "¬øQui√©n es amigo del amigo de mi amigo?". Redes sociales, recomendaciones (Como el motor de Netflix).
*   **Time-Series (InfluxDB):** Datos de sensores IoT, logs, m√©tricas financieras.

---

## Cloud Computing y DevOps: La Infraestructura Moderna

"El c√≥digo que funciona en tu m√°quina no sirve si no funciona en producci√≥n".

### Los Tres Grandes (Cloud Providers)
Ya nadie compra servidores f√≠sicos (On-Premise) a menos que sea un banco paranoico.
1.  **AWS (Amazon Web Services):** El pionero y l√≠der (33% del mercado). Complejo pero omnipresente.
2.  **Microsoft Azure:** El favorito de las empresas que ya usan Windows/Office. Crecimiento enorme.
3.  **Google Cloud (GCP):** El favorito para Big Data y Kubernetes.

### Contenedores (Docker)
Antes, enviabas el c√≥digo y rezabas para que el servidor tuviera la misma versi√≥n de Python que t√∫.
*   **Docker:** Empaqueta tu c√≥digo + librer√≠as + sistema operativo en una "caja" (Container).
*   **Promesa:** "Si corre en mi m√°quina, corre en cualquier lado".

### Orquestaci√≥n (Kubernetes)
Docker maneja un contenedor. **Kubernetes** maneja miles.
Si un servidor se cae, Kubernetes levanta otro autom√°ticamente en segundos. Es el "capit√°n" del barco.

### CI/CD (Continuous Integration / Continuous Deployment)
Automatizaci√≥n del despliegue.
*   **CI (Integraci√≥n):** GitHub Actions detecta que subiste c√≥digo, corre los tests autom√°ticos. Si fallan, te avisa.
*   **CD (Despliegue):** Si los tests pasan, el c√≥digo se sube autom√°ticamente a producci√≥n sin intervenci√≥n humana.
*   *Herramientas:* GitHub Actions, Jenkins, CircleCI.

---

## Tecnolog√≠as de Comunicaci√≥n (APIs)

No basta con HTTP GET/POST. Hay formas m√°s sofisticadas de hablar.

### REST (Representational State Transfer)
El est√°ndar de facto.
*   *Formato:* JSON.
*   *Verbos:* GET, POST, PUT, DELETE.
*   *Desventaja:* **Over-fetching**. Pides `/users/1` y te devuelve 50 campos, aunque solo quer√≠as el nombre.

### GraphQL (La Revoluci√≥n de Facebook)
Un lenguaje de consulta para tu API.
*   *Filosof√≠a:* "Pide exactamente lo que necesitas, nada m√°s".
*   *Ejemplo Query:*
    ```graphql
    {
      user(id: "1") {
        name
        avatar
      }
    }
    ```
*   *Ventaja:* Evita el over-fetching. Ideal para m√≥viles con pocos datos.
*   *Desventaja:* Complejidad de cach√© y seguridad en el backend.

### gRPC (Google Remote Procedure Call)
Alto rendimiento entre microservicios.
*   *Formato:* **Protobuf** (Binario, no texto). Mucho m√°s ligero que JSON.
*   *Protocolo:* HTTP/2 nativo.
*   *Uso:* Comunicaci√≥n interna entre microservicios (Backend a Backend). No suele usarse directamente desde el navegador.

### WebSockets (Real-Time)
Comunicaci√≥n bidireccional persistente.
*   *Diferencia:* En HTTP, el cliente siempre inicia. En WebSockets, el servidor puede enviar datos al cliente sin que este pregunte.
*   *Uso:* Chats, Juegos Multijugador, Bolsa de Valores en vivo.

---

## Seguridad y Autenticaci√≥n: El Guardi√°n

"La seguridad no es una caracter√≠stica, es un requisito b√°sico".

### M√©todos de Autenticaci√≥n
1.  **Session-Based (Cl√°sico):** El servidor crea una "sesi√≥n" en memoria y le da una cookie al navegador.
    *   *Problema:* Dif√≠cil de escalar horizontalmente (¬øqu√© pasa si el usuario cae en otro servidor que no tiene la sesi√≥n?).
2.  **Token-Based (JWT - JSON Web Tokens):** El est√°ndar moderno.
    *   *Funcionamiento:* El servidor te da un "gafete" firmado criptogr√°ficamente. El servidor no guarda nada en memoria. Solo verifica la firma.
    *   *Ventaja:* Stateless. Escala infinito.
3.  **OAuth 2.0 / OIDC:** "Inicia sesi√≥n con Google/Facebook".
    *   Delegas la seguridad a un experto. No toques las contrase√±as de los usuarios si puedes evitarlo.

### HTTPS y Certificados SSL/TLS
Hoy en d√≠a, Chrome marca como "No Seguro" cualquier sitio HTTP.
*   **Let's Encrypt:** Revolucion√≥ la web dando certificados SSL gratuitos y autom√°ticos. Ya no hay excusa para no usar HTTPS.

---

## Testing: Calidad de Software

Si no est√° probado, est√° roto.

### Pir√°mide de Testing
1.  **Unit Tests (Base):** Prueban una funci√≥n aislada (`sumar(2,2)`). R√°pidos y baratos. (Jest, Vitest).
2.  **Integration Tests (Centro):** Prueban que la Base de Datos hable bien con la API.
3.  **E2E (End-to-End) (Punta):** Un robot abre el navegador real, hace clic en "Comprar" y verifica que salga el recibo. Lentos y caros pero simulan al usuario real. (Cypress, Playwright).

---

## Tendencias Emergentes (El Futuro)

### WebAssembly (Wasm)
Ejecutar c√≥digo binario de C++, Rust o Go en el navegador a velocidad casi nativa.
*   *Uso:* Photoshop Web, Figma, editores de video en el navegador, juegos 3D.
*   *Revoluci√≥n:* Rompe el monopolio de JavaScript en el navegador.

### Low-Code / No-Code
Herramientas como Webflow, Bubble o OutSystems.
*   *Realidad:* Permiten crear aplicaciones simples 10x m√°s r√°pido.
*   *Amenaza:* ¬øReemplazar√°n a los programadores? No, pero eliminar√°n el trabajo repetitivo y aburrido (CRUDs b√°sicos).

### AI-Assisted Coding
GitHub Copilot, Cursor, ChatGPT.
*   *Cambio de Paradigma:* El programador pasa de ser un "escritor de c√≥digo" a un "editor y arquitecto de c√≥digo".
*   *Peligro:* Generar c√≥digo que no entiendes. Si hay un bug, no sabr√°s arreglarlo.

---

## La Piedra Rosetta del Backend: 5 Lenguajes, 1 Misi√≥n

Para entender realmente las diferencias, no leas teor√≠a. Lee c√≥digo.
Vamos a crear la misma **API REST** (`GET /hello`) que devuelve `{"message": "Hello World"}` en los 5 lenguajes m√°s importantes.

### Node.js (con Express)
*   **Veredicto:** Conciso, as√≠ncrono, familiar si vienes del Frontend.
```javascript
const express = require('express');
const app = express();

app.get('/hello', (req, res) => {
    res.json({ message: "Hello World from Node.js" });
});

app.listen(3000, () => console.log('Server on port 3000'));
```

### Python (con FastAPI)
*   **Veredicto:** Elegante, tipado moderno, documentaci√≥n autom√°tica (Swagger) gratis.
```python
from fastapi import FastAPI
import uvicorn

app = FastAPI()

@app.get("/hello")
def read_root():
    return {"message": "Hello World from Python"}

if __name__ == "__main__":
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### Go (Golang - Librer√≠a Est√°ndar)
*   **Veredicto:** Verboso pero expl√≠cito. Sin frameworks pesados. Compila a binario. Rendimiento brutal.
```go
package main

import (
    "encoding/json"
    "net/http"
)

type Response struct {
    Message string `json:"message"`
}

func helloHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "application/json")
    response := Response{Message: "Hello World from Go"}
    json.NewEncoder(w).Encode(response)
}

func main() {
    http.HandleFunc("/hello", helloHandler)
    http.ListenAndServe(":8080", nil)
}
```

### Java (con Spring Boot)
*   **Veredicto:** Mucho "boilerplate" (c√≥digo repetitivo), anotaciones m√°gicas, orientado a objetos puro. Robusto.
```java
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.HashMap;
import java.util.Map;

@SpringBootApplication
@RestController
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

    @GetMapping("/hello")
    public Map<String, String> hello() {
        HashMap<String, String> map = new HashMap<>();
        map.put("message", "Hello World from Java");
        return map;
    }
}
```

### PHP (Vanilla Moderno)
*   **Veredicto:** El m√°s simple de desplegar (solo sube el archivo). Sin servidor de aplicaciones complejo.
```php
<?php
// index.php
header('Content-Type: application/json');

$response = [
    "message" => "Hello World from PHP"
];

echo json_encode($response);
?>
```

### An√°lisis Comparativo Final
1.  **L√≠neas de C√≥digo:** Python y Node ganan por goleada. Java pierde.
2.  **Velocidad de Arranque:** Go y PHP son instant√°neos. Java tarda segundos.
3.  **Tipado:** Java y Go son estrictos (menos bugs en runtime). Node y Python son din√°micos (riesgo de errores tontos).

---

---

## Deep Dive: Estructura Profesional del MERN Stack

Decimos "MERN" muy a la ligera. As√≠ es como se estructura un proyecto real de nivel senior.

### Backend (Node/Express): Arquitectura por Capas
Jam√°s escribas toda la l√≥gica en el archivo `index.js`.
```text
/backend
‚îú‚îÄ‚îÄ /config         # Variables de entorno, conexi√≥n a DB
‚îú‚îÄ‚îÄ /controllers    # L√≥gica de los endpoints (req, res)
‚îú‚îÄ‚îÄ /models         # Esquemas de Mongoose (User, Product)
‚îú‚îÄ‚îÄ /routes         # Definici√≥n de rutas (/api/users, /api/auth)
‚îú‚îÄ‚îÄ /middleware     # Verificaci√≥n de JWT, manejo de errores
‚îú‚îÄ‚îÄ /utils          # Funciones auxiliares (enviar email, calcular fecha)
‚îî‚îÄ‚îÄ server.js       # Punto de entrada
```

### Frontend (React): Patr√≥n de Caracter√≠sticas (Feature-Based)
Olvida agrupar por "tipos" (todos los componentes juntos). Agrupa por "funcionalidad".
```text
/frontend/src
‚îú‚îÄ‚îÄ /assets         # Im√°genes, fuentes
‚îú‚îÄ‚îÄ /components     # UI Gen√©rica (Botones, Inputs, Modales reutilizables)
‚îú‚îÄ‚îÄ /features       # L√≥gica de negocio encapsulada
‚îÇ   ‚îú‚îÄ‚îÄ /auth       # Login, Register, ForgotPassword
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ /components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ /hooks  # useAuth, useLogin
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ /api    # authService.js
‚îÇ   ‚îî‚îÄ‚îÄ /products   # ProductList, ProductDetail
‚îú‚îÄ‚îÄ /layouts        # DashboardLayout, AuthLayout
‚îú‚îÄ‚îÄ /pages          # Vistas completas que unen todo
‚îú‚îÄ‚îÄ /routes         # AppRouter, PrivateRoute
‚îî‚îÄ‚îÄ /services       # Configuraci√≥n de Axios
```

### El Flujo de Datos (The Data Flow)
1.  **Frontend:** Usuario llena formulario en `LoginPage.jsx`.
2.  **Frontend:** `authService.js` env√≠a POST a `https://api/login`.
3.  **Backend:** `authRoutes.js` recibe la petici√≥n.
4.  **Backend:** `authMiddleware.js` valida que el body tenga email/password.
5.  **Backend:** `authController.js` busca en `UserModel.js`.
6.  **Backend:** Si es correcto, genera un JWT y responde 200 OK.
7.  **Frontend:** Guarda el JWT en `localStorage` o Cookies.

---

## Modelado de Datos: SQL vs NoSQL (Caso Pr√°ctico)

¬øC√≥mo guardamos una factura en ambos mundos?

### En SQL (PostgreSQL - Normalizado)
Necesitamos 3 tablas separadas para evitar redundancia.

**Tabla: Users**
| id | name | email |
| :--- | :--- | :--- |
| 1 | Juan | juan@mail.com |

**Tabla: Orders**
| id | user_id | date | total |
| :--- | :--- | :--- | :--- |
| 100 | 1 | 2024-01-20 | 500.00 |

**Tabla: Order_Items** (Tabla pivote)
| id | order_id | product_name | qty | price |
| :--- | :--- | :--- | :--- | :--- |
| 50 | 100 | Laptop | 1 | 450 |
| 51 | 100 | Mouse | 1 | 50 |

*   **Consulta:** `JOIN Users ON Orders.user_id = Users.id JOIN Order_Items...`

### En NoSQL (MongoDB - Documento Embebido)
Todo vive junto. Lectura at√≥mica ultra r√°pida.
```json
// Colecci√≥n: Orders
{
  "_id": "507f1f77bcf86cd799439011",
  "date": "2024-01-20",
  "total": 500.00,
  "user": {
    "name": "Juan",
    "email": "juan@mail.com"
  },
  "items": [
    { "product": "Laptop", "qty": 1, "price": 450 },
    { "product": "Mouse",  "qty": 1, "price": 50 }
  ]
}
```
*   **Dilema:** Si Juan cambia su email, en NoSQL tienes que actualizarlo en TODAS sus √≥rdenes pasadas (o dejarlo desactualizado). En SQL solo lo cambias en la tabla `Users`.

---

---

## Rendimiento Web y Core Web Vitals

No importa qu√© stack uses si tu web tarda 10 segundos en cargar. Google te penalizar√°.

### M√©tricas Cr√≠ticas (Core Web Vitals de Google)
Google mide 3 cosas para decidir si rankea tu web arriba o abajo:
1.  **LCP (Largest Contentful Paint):** Velocidad de Carga.
    *   *Meta:* < 2.5 segundos.
    *   *Lo que cuenta:* Cu√°nto tarda en aparecer el elemento m√°s grande (imagen principal o t√≠tulo).
2.  **INP (Interaction to Next Paint):** Interactividad.
    *   *Meta:* < 200 milisegundos.
    *   *Lo que cuenta:* Si haces clic en un bot√≥n, ¬øcu√°nto tarda el navegador en pintar el siguiente frame? (Sustituy√≥ a FID).
3.  **CLS (Cumulative Layout Shift):** Estabilidad Visual.
    *   *Meta:* < 0.1.
    *   *Lo que cuenta:* ¬øSe mueven las cosas solas mientras leo? (Ej. Un banner publicitario carga tarde y empuja todo el texto hacia abajo).

### Lighthouse
La herramienta est√°ndar de auditor√≠a (viene en Chrome DevTools).
Mide:
*   Performance (Velocidad).
*   Accessibility (¬øPueden usarlo ciegos?).
*   Best Practices (¬øUsas HTTPS? ¬øIm√°genes optimizadas?).
*   SEO (¬øTienes meta tags?).

### SSR vs SSG vs ISR (Deep Dive Next.js)
Entender esto te pone en el top 10% de desarrolladores.
*   **SSR (Server Side Rendering):** La p√°gina se genera en el servidor en CADA petici√≥n. (Bien para SEO, Lento para el server).
*   **SSG (Static Site Generation):** La p√°gina se genera UNA VEZ al construir (Build time). Ultra r√°pido. (Bien para Blogs, Landing Pages).
*   **ISR (Incremental Static Regeneration):** Lo mejor de ambos mundos. La p√°gina es est√°tica, pero se regenera sola cada X segundos si hay nuevos datos.

---

## Git Moderno: M√°s all√° del Commit

Saber `git add .` no es suficiente.

### Git Flow vs Trunk Based
*   **Git Flow:** Ramas eternas (`develop`, `release`). Complejo. Bueno para software empaquetado (versiones 1.0, 2.0).
*   **Trunk Based Development:** Todos hacen push a `main` todos los d√≠as. Requiere Tests autom√°ticos potentes. Es lo que usan Google y Facebook.

### Conventional Commits
Escribe mensajes que las m√°quinas entiendan.
*   `feat: add new login button` (Nueva funcionalidad)
*   `fix: resolve crash on IOS` (Arreglo de bug)
*   `docs: update readme` (Documentaci√≥n)
*   **Ventaja:** Generan el CHANGELOG autom√°ticamente.

---

## Tu Entorno de Desarrollo (El Dojo del Programador)

No puedes ser un samurai con una espada de madera. Necesitas herramientas profesionales.

### VS Code: Configuraci√≥n Pro
Instala estas extensiones S√≠ o S√ç:
1.  **ESLint / Prettier:** Formato autom√°tico. Se acab√≥ el discutir si van espacios o tabs.
2.  **GitLens:** ¬øQui√©n escribi√≥ esta l√≠nea de c√≥digo hace 3 meses? GitLens te lo dice.
3.  **Live Server:** Para ver tus cambios de HTML al instante.
4.  **Thunder Client:** Como Postman, pero dentro de VS Code. Para probar tus APIs.
5.  **Material Icon Theme:** Porque los iconos bonitos ayudan a identificar archivos r√°pido.

### La Terminal (Tu mejor amiga)
Deja de usar el rat√≥n. Aprende estos comandos b√°sicos de Unix (Mac/Linux/Git Bash):
*   `ls -la`: Listar todo (incluso ocultos).
*   `cd ..`: Subir un nivel.
*   `mkdir proyecto`: Crear carpeta.
*   `touch index.js`: Crear archivo.
*   `rm -rf node_modules`: Borrar la carpeta m√°s pesada del universo (con cuidado).

---

## Ejercicios y Retos T√©cnicos

### Reto 1: "Investigaci√≥n Forense"
Ve a `facebook.com` o `amazon.com`.
1.  Abre las DevTools (F12) -> Red (Network).
2.  Filtra por "XHR" o "Fetch".
3.  Navega un poco.
4.  **Misi√≥n:** Encuentra una petici√≥n que devuelva un JSON. Copia ese JSON. ¬øQu√© estructura tiene? ¬øQu√© servidor web usan (mira los Headers)?

### Reto 2: "El Pol√≠glota"
Copia el c√≥digo de "Hello World" en **Go** (Secci√≥n 10.3).
1.  Instala Go en tu m√°quina.
2.  Ejec√∫talo (`go run main.go`).
3.  Modif√≠calo para que devuelva tu nombre en lugar de "Hello World".
4.  Modif√≠calo para que devuelva la hora actual.

### Reto 3: "Docker First Steps"
Si tienes Docker instalado:
1.  Corre: `docker run -d -p 80:80 nginx`
2.  Abre `localhost` en tu navegador.
3.  ¬°Felicidades! Tienes un servidor web profesional corriendo en 10 segundos sin instalar nada en tu sistema base.

---

## Glosario T√©cnico de Tecnolog√≠as

*   **Babel:** Transpilador de JavaScript que convierte c√≥digo moderno ES6+ en c√≥digo compatible con navegadores antiguos.
*   **CLI (Command Line Interface):** Interfaz donde interact√∫as con la computadora mediante texto en lugar de gr√°ficos.
*   **Compilador vs Int√©rprete:** El compilador (C++, Go) traduce todo el programa a binario antes de correr. El int√©rprete (Python, JS) lee y ejecuta l√≠nea por l√≠nea.
*   **Dependency Injection:** Patr√≥n de dise√±o donde las dependencias de una clase se pasan desde fuera en lugar de crearse dentro. Muy usado en Angular y Spring.
*   **DOM (Document Object Model):** Representaci√≥n en √°rbol que el navegador hace de tu HTML. JavaScript manipula el DOM, no el archivo HTML.
*   **EcmaScript (ES):** El est√°ndar oficial que define c√≥mo funciona JavaScript. ES6 (2015) fue el cambio m√°s grande.
*   **Full Stack:** Desarrollador capaz de trabajar en todas las capas (Frontend, Backend, DB, DevOps).
*   **Git:** Sistema de control de versiones distribuido.
*   **HMR (Hot Module Replacement):** Tecnolog√≠a de Vite/Webpack que actualiza el m√≥dulo que cambiaste en el navegador sin recargar toda la p√°gina.
*   **Hydration:** Proceso donde JavaScript se "conecta" al HTML est√°tico que vino del servidor para hacerlo interactivo.
*   **Isomorfismo:** Capacidad de ejecutar el mismo c√≥digo (usualmente JS) en cliente y servidor.
*   **LTS (Long Term Support):** Versiones de software (Node.js, Ubuntu) que garantizan soporte y parches de seguridad por a√±os. Usa siempre LTS en producci√≥n.
*   **Transpilaci√≥n:** Traducir c√≥digo de un lenguaje a otro de similar nivel de abstracci√≥n (ej. TypeScript a JavaScript).
*   **Webhook:** Una "llamada telef√≥nica" inversa. En lugar de que t√∫ preguntes a Stripe "ya pag√≥ el usuario?", Stripe te llama a ti (a tu URL) cuando paga.

---

## Referencias y Recursos

*   [Roadmap.sh](https://roadmap.sh/): El mapa definitivo para saber qu√© estudiar despu√©s.
*   [MDN Web Docs](https://developer.mozilla.org/): La biblia del desarrollador web.
*   [State of JS](https://stateofjs.com/): Encuesta anual sobre qu√© tecnolog√≠as est√°n ganando o perdiendo popularidad.
*   Tiobe Index: Ranking de popularidad de lenguajes.

<div align="center">

[‚¨ÖÔ∏è Anterior: 1.2 Arquitectura](1.2.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 1.4 Planificaci√≥n](1.4.md) ‚û°Ô∏è

</div>

