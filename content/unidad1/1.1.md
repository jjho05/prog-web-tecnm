# 1.1 Evolución de las aplicaciones web

## Introducción General

La **World Wide Web (WWW)** no es solo una red de computadoras; es el sistema de información más grande de la humanidad. Creada en 1989 por **Tim Berners-Lee** en el CERN, evolucionó de documentos estáticos al sistema operativo universal de nuestra era.

Entender su historia es vital. Las tecnologías actuales responden a limitaciones pasadas:
*   ¿Por qué usamos Cookies? Porque HTTP no tiene "memoria" (es stateless).
*   ¿Por qué AJAX? Porque recargar toda la página era lento.
*   ¿Por qué Contenedores? Porque configurar servidores físicos era una pesadilla.

En esta unidad, analizaremos las **cuatro eras de la web**, entendiendo el *porqué* de cada avance.

---

## Web 1.0: La Era de la Información Estática (1990 - 2004)

La **Web 1.0** (1990-2004) fue la era de la "lectura". La mayoría de los usuarios solo consumían contenido, creado por una élite técnica ("webmasters").

Su filosofía era la **publicación digital**: llevar periódicos y revistas al monitor.

### Contexto Histórico: Cronología de la Guerra de los Navegadores

La lucha por el control de la web definió el desarrollo de estándares. Aquí la cronología detallada:

| Año | Hito Clave | Detalle Técnico | Consecuencia |
| :--- | :--- | :--- | :--- |
| **1993** | **Mosaic Publicado** | Primer navegador con soporte de imágenes (fueron una revolución). | La web se vuelve visual. El tráfico explota. |
| **1994** | **Nace Netscape** | Fundada por el equipo de Mosaic. Lanzan Navigator 1.0. | Optimizaron la carga de páginas (carga progresiva de texto antes que imágenes). |
| **1995** | **Microsoft despierta** | Licencia Spyglass Mosaic y lanza **Internet Explorer 1.0**. | Comienza la guerra. Microsoft integra IE en Windows 95 Plus!. |
| **1996** | **Innovación Caótica** | Netscape 2.0 introduce **JavaScript**, Frames y Plugins. IE 3.0 responde con **CSS**, ActiveX y JScript. | Divergencia total. Los sitios web se rompen en un navegador u otro. |
| **1997** | **HTML 4.0 (Intento de Paz)** | W3C intenta estandarizar HTML para detener la fragmentación. | Ambos navegadores prometen soporte, pero implementan los estándares con bugs diferentes. |
| **1998** | **El fin de Netscape** | Microsoft lanza Windows 98 con IE 4.0 integrado e imposible de desinstalar. Netscape libera su código fuente (nace Mozilla). | Microsoft gana por monopolio de distribución. Netscape es vendido a AOL. |
| **2001** | **Dominio Total** | **Internet Explorer 6.0**. Tiene el 96% del mercado. | Al no tener competencia, Microsoft detiene la innovación de la web por 5 años (La Era Oscura). |

**Legado de la Guerra:**
Muchos de los dolores de cabeza de hoy (polyfills, prefijos de CSS como `-webkit-`, `-moz-`) son cicatrices de esta época donde la compatibilidad no estaba garantizada.

### Profundización: La Guerra de los Motores de Renderizado

Más allá de las marcas comerciales (Chrome, Firefox), lo importante son los **Motores de Renderizado** que interpretan el HTML/CSS.

1.  **Trident (MSHTML):** El corazón de Internet Explorer. Cerrado, difícil de mantener y lleno de bugs no documentados ("hasLayout"). Dominó de 1999 a 2010.
2.  **Gecko:** El motor de Netscape 6 y luego Mozilla Firefox. Open Source. Fue el primero en intentar cumplir los estándares del W3C al pie de la letra.
3.  **Presto:** Motor de Opera (hasta 2013). Legendario por ser el más rápido y eficiente en memoria, pero con una cuota de mercado minúscula.
4.  **WebKit:** Nace de KHTML (proyecto KDE de Linux). Adoptado por Apple para Safari en 2003. Google también lo usó para Chrome inicialmente.
5.  **Blink:** En 2013, Google hizo un "fork" de WebKit y creó Blink, eliminando el código legado de Apple. Ahora es el motor de Chrome, Edge, Opera, Vivaldi y Brave.

**¿Por qué importa esto?**
Hoy, casi toda la web corre sobre **Blink** (Chromium). Hemos pasado del monopolio de IE (Trident) al monopolio de Chrome (Blink). Si Google decide implementar una función no estándar, se convierte en estándar de facto.

### Cronología Detallada de Versiones HTML

HTML no siempre fue como lo conocemos.

| Versión | Año | Nuevas Etiquetas / Cambios | Ejemplo de Código de la Época |
| :--- | :--- | :--- | :--- |
| **HTML 1.0** | 1993 | Solo texto y enlaces. `H1` a `H6`, `P`, `A`, `UL`, `LI`. Sin imágenes inline al inicio. | `<h1>Titulo</h1><p>Texto</p>` |
| **HTML 2.0** | 1995 | Primer estándar oficial (RFC 1866). Agregó `<form>`, `<input>`, `<img>`. Nace la interacción. | `<form action="/cgi-bin/mail"><input name="email"></form>` |
| **HTML 3.2** | 1997 | El caos de la guerra. `<table`> para diseño. `<font>`, `<center>`, `<applet>`. Mala semántica. | `<body bgcolor="#000000" text="#00FF00">` |
| **HTML 4.01** | 1999 | Intenta separar estructura de estilo (promoviendo CSS). Introdujo `<div>` y `<span>`. | `<div id="header">` (aún sin semántica clara). |
| **XHTML 1.0** | 2000 | HTML reformulado como XML estricto. Todas las etiquetas deben cerrarse `<br />`. Muy estricto, falló comercialmente. | `<p>Hola mundo</p>` (Error si falta cierre). |
| **HTML5** | 2014 | Semántica real (`<nav>`, `<header>`, `<article>`). APIs poderosas (Geo, Storage). Adiós plugins. | `<video src="movie.mp4" controls></video>` |

### Tecnología Profunda: Cómo funcionaba la Web 1.0

#### A. Arquitectura de Archivos Físicos: El Mapeo Directo
En la Web 1.0, el servidor web (generalmente NCSA HTTPd o el primer Apache) funcionaba como un "despachador de archivos" glorificado. La seguridad era mínima y la lógica inexistente.

*   **Mapping URL a Disco:**
    Cuando solicitabas `http://mi-universidad.edu/usuarios/~juan/tesis.html`, el servidor hacía una traducción literal a `/home/juan/public_html/tesis.html`.
*   **Gestión de Enlaces:**
    Si Juan decidía reorganizar sus carpetas y mover `tesis.html` a `docs/tesis.html`, cualquier otro sitio web en el mundo que enlazara a su tesis recibía un error 404. No existían las redirecciones automáticas ni los routers inteligentes de hoy.
*   **Mantenimiento de Pesadilla:**
    Imagina que querías cambiar el logo del encabezado en un sitio de 500 páginas. En la Web 1.0, tenías que abrir y editar 500 archivos `.html` uno por uno. Esto dio origen a herramientas como **Macromedia Dreamweaver** que automatizaban estos cambios masivos ("Find and Replace in Files").

#### B. HTTP/1.0 y la falta de memoria (Stateless)
Berners-Lee diseñó HTTP para ser ligero: el servidor olvida al usuario en cuanto responde.
*   **Filosofía:** Ahorrar memoria RAM (muy cara en 1990).
*   **Problema:** Sin memoria, no hay carritos de compra. El servidor no sabe qué elegiste antes.
*   **La Solución: Cookies (1994).** Un pequeño archivo de texto que el navegador guarda y reenvía, recordándole al servidor quién eres.

#### C. CGI: La Primera Puerta al Dinamismo
**CGI (Common Gateway Interface)** no es un lenguaje, es un protocolo/estándar que define cómo un servidor web delega la generación de contenido a un programa ejecutable.

*   **El Flujo Paso a Paso:**
    1.  **Request:** Usuario llena un formulario y da clic en enviar.
    2.  **Fork:** El servidor web (Apache) recibe la petición. Pausa su ejecución y clona su proceso (fork) o lanza uno nuevo.
    3.  **Exec:** El nuevo proceso carga el intérprete (ej. `/usr/bin/perl`).
    4.  **Environment:** Apache pasa los datos del formulario (nombres, valores) al script mediante **Variables de Entorno** (`QUERY_STRING`, `REQUEST_METHOD`).
    5.  **Processing:** El script de Perl corre, analiza texto, quizás abre un archivo `.txt`, escribe algo.
    6.  **Output:** El script escribe código HTML en su "Salida Estándar" (STDOUT).
    7.  **Response:** Apache captura ese STDOUT y lo manda al navegador.
    8.  **Die:** El proceso de Perl muere y libera memoria.

*   **El Problema "C10K":**
    Este modelo funciona bien para 10 visitas por hora. Pero si tienes 10,000 usuarios concurrentes (Problema C10K), necesitas lanzar 10,000 procesos. El servidor explota por falta de memoria RAM. Esto limitó seriamente la escala de las primeras aplicaciones web.

### Ejemplo de Código: Script CGI en Perl
Este script es un ejemplo real de cómo se procesaba un formulario en 1998.

```perl
#!/usr/bin/perl
# guestbook.pl - Procesa un formulario y guarda el mensaje

use strict;
use CGI qw(:standard);

# 1. Leer los datos del formulario
my $nombre = param('nombre');
my $mensaje = param('mensaje');
my $fecha = localtime();

# 2. Guardar en archivo de texto (La "Base de Datos")
open(ARCHIVO, ">>guestbook.txt") or die "No puedo abrir el archivo";
print ARCHIVO "$date|$nombre|$mensaje\n";
close(ARCHIVO);

# 3. Generar la respuesta HTML (Server Side Rendering primitivo)
print header(); # Imprime Content-type: text/html
print start_html("Gracias por firmar");
print "<h1>¡Gracias $nombre!</h1>";
print "<p>Hemos recibido tu mensaje el $fecha.</p>";
print "<a href='index.html'>Volver al inicio</a>";
print end_html();
```

---

## Web 2.0: La Revolución Social y Colaborativa (2004 - 2010)

### El Renacimiento
Tras la crisis de las "puntocom" en el 2000, solo sobrevivieron las empresas que conectaban personas (Google, Amazon). En 2004, nació el concepto **Web 2.0**: la web como plataforma social.

Ya no solo leías; ahora **participabas** (Blogs, Wikis, Redes Sociales).

### Principios Fundamentales
1.  **La Web como Plataforma:** El software deja de instalarse en el PC y corre en el navegador.
2.  **Inteligencia Colectiva:** El valor del sitio lo crean los usuarios (Reviews de Amazon, Artículos de Wikipedia).
3.  **Datos sobre Software:** El código es commodity; los datos (quién es amigo de quién, qué compró quién) son el activo valioso.
4.  **Beta Perpetuo:** El software nunca está "terminado". Se actualiza diariamente (Continuous Deployment).

### La Revolución AJAX
Antes, para actualizar un dato, recargabas toda la página (pantalla blanca por segundos).
*   **La Solución:** AJAX permitió pedir datos al servidor en segundo plano ("Asíncrono") y actualizar solo una parte de la pantalla.
*   **Ejemplo:** Google Maps (2005). Podías mover el mapa sin recargar la página. Magia pura en su época.

**Comparativa Técnica Detallada: Modelo Clásico vs AJAX**

Para entender el salto cuántico que significó AJAX, analicemos el flujo de datos byte a byte.

| Característica | Modelo Clásico (Web 1.0) | Modelo AJAX (Web 2.0) |
| :--- | :--- | :--- |
| **Disparador** | Clic en un enlace `<a>` o envío de formulario `<form>`. | Evento JavaScript (onclick, onchange, timer). |
| **Petición** | Navegador detiene todo, muestra icono de carga, pantalla en blanco. | Motor JS envía `XMLHttpRequest` en un hilo separado. Usuario sigue interactuando. |
| **Servidor** | Procesa lógica + Renderiza HTML completo (Header + Menu + Content + Footer). | Procesa lógica + Retorna solo DATOS crudos (JSON/XML). |
| **Respuesta** | `<html>...</html>` (Ej. 50KB). | `{"status": "ok", "new_count": 5}` (Ej. 50 Bytes). |
| **Cliente** | Navegador destruye el DOM anterior, parsea el nuevo HTML, descarga CSS/JS/Img de nuevo (si no hay caché). | JavaScript recibe el JSON, busca el nodo específico en el DOM y cambia su `.innerText`. |
| **Ancho de Banda** | Alto consumo. Redundancia masiva de datos repetidos. | Mínimo. Solo viaja la información nueva. |

### Código: jQuery vs Vanilla JS (La Era Dorada de las Librerías)
En la Web 2.0, los navegadores eran muy incompatibles. Hacer AJAX en IE6 era diferente a Firefox.
Surgieron librerías para "normalizar" la web. **jQuery** fue la reina absoluta.

**Tarea: Obtener datos de un usuario y mostrarlos.**

**A. Vanilla JS (2008 - El Infierno de la compatibilidad)**
```javascript
var xhr;
if (window.XMLHttpRequest) {
    xhr = new XMLHttpRequest(); // Navegadores modernos
} else {
    xhr = new ActiveXObject("Microsoft.XMLHTTP"); // IE6 (El dolor de cabeza)
}

xhr.onreadystatechange = function() {
    if (xhr.readyState == 4 && xhr.status == 200) {
        var datos = eval("(" + xhr.responseText + ")"); // Inseguro pero común en esa época
        document.getElementById("nombre").innerHTML = "<strong>" + datos.nombre + "</strong>";
        document.getElementById("bio").style.display = "block";
    }
}
xhr.open("GET", "/api/usuario.php?id=5", true);
xhr.send();
```

**B. jQuery (2008 - La Salvación)**
Nota cómo jQuery abstrae las diferencias y permite encadenamiento (chaining).
```javascript
$.getJSON("/api/usuario.php", { id: 5 }, function(datos) {
    $("#nombre").html("<strong>" + datos.nombre + "</strong>");
    $("#bio").fadeIn("slow"); // Animaciones gratis!
});
```
*Análisis:* jQuery democratizó el desarrollo frontend. Permitía a diseñadores con poco conocimiento de programación crear interacciones complejas.

### El Auge de las APIs y SOAP vs REST
Las empresas empezaron a abrir sus puertas digitales. Surge la "Economía de las APIs".

#### Protocolo SOAP (Simple Object Access Protocol)
El estándar corporativo inicial. Basado en XML estricto.
*   **Pros:** Muy seguro (WS-Security), tipado fuerte, transaccional.
*   **Contras:** Verbosidad extrema. Mensajes gigantes para datos pequeños. Difícil de parsear en JavaScript.

**Ejemplo Request SOAP:**
```xml
<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope">
  <soap:Header>...</soap:Header>
  <soap:Body>
    <m:GetStockPrice xmlns:m="http://www.example.org/stock">
      <m:StockName>IBM</m:StockName>
    </m:GetStockPrice>
  </soap:Body>
</soap:Envelope>
```

#### Arquitectura REST (Representational State Transfer)
Propuesta por Roy Fielding en su tesis doctoral (2000).
*   Usa los verbos HTTP existentes (GET, POST, PUT, DELETE) en lugar de inventar nuevos.
*   Mucho más ligero, usualmente usa JSON (JavaScript Object Notation).
*   Se convirtió en el estándar de la Web 2.0 y 3.0.

**Ejemplo Request REST:**
```http
GET /api/stocks/IBM HTTP/1.1
Accept: application/json
```

### Stack Tecnológico: LAMP
El sistema operativo de la Web 2.0 fue Open Source.
*   **Linux:** Kernel robusto.
*   **Apache:** Servidor Web modular (`mod_php`, `mod_rewrite`).
*   **MySQL:** Base de datos relacional rápida para lecturas (ideal para webs).
*   **PHP/Perl/Python:** Lenguajes dinámicos. PHP fue el ganador absoluto por su facilidad de despliegue (solo copiar el archivo `.php` via FTP).

### Bono Histórico: Las Guerras de los Navegadores
La web no siempre fue pacífica. Hubo guerras por el dominio del mercado.

#### La Primera Guerra (1995-2001): Netscape vs Internet Explorer
*   **Netscape Navigator:** El pionero. Inventó las cookies, JavaScript y el SSL. Tenía el 90% del mercado.
*   **Microsoft (IE):** Llegó tarde, pero "incluyó" IE gratis en Windows 95. Usó tácticas monopolísticas ("Abrazar, extender y extinguir").
*   **Resultado:** Microsoft ganó. Netscape murió (pero su código renació como Firefox). IE tuvo el 95% del mercado en 2002.

#### La Segunda Guerra (2004-2012): IE vs Firefox vs Chrome
*   **El Estancamiento:** Al no tener competencia, Microsoft dejó de mejorar IE (IE6 fue una pesadilla de seguridad y bugs por 5 años).
*   **La Resistencia:** Firefox (2004) introdujo pestañas y extensiones.
*   **El Arma Nuclear:** Google lanzó **Chrome (2008)**. Era minimalista y rapidísimo (motor V8).
*   **Resultado:** Chrome devoró el mercado. Hoy tiene ~65%. IE murió (ahora es Edge, basado en Chromium).

---

## Web 3.0: Movilidad, Nube y Semántica (2010 - Actualidad)

### La Tormenta Perfecta
Alrededor de 2010, tres factores cambiaron todo:
1.  **Smartphones:** La web salió del escritorio (iPhone/Android).
2.  **La Nube (AWS):** Servidores baratos y elásticos.
3.  **Velocidad:** Los navegadores se volvieron motores de software potentes.

### La Web Semántica (El sueño vs La realidad)
Tim Berners-Lee imaginó una "Web Semántica" donde los datos tuvieran significado para las máquinas usando estándares como **RDF** (Resource Description Framework) y **OWL** (Web Ontology Language).
*   *Idea:* Que tu calendario pudiera leer automáticamente la fecha de un concierto desde una web y agendarlo, entendiendo que "Coldplay" es una banda y "Wembley" un lugar.
*   *Realidad:* Los estándares eran muy complejos. Sin embargo, conceptos simplificados como **Open Graph** (Facebook) y **Schma.org** (Google) triunfaron. Hoy, gracias a esto, cuando compartes un link en WhatsApp, aparece una vista previa con foto y título.

### Single Page Applications (SPA)
La arquitectura cambió radicalmente:
*   **Antes:** El servidor armaba el HTML.
*   **Ahora:** El navegador descarga una App completa (JavaScript) y armada la vista.
*   **Resultado:** Webs que se sienten como Apps nativas (Gmail, Facebook). Transiciones instantáneas.

Este cambio movió la complejidad del Backend al Frontend. Nació el puesto de "Frontend Engineer".

### Profundización en SPAs: El Virtual DOM
El mayor desafío de las SPAs era el rendimiento. Manipular el DOM (el árbol HTML vivo del navegador) es una operación lenta y costosa computacionalmente. Si tienes una lista de 1000 items y cambias uno, regenerar la lista completa congela el navegador.

**Solución: Virtual DOM (React)**
React introdujo una capa intermedia.
1.  React mantiene una copia del DOM en memoria (JavaScript puro), que es rapidísimo.
2.  Cuando cambian los datos, React actualiza su Virtual DOM.
3.  **Diffing:** React compara el Virtual DOM nuevo con el anterior. Detecta: *"Solo cambió el texto del `<li>` número 45"*.
4.  **Reconciliation:** React toca el DOM real *solo* para cambiar ese texto.

**Código: Componente React Moderno (Functional Component)**
```jsx
import React, { useState, useEffect } from 'react';

// Un componente es una función que retorna UI basada en el Estado
function UserProfile({ userId }) {
  // Hook de Estado: Variable reactiva
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  // Hook de Efecto: Se ejecuta cuando cambia userId
  useEffect(() => {
    async function fetchData() {
      setLoading(true);
      const response = await fetch(`https://api.ejemplo.com/users/${userId}`);
      const data = await response.json();
      setUser(data);
      setLoading(false);
    }
    fetchData();
  }, [userId]);

  if (loading) return <div>Cargando... (Spinner CSS3)</div>;

  // JSX: Parece HTML, pero es JavaScript
  return (
    <div className="card shadow-lg">
      <img src={user.avatar} alt={user.name} />
      <h1>{user.name}</h1>
      <p>{user.email}</p>
      {/* Renderizado condicional */}
      {user.isPremium && <span className="badge">PRO</span>}
    </div>
  );
}
```
*Nota:* Compara esto con el código jQuery anterior. Aquí no manipulamos el DOM (`.html()`, `.fadeIn()`). Solo declaramos *cómo debe verse* el estado, y React se encarga del resto.

---

## Web 4.0: El Futuro Inteligente y Ubicuo

### Definición: La Web Simbiótica
La Web 4.0 conecta **inteligencias**. Se caracteriza por la integración total de la IA, el mundo físico (IoT) y la descentralización.

### Tecnologías Emergentes y Futuras

#### A. WebAssembly (Wasm)
Hasta 2017, JavaScript era el único lenguaje que corría en el navegador. **WebAssembly** cambia esto.
*   Es un formato binario de bajo nivel.
*   Permite ejecutar código C++, Rust o Go en el navegador a velocidad casi nativa.
*   *Aplicaciones:* Edición de video (Adobe Premiere Web), Juegos 3D (Unity Web), Diseño (Figma usa C++ compilado a Wasm).

#### B. Web 3.0 Descentralizada (Web3/Crypto)
Un movimiento paralelo que busca devolver la propiedad de los datos a los usuarios usando **Blockchain**.
*   **Identidad:** Login con tu billetera (Metamask) en lugar de "Login con Google".
*   **Almacenamiento:** IPFS (InterPlanetary File System) para guardar archivos distribuidos, resistentes a la censura.
*   **Finanzas:** DeFi (Finanzas Descentralizadas) integradas en el navegador.

#### C. Internet de las Cosas (IoT)
La web sale de la pantalla. Tu refrigerador, tu reloj y tu coche hablan HTTP.
*   **Edge Computing:** Procesar datos en el mismo dispositivo o muy cerca (en la antena 5G) para tener latencia cero. Vital para coches autónomos.

---

## Evolución de los Protocolos: La Tubería de Internet

No podemos ignorar cómo cambiaron los "tubos" por donde viajan los datos.

### Tabla Comparativa de Protocolos HTTP

| Versión | Año | Características Técnicas | Problema que Resolvió |
| :--- | :--- | :--- | :--- |
| **HTTP/0.9** | 1991 | Solo método GET. Solo transmitía texto HTML. Sin cabeceras. La conexión se cerraba al terminar. | Intercambio de documentos simple. |
| **HTTP/1.0** | 1996 | Introduce cabeceras HTTP (metadatos), códigos de estado (200, 404), métodos POST y HEAD. Soporte para imágenes. | Web multimedia y formularios básicos. |
| **HTTP/1.1** | 1999 | **Keep-Alive:** Mantiene la conexión TCP abierta para múltiples peticiones. **Host Header:** Permite Virtual Hosting (múltiples dominios en una IP). | Rendimiento y eficiencia de IPs. Fue el estándar por 16 años. |
| **HTTP/2** | 2015 | Basado en el protocolo SPDY de Google. Es **binario**, no texto. **Multiplexación:** Varias peticiones en paralelo por una sola conexión TCP. **Header Compression (HPACK).** | Latencia y bloqueo "Head-of-Line" en aplicaciones complejas con muchos recursos. |
| **HTTP/3** | 2022 | Basado en **QUIC** (Quick UDP Internet Connections). Abandona TCP por **UDP**. Cifrado TLS 1.3 obligatorio por defecto. | Latencia en redes móviles con pérdida de paquetes. Handshake ultra-rápido. |

---

## Diccionario de Cabeceras HTTP (Headers)

El verdadero "idioma" de la web no es HTML, son las cabeceras HTTP. Son los metadatos que cliente y servidor negocian antes de enviar contenido.

### Cabeceras de Petición (Request Headers)
Lo que el navegador le dice al servidor:

1.  **`Accept`**: *"Qué formatos entiendo"*.
    *   Ej: `Accept: text/html, application/xhtml+xml, application/json`
    *   Uso: Negociación de contenido. Una API puede devolver XML o JSON según esto.
2.  **`User-Agent`**: *"Quién soy"*.
    *   Ej: `Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36...`
    *   Uso: Analytics y servir versiones diferentes (Móvil vs Desktop).
3.  **`Authorization`**: *"Aquí están mis credenciales"*.
    *   Ej: `Authorization: Bearer eyJhbGciOiJIUzI1Ni...`
    *   Uso: Enviar tokens JWT para acceder a áreas privadas.
4.  **`Cookie`**: *"Ya nos conocemos, este es mi ID"*.
    *   Ej: `Cookie: session_id=abc12345; theme=dark`
    *   Uso: Mantener sesión y preferencias.

### Cabeceras de Respuesta (Response Headers)
Lo que el servidor le responde al navegador:

1.  **`Content-Type`**: *"Qué te estoy enviando"*.
    *   Ej: `Content-Type: application/json; charset=utf-8`
    *   Uso: Crítico. Si está mal configurado (ej. enviar JS como texto plano), el navegador no ejecutará el código (medida de seguridad MIME types).
2.  **`Cache-Control`**: *"Cuánto tiempo guardar esto"*.
    *   Ej: `Cache-Control: max-age=3600, public`
    *   Uso: Rendimiento. Le dice al navegador "no me pidas esta imagen de nuevo por 1 hora".
3.  **`Set-Cookie`**: *"Guarda esto para la próxima"*.
    *   Ej: `Set-Cookie: session_id=new_id; Secure; HttpOnly`
    *   Uso: `HttpOnly` previene que JavaScript lea la cookie (protección XSS).
4.  **`Access-Control-Allow-Origin` (CORS)**: *"Quién puede usarme"*.
    *   Ej: `*` o `https://mi-app.com`
    *   Uso: Seguridad. Impide que un sitio malicioso haga peticiones AJAX a tu banco.

---

### Caso 1: Amazon.com - El Gigante Adaptable
La historia de Amazon es la historia de la web misma.

1.  **1995 (Web 1.0):** "Cadabra.com". Un catálogo estático de libros. Perl y Oracle. Sin fotos de portadas inicialmente. Pedidos lentos.
2.  **1998 (Web 1.5):** Introduce *"1-Click Buying"* (patentado). Uso de cookies agresivo para personalización. Introduce el sistema de afiliados (abriendo la plataforma).
3.  **2002 (Web 2.0 Precoz):** Lanza **Amazon Web Services (AWS)**. Amazon se da cuenta de que su infraestructura es más valiosa que su tienda. Expone su catálogo vía API XML.
4.  **2006:** Lanza S3 y EC2. Nace el Cloud Computing moderno.
5.  **2015 (Web 3.0):** Migración total a microservicios. La página principal de Amazon no es una página, es la composición de cientos de servicios (precio, stock, recomendaciones, anuncios) cargados asíncronamente.
6.  **2024 (Web 4.0):** Uso de IA generativa para resumir reseñas de usuarios. Logística anticipatoria (envían el producto cerca de tu casa antes de que lo compres basándose en predicciones).

### Caso 2: Netflix - De DVD a Streaming Global

1.  **1998 (El videoclub online):** Sitio Web 1.0 clásico. PHP/Java. Seleccionabas DVDs y te llegaban por correo postal. El negocio era logística física.
2.  **2007 (Streaming pionero):** Lanza "Watch Now". Usaba un plugin propietario de Microsoft (Silverlight) porque HTML no tenía DRM ni streaming adaptativo.
3.  **2013 (Microservicios y Big Data):**
    *   Arquitectura "Chaos Engineering": Matan servidores en producción a propósito (Chaos Monkey) para asegurar resiliencia.
    *   Personalización extrema: Tu portada de "Stranger Things" es diferente a la de tu vecino según tus gustos de colores y actores.
4.  **2015 (Globalización):** Migración total a la nube de AWS (cerraron sus últimos datacenters propios). Uso de CDN (Content Delivery Network) Open Connect propia.
5.  **Actualidad:** Pioneros en códecs de video abiertos (AV1) para ahorrar ancho de banda global. Su interfaz de TV es una SPA de alto rendimiento renderizada en dispositivos con pocos recursos.

---

## Glosario Técnico Extendido

*   **API Gateway:** Un servidor que actúa como punto de entrada único para un sistema de microservicios, encargándose del enrutamiento, autenticación y limitación de velocidad.
*   **CDN (Content Delivery Network):** Red de servidores distribuidos geográficamente que sirven contenido estático (fotos, videos) desde el nodo más cercano al usuario para reducir latencia.
*   **DNS (Domain Name System):** El directorio telefónico de internet. Traduce `google.com` a `142.250.189.46`.
*   **Framework:** Conjunto de código estandarizado y herramientas que provee una estructura base para desarrollar software (ej. React, Django, Angular). A diferencia de una librería, el framework "te llama a ti" (Inversión de Control).
*   **Isomórfico (Universal) JS:** JavaScript que puede ejecutarse tanto en el cliente (navegador) como en el servidor (Node.js), permitiendo compartir código y lógica.
*   **Latency (Latencia):** El tiempo que tarda un paquete de datos en viajar desde el origen al destino. En la web moderna, la latencia es más crítica que el ancho de banda.
*   **ORM (Object-Relational Mapping):** Técnica de programación para convertir datos entre sistemas de tipos incompatibles (Objetos en código vs Tablas en SQL).
*   **SSR (Server Side Rendering):** Generar el HTML completo de una página en el servidor antes de enviarlo, mejorando el SEO y la velocidad de carga inicial percibida.
*   **TLS/SSL (Transport Layer Security):** Protocolo criptográfico que proporciona comunicaciones seguras por una red. HTTPS es esencialmente HTTP sobre TLS.
*   **V8 Engine:** Motor de JavaScript de código abierto desarrollado por Google (escrito en C++). Es el corazón de Chrome y Node.js, responsable de que JS sea hoy un lenguaje de alto rendimiento.
*   **Service Worker:** Script que corre en segundo plano en el navegador, separado de la página web, clave para las PWAs (permite funcionamiento offline y notificaciones push).
*   **Reflow & Repaint:** Procesos costosos del navegador. *Reflow* calcula la posición de los elementos (geometría), *Repaint* los rellena de píxeles. Evitarlos es clave para el rendimiento.
*   **Zero-Day Exploit:** Vulnerabilidad de software desconocida para el fabricante, para la cual no existe parche ("día cero"), aprovechada por hackers.
*   **WebAssembly (Wasm):** Formato de instrucciones binarias para una máquina virtual basada en pila. Permite desplegar aplicaciones de alto rendimiento (C++, Rust) en la web.

---

## Historia de la Seguridad Web: De Texto Plano a Zero Trust

La seguridad no fue una prioridad inicial. Se asumía que la red era académica y confiable.

### La Era del Texto Plano (HTTP)
Hasta el 2010, era común loguearse en Facebook o Google usando HTTP.
*   **Riesgo:** Un hacker en la misma red Wi-Fi (Starbucks) podía usar "Firesheep" o Wireshark para leer tu contraseña o cookie de sesión volando en texto plano por el aire.
*   **Ataque Man-in-the-Middle (MITM):** Cualquiera en la ruta podía inyectar publicidad o malware en el HTML que recibías.

### El Ascenso de HTTPS y SSL
Netscape inventó SSL (Secure Sockets Layer) en 1994 para proteger tarjetas de crédito.
*   **Cifrado Asimétrico:** Clave Pública (candado) y Clave Privada (llave).
*   **Certificados:** Una "Autoridad Certificadora" (CA) como VeriSign confirma que `google.com` es realmente quien dice ser.
*   **De Pago a Gratis:** Antes los certificados costaban $100/año. En 2016, **Let's Encrypt** democratizó la seguridad ofreciendo certificados SSL gratuitos y automatizados. Hoy el 95% del tráfico web es cifrado.

### Vulnerabilidades Clásicas
1.  **SQL Injection (SQLi):**
    *   *Código Malo:* `query("SELECT * FROM users WHERE name = '" + input + "'");`
    *   *Ataque:* Input = `' OR '1'='1`. La query se vuelve verdadera siempre y devuelve toda la base de datos.
2.  **Cross-Site Scripting (XSS):**
    *   Permite inyectar JavaScript en la página de otro usuario para robar sus cookies.
    *   *Solución:* Escapar todos los outputs y usar cabeceras CSP (Content Security Policy).
3.  **CSRF (Cross-Site Request Forgery):**
    *   Obligar a tu navegador a hacer una acción (ej. transferir dinero) en un banco donde ya tienes sesión iniciada, usando una imagen oculta en otro sitio.

---

## Evolución de las Herramientas de Desarrollo (DevTools)

¿Cómo depuraban los ingenieros antes?

1.  **Era "View Source" (1995-2005):**
    No había debugger. Si algo fallaba, hacías clic derecho -> "Ver código fuente". Llenabas el código de `alert('Llegué aquí')` para saber qué pasaba.

2.  **Firebug (2006):**
    Un plugin para Firefox creado por Joe Hewitt. Fue una revolución.
    *   Permitía inspeccionar el DOM en vivo (no el código fuente estático).
    *   Ver peticiones de red AJAX.
    *   Modificar CSS en tiempo real.
    *   *Dato:* Las DevTools de Chrome se basaron en Firebug.

3.  **Chrome DevTools (2010-Actualidad):**
    Un IDE completo dentro del navegador.
    *   **Lighthouse:** Auditoría automática de rendimiento y SEO.
    *   **Performance:** Gráficos de llama (Flame charts) milisegundo a milisegundo.
    *   **Sensores:** Simular GPS, Acelerómetro y Red 3G.

---

## Ejercicios y Prácticas

### Ejercicio 1: Investigación Forense Web
Utilizando [archive.org](https://archive.org/web/):
1.  Visita `apple.com` en 1997, 2007 (lanzamiento iPhone) y 2024.
2.  **Reporte:** Crea una tabla comparativa analizando:
    *   **Navegación:** ¿Menús laterales vs Menús superiores vs Menú hamburguesa?
    *   **Imágenes:** ¿Uso de GIFs, JPGs de baja resolución o WebP de alta definición?
    *   **Diseño:** ¿Ancho fijo (640px/800px) vs Ancho fluido (Responsive)?

### Ejercicio 2: Análisis de Cabeceras HTTP
1.  Abre tu navegador (Chrome/Edge/Firefox).
2.  Presiona `F12` para abrir las **Developer Tools**.
3.  Ve a la pestaña **Network** (Red).
4.  Entra a `www.google.com`.
5.  Haz clic en la primera petición (el documento html).
6.  **Identifica:**
    *   `Request Method` (¿GET?)
    *   `Status Code` (¿200?)
    *   `Protocol` (¿h2 o h3?)
    *   Busca la cabecera `user-agent`. ¿Qué dice sobre tu navegador?

### Ejercicio 3: Laboratorio de Cabeceras con cURL
Vamos a usar la línea de comandos para ver la web "al desnudo", sin la interfaz gráfica.

**Instrucciones:**
1.  Abre tu terminal (CMD, PowerShell o Bash).
2.  Escribe el siguiente comando para ver las cabeceras de Google:
    `curl -I https://www.google.com`
3.  Analiza la salida. Deberías ver algo como:
    ```
    HTTP/2 200
    content-type: text/html; charset=ISO-8859-1
    server: gws
    x-xss-protection: 0
    ...
    ```
4.  **Reto:** Intenta hacer una petición fingiendo ser un iPhone.
    `curl -A "iPhone" -I https://www.google.com`
    ¿Cambia el `Content-Length`? ¿Por qué?

### Ejercicio 4: Debate - Centralización vs Descentralización
La Web 1.0 era descentralizada (cualquiera ponía un servidor). La Web 2.0 centralizó el tráfico en grandes plataformas (Facebook, Google, Amazon). La Web 3.0 promete descentralización (Blockchain).
*   **Discute:** ¿Es eficiente la descentralización para aplicaciones de alto rendimiento como YouTube? ¿Podría una red blockchain soportar el tráfico de video mundial? Argumenta técnicamente sobre latencia y almacenamiento.

---

## Impacto Socioeconómico y Cultural de la Web

La evolución tecnológica no ocurre en el vacío. Cada avance en la web ha reescrito las reglas de la sociedad moderna. Analicemos los cuatro pilares del impacto social.

### La Democratización del Conocimiento
Antes de la web, el conocimiento estaba encerrado en bibliotecas físicas y universidades de élite.
*   **Enciclopedias:** La *Britannica* costaba $1,500 USD y ocupaba una estantería. Hoy, **Wikipedia** es gratuita, se actualiza en segundos y tiene 60 millones de artículos.
*   **Educación:** Plataformas como Coursera, edX y YouTube han permitido que un estudiante en una aldea remota aprenda Inteligencia Artificial de profesores de Stanford.
*   **Periodismo Ciudadano:** Twitter (X) y los blogs permitieron que las noticias fluyeran en tiempo real desde los testigos, rompiendo el monopolio de las grandes cadenas de TV (ej. Primavera Árabe).

### La Economía Digital y el "Gig Economy"
La Web 2.0 permitió que cualquiera se convirtiera en micro-empresario.
*   **E-Commerce:** Amazon y Shopify permitieron tiendas globales sin local físico.
*   **Gig Economy:** Uber, Airbnb y Fiverr crearon mercados laborales líquidos. Ya no necesitas un contrato de 9 a 5; puedes vender tus servicios de diseño a un cliente en Japón mientras viajas.
*   **Criptoeconomía:** La Web3 introdujo el concepto de dinero programable y finanzas sin bancos (DeFi), aunque con alta volatilidad.

### Privacidad, Vigilancia y el "Capitalismo de Vigilancia"
No todo es positivo. El modelo de negocio de la Web 2.0 ("Si es gratis, tú eres el producto") ha traído consecuencias oscuras.
*   **Cambridge Analytica (2018):** Demostró cómo los datos de Facebook podían usarse para manipular elecciones democráticas con precisión quirúrgica (Micro-targeting).
*   **La Muerte del Anonimato:** Las cookies de terceros y el fingerprinting permiten a los anunciantes seguirte por toda la web. Saben qué compras, qué lees y dónde estás.
*   **GDPR y Regulaciones:** Europa respondió con el Reglamento General de Protección de Datos, obligando a las webs a pedir consentimiento (los famosos banners de cookies).

### La Brecha Digital
Mientras hablamos de Web 4.0, el 33% de la población mundial (2,600 millones de personas) nunca ha usado internet.
*   **Acceso:** En regiones rurales, la fibra óptica es inviable. Proyectos como **Starlink** (internet satelital) buscan cerrar esta brecha.
*   **Alfabetización Digital:** No basta con tener conexión. Saber distinguir una "Fake News" de una noticia real es la habilidad crítica del siglo XXI.

---

## Tendencias Futuras 2025-2030: Más allá de la Pantalla

Para cerrar este análisis evolutivo, debemos mirar hacia el horizonte inmediato. Los laboratorios de I+D ya están definiendo la "Web 5.0".

### Web 5.0 (La Visión de Jack Dorsey)
Un concepto híbrido propuesto por TBD (Block).
*   **Definición:** Web 2.0 + Web 3.0 = Web 5.0.
*   **Objetivo:** Identidad descentralizada (tú eres dueño de tus datos) pero con la experiencia de usuario fluida de las apps actuales.
*   **Ejemplo:** Tus playlists de música no viven en Spotify, viven en tu "Bóveda de Datos Personal". Cualquier app de música puede reproducirlas si le das permiso.

### La Web Cuántica
La computación cuántica amenaza con romper la criptografía actual (RSA/ECC) que protege HTTPS.
*   **El Peligro "Q-Day":** El día que una computadora cuántica pueda descifrar todo el tráfico web pasado y presente.
*   **Solución:** La **Criptografía Post-Cuántica (PQC)**. El NIST ya está estandarizando nuevos algoritmos (CRYSTALS-Kyber) que los navegadores deberán implementar antes de 2030.

### Interfaces Neuronales Directas (BCI)
Empresas como Neuralink y Synchron están trabajando en conectar el cerebro a la web sin teclados ni voces.
*   **Navegación Mental:** Imagina hacer scroll o clic solo con pensarlo.
*   **Accesibilidad Total:** Personas con parálisis completa podrán ser desarrolladores web o creadores de contenido usando solo su mente. La web será el gran igualador biológico.

---

## Conclusión de la Unidad
Hemos viajado desde los documentos estáticos de Berners-Lee hasta las interfaces mentales del futuro. La única constante en la web es el cambio. Como desarrollador, tu trabajo no es aprender un framework (que morirá en 5 años), sino entender los fundamentos que hemos visto aquí: Protocolos, Arquitectura y Estándares.

---
*Referencia: Programa AEB-1055 - Unidad 1 - TecNM*
*Fuentes: W3C History, MDN Web Docs, O'Reilly Media.*

<div align="center">

[Menú Unidad](README.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 1.2 Arquitectura](1.2.md) ➡️

</div>
