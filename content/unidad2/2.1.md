# 2.1 Introducci칩n al Lenguaje de Marcado

### 쯈u칠 es realmente "La Web"?
La Web e Internet no son lo mismo.
*   **Internet:** Es la carretera (cables y routers).
*   **La Web:** Son los coches y camiones que viajan por ella.

**Tim Berners-Lee (1989)** invent칩 los 3 pilares:
1.  **HTML:** El formato del documento.
2.  **URL:** La direcci칩n del documento.
3.  **HTTP:** El idioma para pedir el documento.

---

## La Genealog칤a del HTML: De SGML a HTML5

HTML no naci칩 de la nada. Tiene padres y abuelos.

### El Abuelo: SGML (Standard Generalized Markup Language)
En los 70s y 80s, los militares y el gobierno de USA necesitaban una forma de guardar documentos que durara 50 a침os.
*   **SGML** era un metalenguaje: Un lenguaje para crear lenguajes.
*   Era incre칤blemente complejo, estricto y pesado.
*   *Curiosidad:* HTML es un "hijo" (una aplicaci칩n) de SGML. Por eso hered칩 los corchetes angulares `< >`.

### Historia Resumida
*   **1991 (HTML 1):** Solo texto. Ni siquiera hab칤a im치genes.
*   **1997 (HTML 4):** El est치ndar por una d칠cada.
*   **2000 (XHTML):** Un intento fallido de hacer HTML estricto y aburrido. Si olvidabas cerrar una etiqueta, la p치gina no cargaba.
*   **2014 (HTML5):** La revoluci칩n. Video, Audio, Gr치ficos y Apps nativas en el navegador. Es lo que usamos hoy.

> **游눹 C칩digo en Acci칩n:**
> Copia este esqueleto. Es el m칤nimo requerido para que tu sitio funcione bien en celulares y Google.
>
> 游늯 **Ver c칩digo:** [01_esqueleto_html5.html](codigos/01_esqueleto_html5.html)

---

## XML (eXtensible Markup Language)

Aunque hoy JSON domina, XML sigue siendo el rey en la industria bancaria, gubernamental y empresarial (Enterprise).

### 쯈u칠 es?
XML no hace *nada*. Solo estructura datos.
A diferencia de HTML, donde `<h1>` significa "T칤tulo Gigante", en XML t칰 inventas las etiquetas.

```xml
<biblioteca>
    <libro id="101">
        <titulo>El Quijote</titulo>
        <autor nacionalidad="es">Cervantes</autor>
        <precio moneda="EUR">20.50</precio>
    </libro>
</biblioteca>
```

### Reglas de Oro (Well-Formed XML)
Para que un XML sea v치lido, debe cumplir reglas estrictas (a diferencia de HTML que aguanta todo):
1.  **Ra칤z 칔nica:** Todo debe estar envuelto en un solo elemento padre.
2.  **Cierre Obligatorio:** Toda etiqueta abierta `<foto>` debe cerrarse `</foto>` o auto-cerrarse `<foto />`.
3.  **Case Sensitive:** `<Libro>` y `<libro>` son cosas distintas.
4.  **Atributos:** Siempre entre comillas. `id="1"` (Bien), `id=1` (Mal).

### DTD y XSD (Validaci칩n)
쮺칩mo sabe un banco que el XML de la factura es correcto?
Usan esquemas (Schemas).
*   **DTD (Document Type Definition):** El formato viejo.
*   **XSD (XML Schema Definition):** Un archivo XML que describe "El campo precio debe ser un n칰mero decimal con 2 d칤gitos".

### XML vs HTML
| Caracter칤stica | HTML | XML |
| :--- | :--- | :--- |
| **Prop칩sito** | Mostrar datos (Presentaci칩n). | Transportar y guardar datos. |
| **Etiquetas** | Predefinidas (`p`, `div`). | Inventadas por ti (`paciente`, `factura`). |
| **Estricto** | No. El navegador intenta arreglar errores. | S칤. Si hay un error, se rompe (Draconian Error Handling). |
| **Estado** | Vivo (HTML Living Standard). | Maduro/Estable. |

---

## JSON vs XML: La Batalla Moderna

En 2005, AJAX usaba XML (la "X" de AJAX). Hoy usamos JSON. 쯇or qu칠?

### JSON (JavaScript Object Notation)
Naci칩 literalmente de la sintaxis de objetos de JS.

**El mismo libro en JSON:**
```json
{
  "biblioteca": {
    "libro": {
      "id": 101,
      "titulo": "El Quijote",
      "autor": {
        "nombre": "Cervantes",
        "nacionalidad": "es"
      },
      "precio": 20.50
    }
  }
}
```

### Comparativa: XML vs JSON
Hoy en d칤a usamos JSON para casi todo (APIs, Configuraci칩n) porque es m치s ligero y f치cil de leer para JavaScript.

| Caracter칤stica | XML | JSON |
| :--- | :--- | :--- |
| **Estilo** | Verboso (`<nombre>Juan</nombre>`). | Limpio (`"nombre": "Juan"`). |
| **Velocidad** | Lento de procesar. | Rapid칤simo (Nativo en JS). |
| **Uso** | Bancos, Facturas Electr칩nicas, SOAP. | Web Moderna, APIs REST, React. |

---

## La Web Sem치ntica (Web 3.0 Real)

Tim Berners-Lee so침aba con una "Web Sem치ntica" donde las m치quinas pudieran entender el significado de la informaci칩n, no solo mostrarla.

### El Problema
Para Google, `<p>Dr. House</p>` y `<p>House M.D.</p>` son solo texto. No sabe si hablas de una casa, un doctor o una serie.

### La Soluci칩n: Linked Data y RDF
Usando vocabularios est치ndar (como `schema.org`), podemos etiquetar el contenido.

```html
<!-- HTML Sem치ntico Microdata -->
<div itemscope itemtype="http://schema.org/TVSeries">
  <span itemprop="name">House M.D.</span>
  <span itemprop="genre">Medical Drama</span>
</div>
```
Ahora Google sabe *exactamente* qu칠 es. Esto alimenta los "Rich Snippets" en los resultados de b칰squeda (estrellitas, precios, horarios).

---

## Ingenier칤a del Navegador: Lo que pasa bajo el cap칩

Cuando escribes `index.html` y lo abres en Chrome, ocurre un proceso de ingenier칤a fascinante en milisegundos.

### El Motor de Renderizado (Browser Engine)
Cada navegador tiene un "coraz칩n" escrito en C++ que interpreta tu c칩digo.
*   **Blink (Google):** Usado por Chrome, Edge, Opera, Brave, Vivaldi. (Es un fork de WebKit).
*   **WebKit (Apple):** Usado por Safari (y todos los navegadores en iOS).
*   **Gecko (Mozilla):** Usado por Firefox. El 칰nico independiente que queda.

### C칩mo el navegador pinta tu web
1.  **HTML -> DOM:** Lee el c칩digo y crea el 치rbol de elementos.
    *   *Ojo:* Si encuentra un `<script>`, se detiene hasta descargarlo.
2.  **CSS -> CSSOM:** Lee los estilos.
3.  **Render Tree:** Combina DOM + CSSOM (solo lo visible).
4.  **Layout:** Calcula tama침os y posiciones.
5.  **Paint:** Colorea los p칤xeles.

---

## XML Avanzado: El Est치ndar Enterprise

Si trabajas en un Banco o Gobierno, topar치s con esto.

### Espacios de Nombres (Namespaces)
En XML, t칰 inventas etiquetas. 쯈u칠 pasa si tienes un XML que combina datos de dos empresas y ambas usan la etiqueta `<table>`? (Una para tablas de muebles, otra para tablas de datos).
**Soluci칩n:** `xmlns` (XML NameSpace).

```xml
<root xmlns:mueba="http://muebleria.com" xmlns:html="http://w3.org/html">
    <mueba:table>
        <mueba:material>Madera</mueba:material>
    </mueba:table>

    <html:table>
        <html:tr><html:td>Dato</html:td></html:tr>
    </html:table>
</root>
```

### XPath (XML Path Language)
Es como SQL, pero para XML. Sirve para buscar nodos espec칤ficos en 치rboles gigantes.
*   `/biblioteca/libro[1]`: El primer libro.
*   `//libro[@precio > 20]`: Todos los libros (no importa profundidad) que cuesten m치s de 20.
*   **Uso Actual:** Selenium (para testing autom치tico) usa XPath para encontrar botones en webs complejas.

### XSLT (Extensible Stylesheet Language Transformations)
Es un lenguaje para transformar un XML en... 춰otra cosa! (HTML, PDF, otro XML).
*   *Magia:* Puedes tener tus datos en XML y usar una hoja XSLT para generar tu sitio web autom치ticamente.
*   Fue muy popular en los 2000s, hoy reemplazado por JSON + Frontend Frameworks.

---

## Codificaci칩n de Caracteres: UTF-8 vs El Mundo

Si alguna vez has visto esto: `Garc츾?a`, lee esto con atenci칩n.

### ASCII (1963)
Solo 7 bits. 128 caracteres.
*   Incluye: A-Z, a-z, 0-9 y signos b치sicos.
*   No incluye: 칌, acentos, Kanji, Emojis.
*   Estados Unidos estaba feliz, el resto del mundo no.

### ISO-8859-1 (Latin-1)
8 bits. Agreg칩 caracteres de Europa Occidental (칌, 치, 칲).
*   Fue el est치ndar de la web primitiva.

### Unicode y UTF-8 (La Soluci칩n Final)
Unicode es una lista de TODOS los caracteres humanos (y Klingon y Emojis).
**UTF-8** es la forma de guardar esa lista en bytes de forma inteligente.
*   Si el caracter es A (ASCII), usa 1 byte.
*   Si es 칌, usa 2 bytes.
*   Si es 游눨, usa 4 bytes.
*   **Regla:** SIEMPRE usa `<meta charset="UTF-8">` al inicio de tu HTML.

---

## Standards Mode vs Quirks Mode

쯇or qu칠 ponemos `<!DOCTYPE html>` en la primera l칤nea?

### La Historia
En los 90s, las webs se hac칤an mal (sin est치ndares). Cuando los navegadores empezaron a respetar los est치ndares (CSS correcto), las webs viejas se romp칤an.

### La Soluci칩n del Navegador
El navegador decide c칩mo renderizar bas치ndose en el DOCTYPE.
*   **Quirks Mode (Modo Rarezas):** Si NO hay DOCTYPE, el navegador simula ser Internet Explorer 5.
    *   Modelo de caja incorrecto.
    *   CSS funciona raro.
    *   Es para compatibilidad con webs de 1999.
*   **Standards Mode (Modo Est치ndar):** Si ve `<!DOCTYPE html>`, usa el motor moderno HTML5.
    *   Todo funciona como esperas.

**Conclusi칩n:** Si olvidas el DOCTYPE, tu sitio se ver치 diferente en cada navegador.

---

## Conceptos Te칩ricos: Hipertexto vs Hipermedia

### Hipertexto
Texto lineal (libro) vs Texto conectado (Web).
El concepto revolucionario fue el **Hiperv칤nculo**: La capacidad de saltar de un contexto A a un contexto B instant치neamente. Esto imita c칩mo funciona el cerebro humano (asociaci칩n de ideas).

### Hipermedia
Es la evoluci칩n. Ya no solo conectamos texto.
Conectamos Audio, Video, Im치genes, Scripts, Datos en tiempo real.
La Web moderna es un motor de Hipermedia distribuido.

---

## Laboratorio de C칩digo: Manipulaci칩n del DOM y XML

Vamos a usar JavaScript puro (Vanilla JS) para entender c칩mo el navegador ve estos lenguajes.

### El DOM API (Document Object Model)
El HTML es texto. El DOM es memoria.
```javascript
// Crear un elemento desde cero (sin escribir HTML)
const nuevoDiv = document.createElement('div');
nuevoDiv.id = 'mi-caja';
nuevoDiv.style.border = '1px solid red';

// Crear texto
const texto = document.createTextNode('Hola Mundo desde JS');

// Unir piezas (Construir el 치rbol)
nuevoDiv.appendChild(texto);

// Inyectar en el documento real
document.body.appendChild(nuevoDiv);

console.log(nuevoDiv.outerHTML); 
// Output: <div id="mi-caja" style="border: 1px solid red;">Hola Mundo desde JS</div>
```

### Parseando XML con JavaScript
El navegador tiene un parser de XML incorporado (`DOMParser`).
```javascript
const xmlString = `
<biblioteca>
    <libro><titulo>1984</titulo></libro>
</biblioteca>
`;

const parser = new DOMParser();
const xmlDoc = parser.parseFromString(xmlString, "application/xml");

// Leer datos (Igual que HTML)
const titulo = xmlDoc.getElementsByTagName("titulo")[0].childNodes[0].nodeValue;

console.log(titulo); // "1984"
```

### El Error de XML (ParserError)
Si intentas parsear XML mal formado, el navegador no lo arregla (como en HTML). Te devuelve un documento de error.
```javascript
const xmlMalo = "<root><apertura>Sin cierre</root>";
const docError = parser.parseFromString(xmlMalo, "application/xml");

// El resultado es un documento XML que contiene informaci칩n del error
console.log(docError.getElementsByTagName("parsererror").length > 0); // true
```

---

## Deep Dive: Tipos MIME y Modos de Parsing

쮺칩mo sabe el navegador si le est치s enviando HTML, XML o una foto? No es por la extensi칩n del archivo. Es por el **Content-Type** (MIME Type).

### `text/html`
*   **Comportamiento:** El navegador usa el parser de HTML5.
*   **Tolerancia a fallos:** Infinita. Si olvidas cerrar un `</div>`, el navegador adivina d칩nde cerrarlo.
*   **Scripts:** Ejecuta `document.write()` (aunque no deber칤as usarlo).

### `application/xhtml+xml`
*   **Comportamiento:** El navegador usa el parser XML estricto.
*   **Tolerancia a fallos:** CERO. Si hay un error de sintaxis, muestra la "Pantalla Amarilla de la Muerte" (Yellow Screen of Death) y deja de renderizar todo el sitio.
*   **Historia:** Fue el sue침o de la Web 2.0 que fracas칩. Nadie quer칤a que su sitio dejara de verse por un error tipogr치fico.

### `application/xml` o `text/xml`
*   **Comportamiento:** Muestra el 치rbol de nodos con colores y permite colapsar/expandir ramas. No aplica CSS por defecto (a menos que uses `<?xml-stylesheet?>`).
*   **Uso:** Feeds RSS, Sitemaps, Configuraci칩n.

---

## Glosario T칠cnico de Lenguajes de Marcado

*   **Atributo:** Informaci칩n extra en la etiqueta de apertura (`width="500"`).
*   **CDATA (Character Data):** En XML, una secci칩n donde puedes escribir caracteres "prohibidos" (como `<` o `&`) sin que el parser intente interpretarlos. `<![CDATA[ if (a < b) ]]>`.
*   **Deprecado (Deprecated):** Una etiqueta u opci칩n que "funciona, pero no deber칤as usarla" porque ser치 eliminada en el futuro (ej. `<font>`, `<center>`, `<marquee>`).
*   **DOM (Document Object Model):** La representaci칩n en memoria (치rbol de objetos) del HTML parsedo. Es lo que manipula JavaScript.
*   **Elemento vs Etiqueta:**
    *   *Etiqueta:* `<p>` (la marca).
    *   *Elemento:* `<p>Hola</p>` (la marca + el contenido + la marca de cierre).
*   **Entidad HTML:** Un c칩digo para escribir caracteres reservados.
    *   `&lt;` (<) Less Than
    *   `&gt;` (>) Greater Than
    *   `&amp;` (&) Ampersand
    *   `&nbsp;` (Non-Breaking Space).
*   **Parser:** El programa que lee texto plano y lo convierte en una estructura de datos 칰til.
*   **Polyfill:** C칩digo (usualmente JS) que provee funcionalidad moderna en navegadores viejos.
*   **Sem치ntica:** El "significado" del c칩digo. Usar `<footer>` en lugar de `<div id="footer">` ayuda a m치quinas (Google) y humanos (ciegos) a entender qu칠 es.
*   **Void Element (Elemento Vac칤o):** Etiqueta que no tiene contenido ni cierre. Ej. `<br>`, `<img>`, `<input>`, `<meta>`.

---

## Ejercicios Pr치cticos

### Reto 1: "El Arque칩logo Digital"
Busca en el c칩digo fuente de una p치gina moderna (ej. Facebook o YouTube).
1.  Encuentra el `<!DOCTYPE html>`.
2.  Busca si usan atributos `data-` personalizados.
3.  Intenta encontrar alg칰n error de validaci칩n (etiqueta no cerrada) copiando el c칩digo en el [W3C Validator](https://validator.w3.org/). (Spoiler: Siempre hay errores, incluso en Google).

### Reto 2: "XML vs JSON Handshake"
Escribe un objeto JSON que describa tu perfil de estudiante (Nombre, Materias, Calificaciones).
Luego, traduce ese MISMO objeto a XML v치lido.
*   쮺u치l es m치s f치cil de leer para ti?
*   쮺u치l ocupa m치s caracteres?

### Reto 3: "Rompiendo el Parser"
Crea un archivo `.html`.
Escribe:
```html
<p>Hola <b>Mundo</p></b>
```
츼brelo en Chrome. 쮺칩mo lo arregl칩 el navegador? (Usa "Inspeccionar Elemento").
*   쯄ovi칩 el `</b>` antes del `</p>`?
*   쮺re칩 dos `<b>`?

---

## Referencias y Recursos

*   **Especificaci칩n Oficial HTML5:** [HTML Living Standard (WHATWG)](https://html.spec.whatwg.org/multipage/). (La 칰nica fuente de la verdad).
*   **MDN Web Docs (Mozilla):** La mejor documentaci칩n para desarrolladores.
*   **W3C Validator:** Herramienta para comprobar si tu HTML es v치lido.
*   **CanIUse.com:** Tablas de compatibilidad para saber si puedes usar una etiqueta nueva en navegadores viejos.

---

## Web Components: El Futuro del Marcado

쯇or qu칠 usar `<div class="slider">` cuando podr칤as usar `<mi-slider>`?
Los Web Components son la evoluci칩n final de HTML: la capacidad de crear tus propias etiquetas.

### Los 4 Jinetes de los Web Components
1.  **Custom Elements:** Definir `<mi-boton>`.
2.  **Shadow DOM:** Un DOM aislado dentro de tu componente. El CSS de afuera no le afecta. 춰Adi칩s a conflictos de nombres!
3.  **HTML Templates:** La etiqueta `<template>` que el navegador no renderiza hasta que t칰 se lo pides.
4.  **ES Modules:** Importar JS est치ndar.

### Ejemplo Real (Vanilla JS)
As칤 se crea una etiqueta nueva hoy en d칤a, sin frameworks.

```javascript
class MiBoton extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' }); // Crear Shadow DOM
    }

    connectedCallback() {
        // Cuando la etiqueta se pone en el HTML
        this.shadowRoot.innerHTML = `
            <style>
                button { background: purple; color: white; border: none; padding: 10px; }
            </style>
            <button>춰Soy un Web Component!</button>
        `;
    }
}

// Registrar la etiqueta
customElements.define('mi-boton', MiBoton);
```

Ahora puedes usar `<mi-boton></mi-boton>` en cualquier parte de tu HTML.

---

## La Arquitectura de Accesibilidad (A11y OM)

Pensamos que solo hay dos 치rboles: DOM y CSSOM. Existe un tercero: el **Accessibility Tree**.

### 쮺칩mo lee un ciego la web?
El "Screen Reader" (como VoiceOver o NVDA) NO lee el DOM. Lee el Accessibility Tree.
Este 치rbol es una versi칩n simplicada del DOM que solo contiene informaci칩n sem치ntica.
*   `div` -> Ignorado (Es solo decorativo).
*   `button` -> "Bot칩n, clickable".
*   `img` -> "Imagen: [texto alt]".

### WAI-ARIA (Web Accessibility Initiative - Accessible Rich Internet Applications)
A veces el HTML no alcanza. Si creas un div que act칰a como bot칩n:
```html
<!-- Malo: El ciego no sabe que es un bot칩n -->
<div onclick="guardar()">Guardar</div>

<!-- Bueno: ARIA le dice al ciego "Esto es un bot칩n" -->
<div role="button" aria-pressed="false" tabindex="0" onclick="guardar()">Guardar</div>
```
**Regla de Oro:** La mejor ARIA es no usar ARIA. Usa `<button>` nativo siempre que puedas.

---

## SVG (Scalable Vector Graphics): XML Gr치fico

Mucha gente olvida que SVG **ES** XML.
Puedes abrir un archivo `.svg` con el Bloc de Notas y leerlo.

### Anatom칤a de un SVG
```xml
<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg">
  <circle cx="50" cy="50" r="40" stroke="green" stroke-width="4" fill="yellow" />
</svg>
```
*   Es vectorial (matem치tico). No se pixela si haces zoom.
*   Es parte del DOM. Puedes cambiar el color del c칤rculo con CSS: `circle:hover { fill: red; }`.

### SVG vs Canvas
*   **SVG (Modo Retenido):** El navegador recuerda los objetos (c칤rculo, cuadrado). Si mueves el c칤rculo, el navegador lo repinta solo. Ideal para logos, iconos, gr치ficos simples.
*   **Canvas (Modo Inmediato):** Es un lienzo de p칤xeles tontos. Tu c칩digo JS dibuja. El navegador olvida qu칠 dibuj칩. Ideal para juegos, 60 FPS, part칤culas.

---

## Referencias Hist칩ricas y T칠cnicas (RFCs)

Si te tomas esto en serio, lee las fuentes primarias:

*   **RFC 1866 (HTML 2.0):** El primer est치ndar oficial (1995).
*   **RFC 8259 (JSON):** "The JavaScript Object Notation (JSON) Data Interchange Format".
*   **The XML 1.0 Specification (W3C):** Duro de leer, pero necesario para expertos.
*   **"Weaving the Web" (Libro):** La autobiograf칤a de Tim Berners-Lee.

---

## Optimizaci칩n: Minificaci칩n y Compresi칩n

Tu c칩digo HTML legible para humanos es ineficiente para m치quinas.

### Minificaci칩n
El proceso de remover espacios en blanco, saltos de l칤nea y comentarios.
*   *Original (45 bytes):*
    ```html
    <div class="box">
        <p> Hola </p>
    </div>
    ```
*   *Minificado (32 bytes):*
    ```html
    <div class="box"><p>Hola</p></div>
    ```
*   **Herramientas:** HTMLMinifier, plugins de Webpack/Vite.

### Compresi칩n (Gzip vs Brotli)
Antes de enviar el archivo por el cable, el servidor lo comprime.
*   **Gzip:** El est치ndar cl치sico (Algoritmo DEFLATE). Reduce el tama침o ~70%.
*   **Brotli (Google):** El est치ndar moderno. Reduce ~20% m치s que Gzip.
*   **Nota:** Si ves caracteres raros en la respuesta de red, es que el navegador no descomprimi칩 bien (o el servidor minti칩 en el header).

---

## Preguntas Frecuentes (FAQ) de Entrevista Senior

**1. 쮺u치l es la diferencia real entre `<b>` y `<strong>`?**
*   `<b>` (Bold): Es puramente visual. "Pon esto en negrita".
*   `<strong>` (Strong Importance): Es sem치ntico. "Esto es importante". Los lectores de pantalla cambian el tono de voz.
*   *Respuesta:* Usa siempre `<strong>` a menos que sea algo decorativo.

**2. 쯇uedo poner un `<div>` dentro de un `<span>`?**
*   En HTML4: **ILEGAL**. Elementos de bloque no pueden ir dentro de elementos en l칤nea.
*   En HTML5: T칠cnicamente el navegador lo permite, pero es mala pr치ctica y confunde al parser. Cambia el `<span>` por un `<div>` con `display: inline-block`.

**3. 쯈u칠 hacen los atributos `data-*`?**
*   Permiten guardar datos privados en el HTML para que JS los lea.
*   Ejemplo: `<div data-user-id="123" data-role="admin">`.
*   JS: `element.dataset.userId`.

**4. 쯇or qu칠 `window.onload` es diferente a `DOMContentLoaded`?**
*   `DOMContentLoaded`: Se dispara cuando el HTML y el DOM est치n listos (pero faltan im치genes).
*   `window.onload`: Se dispara cuando TODO (im치genes, iframes, estilos) termin칩 de cargar. (Mucho m치s lento).

---

## Historia de los Est치ndares: La Guerra de los Navegadores

쯇or qu칠 HTML5 es "vivo"?

### W3C vs WHATWG
*   **1999-2004:** La W3C se obsesion칩 con XHTML (HTML estricto como XML). Era un desastre.
*   **2004:** Apple, Mozilla y Opera dijeron "No". Fundaron el **WHATWG**.
*   **2007:** WHATWG propuso HTML5 (pragm치tico, tolerante a errores).
*   **2019:** La W3C se rindi칩. HTML5 es ahora el **"HTML Living Standard"**. Ya no hay versiones (HTML6 no existir치), es una actualizaci칩n cont칤nua.

### El proceso de un Est치ndar
1.  **Explainer:** Alguien dice "Necesitamos `<dialog>`".
2.  **Draft:** Se escribe la especificaci칩n t칠cnica.
3.  **Implementation:** Chrome y Firefox lo construyen detr치s de una "flag".
4.  **Ship:** Cuando 2 navegadores lo tienen estable, es oficial.

---

## C칩mo funciona el Parser HTML

Cuando Chrome lee tu c칩digo:
1.  **Tokenizaci칩n:** Convierte el texto `<p>` en un objeto "StartTag: p".
2.  **Construcci칩n del 츼rbol:** Crea el nodo `HTMLParagraphElement`.
3.  **Script Execution:** Si ve un `<script>`, PAUSA todo (a menos que uses `defer`).
4.  **Error Handling (La magia):**
    *   Si escribes `<p>Hola <div>Mundo</div></p>`, es ilegal (`div` dentro de `p`).
    *   El parser no explota. Lo reescribe silenciosamente a:
    *   `<p>Hola</p> <div>Mundo</div>`. (Cierra el p autom치ticamente).
    *   **Lecci칩n:** No conf칤es en que el navegador arregle tu c칩digo. Val칤dalo.

---

---

## El Tooling del Desarrollador Profesional

No escribas HTML en Notepad.

### VS Code Extensions (Esenciales)
1.  **Live Server:** Recarga tu p치gina autom치ticamente al guardar.
2.  **Prettier - Code Formatter:** Indenta tu c칩digo autom치ticamente al guardar.
3.  **Auto Rename Tag:** Si cambias `<h1>` por `<h2>`, te cambia el cierre autom치ticamente.

### Emmet Cheatsheet
Escribe r치pido:
*   `ul>li*5` -> Crea una lista con 5 elementos.
*   `.container>h1.title+p.text` -> Crea un div con clase container, adentro un h1 con clase title y un p con clase text.
*   `! + Tab` -> Crea la estructura b치sica HTML5 (`<html>`, `<head>`, `<body>`).

---

<div align="center">

[Siguiente: 2.2 Estructura Global](2.2.md) 俱뫮잺

</div>
