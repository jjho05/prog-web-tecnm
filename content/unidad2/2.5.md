# 2.5 Lenguajes de Presentaci√≥n: El Arte de CSS

### La regla de oro
*   **HTML:** Estructura (Esqueleto).
*   **CSS:** Estilo (Ropa y Maquillaje).
*   **JS:** Comportamiento (M√∫sculos y Movimiento).
Nunca mezcles estilos dentro del HTML (`<div style="...">`). Usa siempre un archivo `.css` separado.

---

## Historia: De las Guerras a la Estandarizaci√≥n

### CSS1 (1996)
H√•kon Wium Lie propuso CSS en 1994. Se estandariz√≥ en el 96.
*   Era muy b√°sico: fuentes, colores, m√°rgenes.
*   Navegadores como Netscape 4 lo implementaban fatal (a veces crasheaban).

### CSS2 y 2.1 (1998-2011)
La era oscura.
*   Introdujo el posicionamiento (`absolute`, `relative`) y `z-index`.
*   **Problema:** No hab√≠a formas de hacer layouts. Us√°bamos tablas (`<table>`) o `float`.
*   `float: left;` fue un hack para poner im√°genes al lado de texto, pero lo usamos para construir sitios enteros. Fue horrible.

### CSS3 (2011 - La Revoluci√≥n)
HTML5 trajo CSS3.
*   **Modularidad:** CSS3 no es una sola especificaci√≥n. Son m√≥dulos separados (Color, Flexbox, Grid, Backgrounds).
*   **Novedades:** Bordes redondeados (`border-radius`), Sombras (`box-shadow`), Degradados, Animaciones (`@keyframes`).
*   **Adi√≥s a las im√°genes de fondo:** Antes, para hacer un bot√≥n redondo, necesitabas 3 im√°genes en Photoshop. Ahora es una l√≠nea de c√≥digo.

### CSS4 (¬øExiste?)
T√©cnicamente no hay "CSS4".
Como CSS3 se dividi√≥ en m√≥dulos, ahora cada m√≥dulo tiene su nivel.
*   CSS Grid Layout Level 2.
*   CSS Color Module Level 5.
*   La gente le dice "CSS Moderno".

---

## Sintaxis y Anatom√≠a de una Regla

### Sintaxis
```css
selector {
    propiedad: valor;
}

/* Ejemplo: Pon todos los t√≠tulos en rojo */
h1 {
    color: red;
}
```

### Unidades de Medida
*   **`px` (P√≠xel):** Fijo. Bueno para bordes.
*   **`rem`:** Flexible. Se adapta al tama√±o de fuente del usuario. √ösalo para textos y m√°rgenes.
*   **`%`:** Relativo al contenedor padre.
*   **`vh/vw`:** Relativo al tama√±o de la pantalla.

---

### La Cascada
CSS significa **Hojas de Estilo en Cascada**.
Si hay reglas que compiten, gana la que sea m√°s espec√≠fica o la que est√© m√°s abajo en el archivo.
1.  `!important` (Ev√≠talo).
2.  Estilos en l√≠nea (HTML).
3.  IDs.
4.  Clases.
5.  Etiquetas.

---

### Reset vs Normalize
*   **Reset:** Borra TODOS los estilos por defecto (hace que los h1 se vean igual que los p).
*   **Normalize:** Hace que todos los navegadores se vean igual, pero mantiene estilos √∫tiles (los h1 siguen siendo grandes). **Usa este.**

### Arquitecturas CSS
*   **BEM:** Escribir clases como `.tarjeta__titulo`. √ötil para equipos grandes.
*   **Tailwind:** Escribir clases directas en el HTML como `class="text-red-500 p-4"`. R√°pido y moderno.

---

## El Problema del Scope Global

En C++ o Java, las variables son privadas por defecto. En CSS, todo es p√∫blico globalmente.
Si creas una clase `.btn` en un archivo `header.css`, afectar√° al bot√≥n del footer tambi√©n. Eso causa "Naming Collisions".

### Soluciones Modernas

#### CSS Modules
Usado en React/Next.js/Vite.
Escribes `.title { color: red; }` en `Button.module.css`.
El compilador lo transforma a `.Button_title__a8s7d`.
*   **Ventaja:** Scope local autom√°tico. Nunca m√°s colisiones de nombres.

#### Shadow DOM (Web Components)
El verdadero aislamiento. Los estilos dentro de un Shadow Root no salen, y los de fuera no entran.
Es como un `<iframe>` ligero.

---

## CSS-in-JS: La Fusi√≥n Controversial

Herramientas como **Styled Components** o **Emotion** permiten escribir CSS dentro de archivos JavaScript (`.jsx` o `.tsx`).

```javascript
/* React */
const Boton = styled.button`
  background: ${props => props.primary ? "blue" : "gray"};
  color: white;
  padding: 10px;
`;
```

### Ventajas
*   **L√≥gica Real:** Puedes usar `if/else`, props, funciones dentro de tu CSS.
*   **Eliminaci√≥n de C√≥digo Muerto:** Si borras el componente JS, se borra su CSS autom√°ticamente.
*   **Dynamic Theming:** Cambiar el tema de la app en tiempo real es trivial.

### Desventajas
*   **Performance:** El navegador tiene que parsear el JS, ejecutarlo, generar el CSS, e inyectarlo en el DOM (`<style>`). Es m√°s lento que descargar un `.css` est√°tico.
*   **Runtime:** Aumenta el tama√±o del bundle de JS.

---

## Pipeline de Renderizado: ¬øC√≥mo pinta el navegador?

Entender esto distingue a un Junior de un Senior.
Cuando el navegador recibe el HTML y el CSS, sigue estos pasos (Critical Rendering Path):

1.  **Parse HTML -> DOM Tree:** Crea el √°rbol de contenido.
2.  **Parse CSS -> CSSOM Tree:** Crea el √°rbol de estilos (incluyendo user agent styles).
3.  **Combine -> Render Tree:** Une DOM + CSSOM. **OJO:** Solo incluye lo que es visible (`display: none` desaparece aqu√≠).
4.  **Layout (Reflow):** Calcula la geometr√≠a. "¬øCu√°nto mide este div en p√≠xeles exactos? ¬øD√≥nde va posicionado?".
    *   *Costoso:* Si cambias `width`, `font-size`, `margin`, obligas a recalcular TODO el layout.
5.  **Paint:** Rellena los p√≠xeles (color, fondo, sombras).
6.  **Composite:** Compone las capas (como Photoshop). Si usas `transform` o `opacity`, el navegador promovere el elemento a su propia capa (GPU) y es muy r√°pido.

**Tip de Performance:**
*   Cambiar `left: 10px` activa Layout + Paint + Composite (Lento).
*   Cambiar `transform: translateX(10px)` activa solo Composite (R√°pido, animaciones fluidas 60fps).

---

## CSS Custom Properties (Variables Nativas)

Tienen dos ventajas asesinas sobre las variables de Sass: **Scope** y **Reactividad**.

### Definici√≥n y Uso
```css
:root {
    --color-main: #3498db;
    --gap: 16px;
}

.card {
    color: var(--color-main);
    padding: var(--gap);
}
```

### La Magia del Scope
Puedes redefinir variables localmente.
```css
.dark-mode {
    --color-main: #ecf0f1; /* En modo oscuro, el azul se vuelve blanco */
}
```
JS puede leer y escribir estas variables en tiempo real:
`element.style.setProperty('--mouse-x', event.clientX + 'px');`

---

## At-Rules Modernas y el Futuro

### `@supports` (Feature Queries)
"Si el navegador soporta Grid, usa Grid. Si no, usa Float".
```css
@supports (display: grid) {
    .container { display: grid; }
}
```

### `@layer` (Cascade Layers) - CSS 2022
Arregla el problema de la especificidad y el orden de importaci√≥n.
Puedes definir capas de prioridad explicita.

```css
@layer reset, framework, mis-estilos;

/* No importa que esto est√© arriba o tenga menos selectores */
@layer mis-estilos {
    h1 { color: red; } 
}
```

### Container Queries (`@container`)
El santo grial. Media queries que dependen del tama√±o del **contenedor**, no de la pantalla.
```css
.card {
    container-type: inline-size;
}

@container (min-width: 400px) {
    .card h2 { font-size: 2rem; }
}
```

---

## Glosario de Presentaci√≥n

*   **CSSOM:** CSS Object Model. El mapa mental de estilos del navegador.
*   **FOUC:** Flash of Unstyled Content. Cuando el HTML carga antes que el CSS y ves la p√°gina "desnuda" por un milisegundo.
*   **Critical CSS:** T√©cnica de inyectar el CSS de la primera pantalla (Above the fold) inline en el HTML para evitar FOUC y acelerar la carga.
*   **Vendor Prefix:** `-webkit-`, `-moz-`. Experimentales. Hoy (2025) casi no se usan gracias a Autoprefixer.
*   **Specificity Wars:** Cuando empiezas a usar `!important` para sobreescribir otro `!important`. S√≠ntoma de mal c√≥digo.

---

## Laboratorio Mental de Arquitectura

Imagina que est√°s en 2012. Tienes un sitio con 10,000 l√≠neas de CSS en un solo archivo `style.css`.
El equipo crece a 20 desarrolladores.
Todos a√±aden estilos al final del archivo.
Nadie se atreve a borrar nada "por si rompe algo".
**Resultado:** CSS Append-Only. El archivo crece y crece. El sitio se vuelve lento.

**Tu tarea mental:** ¬øC√≥mo lo solucionar√≠as con lo que aprendimos hoy?
1.  ¬øUsar√≠as BEM para evitar colisiones?
2.  ¬øMigrar√≠as a CSS Modules?
3.  ¬øImplementar√≠as un Design System con Custom Properties?

---

## Arquitecturas CSS a Fondo

M√°s all√° de BEM, ¬øc√≥mo organizas 50 archivos CSS?

### OOCSS (Object Oriented CSS)
Idea de Nicole Sullivan (2009). Separar contenedor y contenido.
*   **Mal:** `.sidebar-title` (Acoplado a la sidebar).
*   **Bien:** `.title` (Reusable). `.skin-blue` (Separado de la estructura).

### SMACSS (Scalable and Modular Architecture for CSS)
Categorizaci√≥n en 5 tipos:
1.  **Base:** Resets, selectores de etiqueta (`body`, `h1`).
2.  **Layout:** Estructura mayor (`#header`, `#footer`).
3.  **Module:** Componentes reusables (`.card`, `.btn`).
4.  **State:** Estados (`.is-active`, `.is-hidden`).
5.  **Theme:** Visuales (`.theme-dark`).

### ITCSS (Inverted Triangle CSS)
La arquitectura m√°s escalable hoy (usada por Tailwind).
Imagina un tri√°ngulo invertido donde la especificidad fluye de arriba a abajo:
1.  **Settings:** Variables Sass, Configuraci√≥n. (Sin salida CSS).
2.  **Tools:** Mixins, Funciones. (Sin salida CSS).
3.  **Generic:** Resets, Normalize.
4.  **Elements:** Etiquetas HTML sin clases (`h1`, `a`).
5.  **Objects:** Layouts sin dise√±o visual (`.container`, `.grid`).
6.  **Components:** UI con dise√±o (`.btn`, `.card`).
7.  **Trumps (Utilities):** `!important`, helpers (`.text-center`).

---

## Preprocesadores: Sass Nivel Dios

No te quedes solo en variables y anidaci√≥n.

### Mixins con Argumentos
Como funciones en JS.
```scss
@mixin flex-center($direction: row) {
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: $direction;
}

.hero {
    @include flex-center(column);
}
```

### Mapas y Bucles (`@each`)
Para generar clases din√°micas.
```scss
$colors: (
    primary: blue,
    danger: red,
    success: green
);

@each $name, $value in $colors {
    .btn-#{$name} {
        background-color: $value;
        border: 1px solid darken($value, 10%);
    }
}
/* Genera: .btn-primary, .btn-danger, .btn-success */
```

### `&` (Padre Selector)
```scss
.btn {
    &:hover { opacity: 0.8; }
    &__icon { margin-right: 5px; }
    .dark-mode & { color: white; } /* Inversi√≥n de contexto */
}
```

---

## Frameworks CSS: La Batalla

### Bootstrap (Component-Based)
*   **Filosof√≠a:** "Te damos los componentes listos".
*   **Pros:** Prototipado ultrarr√°pido. Accesibilidad decente por defecto.
*   **Contras:** Todos los sitios se ven iguales ("Bootstrap look"). Dif√≠cil de personalizar a fondo (tienes que pelear con `!important`).
*   **Uso:** `.btn .btn-primary`.

### Tailwind CSS (Utility-First)
*   **Filosof√≠a:** "Te damos piezas de Lego at√≥micas".
*   **Pros:** Libertad total de dise√±o. Archivo CSS final min√∫sculo (con PurgeCSS). No inventas nombres de clases.
*   **Contras:** HTML sucio (`class="text-lg font-bold p-4 bg-blue-500 hover:bg-blue-600 rounded shadow"`). Curva de aprendizaje inicial.
*   **Veredicto:** El est√°ndar moderno para apps personalizadas.

### Bulma / Pico.css (Classless / Minimal)
*   **Uso:** Proyectos peque√±os o documentos.
*   En Pico.css, solo escribes HTML sem√°ntico (`<button>`) y ya se ve bien. Sin clases.

---

---

## PostCSS y el Tooling Moderno

CSS ya no se escribe a mano y se sube. Se "transpila", igual que JS.
PostCSS es una herramienta que toma tu CSS y le pasa plugins JS.

### Plugins Esenciales
1.  **Autoprefixer:** A√±ade los prefijos de navegador (`-webkit-`, `-moz-`) autom√°ticamente usando datos de CanIUse.
    *   *T√∫ escribes:* `display: flex;`
    *   *√âl genera:* `display: -webkit-box; display: -ms-flexbox; display: flex;`
2.  **cssnano:** Minifica el CSS (quita espacios, acorta colores `#ffffff` -> `#fff`).
3.  **PurgeCSS:** Analiza tus archivos `.html` y `.js`, ve qu√© clases NO est√°s usando, y las borra del CSS final. (Vital para Tailwind).

---

## CSS en el JS: La Guerra Civil

Hay dos bandos claros en la comunidad.

### Styled Components (Runtime)
*   **Sintaxis:** Template literals.
*   **Pros:** Pasas props de React directo al estilo. `color: ${props => props.color}`.
*   **Contras:** Lento. JS tiene que calcular los estilos en el navegador cliente.

### Zero-Runtime (Vanilla Extract / Panda CSS)
*   **La nueva ola (2024):** Escribes en JS/TS (con tipos), pero **durante el build** se extrae a un archivo `.css` est√°tico real.
*   **Ventaja:** Developer Experience (DX) de TS, pero Performance de CSS puro.

---

## El Futuro: CSS Houdini
Es un conjunto de APIs de bajo nivel que exponen el motor de renderizado del navegador.
Permite crear **nuevas propiedades CSS** con JS.
*   *Ejemplo:* `background: paint(mi-patron-loco);`. (Dibuja un patr√≥n con Canvas API pero usado como fondo CSS).
*   *Estado:* Soporte parcial, pero es el futuro de las animaciones complejas.

---

## Accesibilidad Visual (A11y)

No es solo para ciegos. Es para todos.

### Prefers-Reduced-Motion
Hay gente que se marea con animaciones parallax o transiciones r√°pidas (Desorden Vestibular).
Resp√©talos:
```css
@media (prefers-reduced-motion: reduce) {
    * {
        animation-duration: 0.01ms !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
    }
}
```

### Contraste de Color
El texto gris claro sobre fondo blanco se ve "moderno" pero es ilegible.
*   **Ratio m√≠nimo (WCAG AA):** 4.5:1 para texto normal.
*   *Herramienta:* Usa la pesta√±a "Rendering" en Chrome DevTools para emular daltonismo.

### Modo Alto Contraste
Windows tiene un modo "High Contrast".
Detectarlo:
```css
@media (forced-colors: active) {
    .btn {
        border: 2px solid currentColor; /* Borde expl√≠cito para cuando no hay fondo */
    }
}
```

---

---

## Proyecto Final: Switcher de Temas (Dark/Light)

Vamos a aplicar variables nativas y JS para crear un sitio con temas din√°micos.

### CSS (La L√≥gica)
```css
:root {
    /* Tema Claro (Default) */
    --bg-color: #ffffff;
    --text-color: #333333;
    --primary: #007bff;
}

[data-theme="dark"] {
    /* Tema Oscuro */
    --bg-color: #1a1a1a;
    --text-color: #f0f0f0;
    --primary: #66b2ff;
}

/* Aplicaci√≥n global */
body {
    background-color: var(--bg-color);
    color: var(--text-color);
    transition: background-color 0.3s, color 0.3s;
}

/* El bot√≥n flotante */
.theme-toggle {
    position: fixed;
    bottom: 20px;
    right: 20px;
    padding: 10px 20px;
    border-radius: 50px;
    background: var(--primary);
    color: white;
    border: none;
    cursor: pointer;
    box-shadow: 0 4px 12px rgba(0,0,0,0.2);
}
```

### JavaScript (El Cerebro)
```javascript
const btn = document.querySelector('.theme-toggle');
const root = document.documentElement; // <html>

// 1. Cargar preferencia guardada
const savedTheme = localStorage.getItem('theme') || 'light';
root.setAttribute('data-theme', savedTheme);

btn.addEventListener('click', () => {
    // 2. Leer estado actual
    const currentTheme = root.getAttribute('data-theme');
    const newTheme = currentTheme === 'light' ? 'dark' : 'light';
    
    // 3. Aplicar y Guardar
    root.setAttribute('data-theme', newTheme);
    localStorage.setItem('theme', newTheme);
    
    // 4. Feedback
    btn.textContent = newTheme === 'light' ? 'üåô Modo Oscuro' : '‚òÄÔ∏è Modo Claro';
});
```

---

## Flexbox vs Grid: La Gu√≠a Definitiva

¬øCu√°ndo uso qu√©?

| Caracter√≠stica | Flexbox | CSS Grid |
| :--- | :--- | :--- |
| **Dimensi√≥n** | 1D (Fila O Columna) | 2D (Filas Y Columnas a la vez) |
| **Enfoque** | Content-First (Deja que el contenido decida el tama√±o) | Layout-First (Define el tama√±o y mete el contenido ah√≠) |
| **Alineaci√≥n** | Excelente para centrar cosas peque√±as. | Excelente para layouts de p√°gina completa. |
| **Superpoder** | `flex-wrap: wrap` (Galer√≠as simples). | `grid-template-areas` (Layouts sem√°nticos). |
| **Uso Ideal** | Men√∫s, Barras de navegaci√≥n, Listas de tarjetas. | Layout general (Header, Sidebar, Main, Footer), Galer√≠as complejas (Mosaicos). |

**Regla de Oro:**
Usa Grid para la **estructura macro** de la p√°gina.
Usa Flexbox para los **componentes micro** (botones, items de men√∫) dentro de esas celdas del Grid.

---

## Glosario de Arquitecturas

*   **Atomic CSS:** Usar una clase por propiedad (`.m-1`, `.p-2`, `.text-red`). (Tailwind).
*   **BEM:** Block Element Modifier. Convenci√≥n de nombres (`.block__element--modifier`).
*   **Component-Driven:** Pensar la UI como componentes aislados (`.card`, `.btn`) en lugar de p√°ginas.
*   **Design Tokens:** Variables que guardan le decisiones de dise√±o (colores, espacios, tipograf√≠a).
*   **Scoped CSS:** Estilos que solo aplican a un componente espec√≠fico (sin colisiones globales).

---

---

## Arquitectura Sass: El Patr√≥n 7-1

Cuando tu CSS crece, necesitas orden. El est√°ndar de la industria para Sass es el patr√≥n 7-1.
7 Carpetas, 1 Archivo `main.scss`.

### Estructura de Carpetas
1.  **`abstracts/`**: Variables, Mixins, Funciones. (No genera CSS).
2.  **`vendors/`**: Bootstrap, jQuery UI, css de terceros.
3.  **`base/`**: Reset, Tipograf√≠a b√°sica, estilos de `<body>`.
4.  **`layout/`**: Header, Footer, Grid, Sidebar.
5.  **`components/`**: Botones, Tarjetas, Modales, Formularios.
6.  **`pages/`**: Estilos espec√≠ficos de "Home", "Contacto".
7.  **`themes/`**: Tema Dark, Tema Admin.

### El Archivo `main.scss`
```scss
@import 'abstracts/variables';
@import 'abstracts/mixins';
@import 'vendors/bootstrap';
@import 'base/reset';
@import 'base/typography';
@import 'layout/header';
@import 'components/buttons';
@import 'pages/home';
```
Este es el √∫nico archivo que compilas.

---

## CSS Nesting Nativo (2024+)

Ya no necesitas Sass para anidar. Los navegadores modernos lo soportan nativamente.

**Sintaxis (Casi igual a Sass):**
```css
.card {
    background: white;
    
    /* Nesting directo */
    & .card-title {
        color: black;
    }
    
    /* Pseudo-clases */
    &:hover {
        background: gray;
    }
    
    /* Media Queries anidadas (¬°Genial!) */
    @media (max-width: 500px) {
        display: none;
    }
}
```
**Diferencia:** En Sass el `&` a veces se usa para concatenar strings (`&__element` -> `.card__element`). En CSS Nativo eso NO funciona. Solo funciona para selectores completos.

---

<div align="center">

[‚¨ÖÔ∏è Anterior: 2.4 Formularios](2.4.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 2.6 Selectores](2.6.md) ‚û°Ô∏è

</div>
