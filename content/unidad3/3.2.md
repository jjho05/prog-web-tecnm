# 3.2 Manejo de Frameworks y Librerías

Escribir JavaScript "Vanilla" (puro) es excelente para aprender, pero en aplicaciones empresariales grandes se vuelve insostenible. Aquí entran los Frameworks.

---

### ¿Por qué usarlos?
Imagina actualizar manualmente 50 lugares de tu web cada vez que el usuario cambia su nombre.
*   **Vanilla JS:** Imperativo ("Busca el div, cambia el texto"). Manual y propenso a errores.
*   **Framework:** Declarativo ("Si cambia la variable `nombre`, actualízate solo"). Reactivo y automático.

### Evolución Rápida
*   **jQuery (2006):** Hizo fácil seleccionar elementos (`$('.btn')`), pero seguía siendo manual.
*   **AngularJS (2010):** Trajo el patrón MVC, pero era lento.
*   **React (2013):** Introdujo los **Componentes**. Todo es un bloque reutilizable (Header, Botón, Footer).
*   **Hoy:** Frameworks modernos (Vue 3, Svelte, Solid) son extremadamente rápidos y ligeros.

---

### Los 3 Gigantes
1.  **React (Meta):** El más popular. Es una **Librería** (solo maneja la vista). Tú eliges el router, estilos, etc. Usa JSX.
2.  **Angular (Google):** El Framework Enterprise. Es "Todo incluido" (Router, HTTP, Estructura rígida). Usa TypeScript obligatorio.
3.  **Vue.js (Comunidad):** El punto medio. Fácil de aprender, flexible y potente.
4.  **Svelte/Solid:** La nueva ola. No usan Virtual DOM, son compiladores ultra rápidos.

---

---

## Virtual DOM vs Signals (La Guerra Técnica)

¿Cómo saben los frameworks qué parte de la pantalla actualizar?

### Virtual DOM (React, Vue 2)
1.  **Copia:** El framework mantiene una copia ligera del DOM en memoria (Objeto JS gigante).
2.  **Diffing:** Cuando cambia un dato (`state`), crea *otra* copia nueva.
3.  **Comparación:** Compara la copia vieja con la nueva para ver qué cambió.
4.  **Patch:** Actualiza SOLO ese nodo en el DOM real.
*   **Pros:** Abstracción potente.
*   **Contras:** Lento si la app es enorme (comparar árboles gigantes cuesta CPU).

### Signals (Solid, Svelte, Vue 3, Angular 16+)
El nuevo estándar.
No hay Virtual DOM. La variable (`signal`) "conoce" a quien la usa.
1.  Creas una señal: `const [count, setCount] = createSignal(0)`.
2.  La usas en el HTML: `<div>{count()}</div>`.
3.  Cuando llamas a `setCount(1)`, la señal dispara una bala de francotirador directo a ese `div`.
*   **Ventaja:** Rendimiento O(1). No importa el tamaño de la app.

---

### State Management (Estado)
*   **Local State:** Datos de un solo componente (ej. `input` value).
*   **Global State:** Datos que toda la app necesita (ej. Usuario logueado, Carrito de compras).
    *   Herramientas: Context API, Redux/Zustand (React), Pinia (Vue).

**Problema (Prop Drilling):** Pasar datos del Abuelo al Nieto manualmente.
**Solución:** Usa Estado Global para evitar pasar props por 10 componentes.

---

### Ciclo de Vida
Todo componente tiene 3 etapas:
1.  **Montaje:** Nace y aparece en pantalla. (Ideal para llamadas a APIs).
2.  **Actualización:** Cambian sus datos y se redibuja.
3.  **Desmontaje:** Se elimina de pantalla. (Ideal para limpiar memoria).

---

---

## Routing (Navegación sin recarga)

En un Framework, cambiar de URL no significa pedir otro HTML al servidor.
Significa: *Intercambiar componentes usando JS*.

### Single Page Application (SPA)
Solo hay un `index.html`.
Cuando vas a `/about`:
1.  JS intercepta el click.
2.  JS cambia la URL con `history.pushState()`.
3.  JS destruye el componente `Home` y monta el componente `About`.
4.  El navegador **NO** recarga.

### Tipos de Routers
*   **Hash Router (`/#/about`):** Viejo. Seguro para servidores estáticos.
*   **History Router (`/about`):** Moderno. Requiere configuración en el servidor (Nginx/Apache) para que todas las rutas redirijan a `index.html`.
*   **File-System Routing (Next.js/Nuxt):** Creas el archivo `pages/about.js` y la ruta `/about` se crea mágicamente.

---

## Estilando Componentes (CSS en la era de JS)

¿Cómo evitamos que `.boton` afecte a toda la app?

### CSS Modules (`Boton.module.css`)
Estándar en Vite/Next.
```css
/* Boton.module.css */
.btn { color: red; }
```
```javascript
import styles from './Boton.module.css';
<button className={styles.btn}>Click</button> 
// Se compila a: <button class="Boton_btn__ax7z9">
```
*   **Ventaja:** Scoping automático sin librerías extra.

### CSS-in-JS (Styled Components / Emotion)
CSS dentro del archivo JS.
```javascript
const Title = styled.h1`
  color: ${props => props.primary ? 'blue' : 'gray'};
`;
```
*   **Ventaja:** Habilitar estilos dinámicos basados en props es trivial.
*   **Desventaja:** Aumenta el tamaño del bundle JS y tiene costo de runtime.

### Utility-First (Tailwind CSS)
El rey actual.
`<div className="flex justify-center bg-blue-500">`
*   No escribes CSS. Usas clases predefinidas.
*   **Ventaja:** Velocidad de desarrollo y bundle size pequeño (PurgeCSS).

---

## Data Fetching Moderno (Olvida useEffect)

Hace años hacíamos esto en React:
```javascript
// MALO (Waterfall, Race Conditions, No Cache)
useEffect(() => {
    fetch('/api/user').then(data => setUser(data));
}, []);
```

### TanStack Query / SWR
Librerías que manejan caché, reintentos y foco de ventana.
```javascript
// BUENO
const { data, error, isLoading } = useQuery(['user'], fetchUser);
```
*   Si cambias de pestaña y vuelves, **revalidan** los datos automáticamente.
*   Si falla, **reintentan** 3 veces.
*   Deduplican peticiones (si 3 componentes piden el user, solo se hace 1 petición de red).

### Server Actions (Next.js 14+)
Llamar funciones de backend directamente desde el botón.
```javascript
// Server Component
async function guardar(formData) {
    'use server';
    await db.save(formData);
}
// Client Component
<form action={guardar}>...</form>
```

---

---

## Build Tools: La Revolución de Vite

Nadie escribe `<script type="module">` a mano. Usamos bundlers.

### Webpack (El Gigante Dormido)
El estándar por 10 años.
*   **Cómo funciona:** Lee TODO tu código, compila TODO, y genera un `bundle.js`.
*   **Problema:** Si tienes 5,000 archivos, tarda 40 segundos en arrancar el servidor `dev`.

### Vite (El Rayo)
Creado por Evan You (Vue).
*   **Dev:** Usa `ES Modules` nativos del navegador. **No compila nada** hasta que lo pides. Arraque en 300ms.
*   **Build:** Usa **Rollup** para producción.
*   **Under the hood:** Usa **esbuild** (escrito en Go) que es 100x más rápido que JS.

---

## Estrategias de Renderizado (Rendering Patterns)

No todo es SPA. Google necesita leer tu HTML.

### CSR (Client Side Rendering)
El servidor manda un HTML vacío. El JS construye todo.
*   **Pros:** Barato (hosting estático). Rápido al navegar.
*   **Contras:** SEO malo (Google a veces espera el JS, a veces no). Pantalla blanca inicial.

### SSR (Server Side Rendering)
El servidor (Node.js) genera el HTML completo con datos y lo manda. Luego JS hace "Hydration".
*   **Pros:** SEO perfecto. First Contentful Paint rápido.
*   **Contras:** Servidor caro.

### SSG (Static Site Generation)
Generas los HTML en el "Build Time" (en tu PC). Subes archivos fijos.
*   **Pros:** Lo más rápido posible (CDN). Irrompible.
*   **Contras:** Si cambias un typo, tienes que reconstruir toda la web.

### ISR (Incremental Static Regeneration)
Lo mejor de ambos mundos (Next.js es famoso por esto).
*"Genera estático, pero si alguien entra después de 1 hora, regenera en background"*.

---

## Testing en Frontend

Si no hay tests, el usuario es el tester.

### Tipos de Test
1.  **Unitarios (Vitest/Jest):** Prueban una función aislada (`sumar(1,2) === 3`).
2.  **Componentes (React Testing Library):** Renderizan un botón y clickean.
    *   *"Renderiza `<Button />`. Busca el texto 'Click'. Haz click. Verifica que se llamó la función"*.
3.  **E2E (Cypress/Playwright):** Abren un Chrome real y navegan como un usuario.
    *   *"Logueate, ve al carrito, compra"*.

---

## El Ecosistema Moderno (Stack 2025)

No reinventes la rueda.

*   **UI Components:** **shadcn/ui** (Copiar y pegar código, no librería npm). **Tailwind CSS**.
*   **Validación:** **Zod** (Validar esquemas y formularios).
*   **Formularios:** **React Hook Form**.
*   **Iconos:** **Lucide React**.
*   **Animaciones:** **Framer Motion**.

---

---

## Arquitectura de Carpetas Escalable

No pongas todos tus componentes en `src/components`.

### Feature-Based Architecture
Agrupar por "funcionalidad", no por "tipo de archivo".
```
src/
  features/
    auth/
      components/
        LoginForm.tsx
      hooks/
        useLogin.ts
      services/
        authApi.ts
      types/
        index.ts
    cart/
      ...
  components/ (UI Genérica)
    Button.tsx
    Modal.tsx
  hooks/ (Globales)
    useTheme.ts
```
*   **Ventaja:** Si quieres borrar la funcionalidad "Auth", borras la carpeta y listo.

---

## Optimización de Rendimiento (Performance)

React es rápido, pero tú puedes hacerlo lento si no tienes cuidado.

### Re-renders Innecesarios
Si el Padre renderiza, todos los hijos renderizan (aunque sus props no cambien).
*   **Solución:** `React.memo(Componente)` (Solo renderiza si cambian las props).

### Cálculos Pesados (`useMemo`)
Si tienes un filtro de 10,000 items:
```javascript
// Malo: Se recalcula en cada render
const visibleItems = items.filter(i => i.active);

// Bueno: Solo se recalcula si 'items' cambia
const visibleItems = useMemo(() => items.filter(i => i.active), [items]);
```

### Referencias de Funciones (`useCallback`)
Si pasas una función a un hijo memoizado, necesitas `useCallback`, o la función será "nueva" en cada render, rompiendo el memo.

### Code Splitting (`React.lazy`)
No cargues el Admin Panel si el usuario es un Visitante.
```javascript
const AdminPanel = React.lazy(() => import('./AdminPanel'));
```
*   Esto crea un archivo `admin-panel.chunk.js` separado que solo se descarga cuando se necesita.

---

## Seguridad en SPAs

### XSS (Cross Site Scripting)
React protege contra XSS por defecto (escapa el HTML).
**El Peligro:**
```javascript
<div dangerouslySetInnerHTML={{ __html: userContent }} />
```
*   **Regla:** Nunca uses esto con contenido que viene del usuario.

### Almacenamiento de Tokens (JWT)
*   **LocalStorage:** Fácil (`localStorage.setItem`), pero vulnerable a XSS (cualquier script puede leerlo).
*   **HttpOnly Cookie:** Seguro. JS no puede leerla. El navegador la envía sola.
*   **Recomendación:** Usa Cookies HttpOnly para el Refresh Token y memoria para el Access Token.

---

---

## React Server Components (RSC)

La mayor innovación desde los Hooks.

### El Problema
Antes, todo componente React se enviaba al navegador (JS bundle).
Si querías renderizar Markdown, tenías que enviar la librería de Markdown (200kb) al usuario.

### La Solución RSC
Componentes que **solo corren en el servidor** y nunca se envían al cliente.
```javascript
// Server Component (por defecto en Next.js 13+)
import { db } from './db';

async function ListaUsuarios() {
    const usuarios = await db.users.find();
    return (
        <div>
            {usuarios.map(u => <div key={u.id}>{u.name}</div>)}
        </div>
    );
}
```
*   **Resultado:** 0kb de JS enviado al cliente para este componente. Rendimiento nativo.

---

## Arquitectura de Islas (Islands Architecture)

Popularizada por **Astro**.
La web es estática (HTML) por defecto. Solo las "islas" de interactividad cargan JS.

### Hidratación Parcial
Imagina un blog. Header, Footer, Artículos son estáticos (0 JS).
Solo el widget de "Comentarios" necesita React.
*   **Astro:** Genera HTML puro para todo.
*   **Isla:** `<Comentarios client:visible />`
*   **Resultado:** El navegador solo descarga el JS de Comentarios cuando el usuario hace scroll hasta ahí.

---

## PWA (Progressive Web Apps)

Hacer que tu web se sienta como una App nativa.

### Service Workers
Un script que corre en segundo plano, separado de tu web.
*   **Offline First:** Intercepta las peticiones de red. Si no hay internet, devuelve archivos cacheados.
*   **Background Sync:** Envía formularios cuando recuperas conexión.

### Web App Manifest (`manifest.json`)
Permite "Instalar" la web en el escritorio o móvil.
```json
{
    "name": "Mi Super App",
    "display": "standalone",
    "icons": [...]
}
```

---

---

## La Gran Matriz Comparativa (2025)

Para que elijas con datos, no con fanatismo.

| Característica | React | Vue | Angular | Svelte | Solid |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Creador** | Meta (Facebook) | Evan You | Google | Rich Harris | Ryan Carniato |
| **Filosofía** | Librería UI (Minimalista) | Framework Progresivo | Plataforma Completa | Compilador | Rendimiento Puro |
| **Sintaxis** | JSX (JS con HTML) | Templates HTML | HTML + Typescript | HTML + Script | JSX (Signals) |
| **State** | `useState`, `useContext` | `ref`, `reactive` | `Signals`, `RxJS` | `let count = 0` | `createSignal` |
| **Virtual DOM** | Sí (Fiber) | Sí (Virtual DOM) | No (Incremental DOM) | No (Compilado) | No (Compilado) |
| **Ecosistema** | Gigante (npm infinito) | Grande (Oficial fuerte) | Medio (Todo integrado) | Creciente | Pequeño |
| **Curva** | Media | Baja | Alta | Muy Baja | Media |
| **Uso Ideal** | Todo (Estándar) | Startups / Laravel | Banca / Enterprise | Apps Rápidas | Rendimiento Crítico |

---

## Patrones Enterprise

Cuando tu equipo crece de 5 a 50 desarrolladores.

### Monorepos (Turborepo / Nx)
Tener múltiples apps (`web`, `admin`, `docs`) y librerías compartidas (`ui-kit`, `utils`) en un solo repositorio Git.
*   **Ventaja:** Cambias un botón en el `ui-kit` y se actualiza en las 3 apps al mismo tiempo.
*   **Herramientas:** Turborepo (Vercel) es el estándar hoy.

### Micro-Frontends (Module Federation)
Dividir una web gigante en trozos independientes desplegados por separado.
*   El equipo A despliega el "Header".
*   El equipo B despliega el "Carrito".
*   El navegador los une en tiempo de ejecución.
*   **Advertencia:** Complejidad brutal. Solo úsalo si tienes >50 devs.

---

## Formularios Avanzados (React Hook Form)

Manejar formularios en React puro es lento (cada letra renderiza todo).

### Uncontrolled Components
React Hook Form usa `ref` para no re-renderizar al escribir.
```javascript
import { useForm } from "react-hook-form";

export default function App() {
  const { register, handleSubmit } = useForm();
  
  const onSubmit = data => console.log(data);

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {/* 0 Re-renders al escribir */}
      <input {...register("firstName")} />
      <input type="submit" />
    </form>
  );
}
```
*   **Resultado:** Performance nativo en formularios gigantes.

---

---

## Headless UI y Accesibilidad (a11y)

Hacer un Modal accesible es difícil (Focus trap, Esc key, ARIA roles).
No lo hagas tú mismo.

### ¿Qué es Headless UI?
Librerías que te dan la **lógica** y la **accesibilidad**, pero **0 estilos**.
*   **Radix UI (shadcn/ui lo usa):** Estándar de oro.
*   **Headless UI (Tailwind Labs):** Integración perfecta con Tailwind.
*   **React Aria (Adobe):** Hooks potentes para accesibilidad.

```javascript
/* Dialog.Root maneja el estado abierto/cerrado y el focus trap */
<Dialog.Root>
  <Dialog.Trigger>Abrir</Dialog.Trigger>
  <Dialog.Content>
    <Dialog.Title>Editar perfil</Dialog.Title>
    {/* Tú pones tus clases CSS aquí */}
  </Dialog.Content>
</Dialog.Root>
```

---

## Internacionalización (i18n)

Tu app va a crecer. No hardcodees textos en español.

### react-i18next
```javascript
// en.json
{ "welcome": "Welcome back, {{name}}" }

// Componente
const { t } = useTranslation();
<h1>{t('welcome', { name: 'Jesus' })}</h1>
```
*   **Ventaja:** Cambiar de idioma es instantáneo y sin recargar.
*   **Plurales:** Maneja automáticamente "1 item" vs "2 items".

---

## El Futuro: React Compiler (React Forget)

Presentado en React Conf 2024.
El fin de `useMemo` y `useCallback`.

### ¿Qué hace?
Un compilador (integrado en Babel/Vite) que analiza tu código y **memoriza todo automáticamente**.
*   Ya no necesitas pensar: "¿Debo envolver esta función en useCallback?".
*   El compilador lo hace por ti en el build time.
*   **Resultado:** React se vuelve tan fácil como Svelte, pero con el ecosistema de React.

---

---

## Carrera y Recursos (Path to Senior)

¿Dónde aprender más?

### Roles Especializados
El "Frontend Developer" genérico está muriendo. Especialízate:
1.  **UI Engineer:** Experto en CSS, Accesibilidad, Design Systems. (Usa Storybook).
2.  **Product Engineer:** Experto en React, Lógica de negocio, UX. (Usa Next.js).
3.  **Platform Engineer:** Experto en Tooling (Vite, Webpack), CI/CD, Monorepos.

### Recursos de Oro
*   **React Docs (Beta):** La mejor documentación técnica del mundo.
*   **Total TypeScript:** Matt Pocock (El mago de los tipos).
*   **Frontend Masters:** Cursos nivel experto (Kyle Simpson).
*   **Josh Comeau:** El mejor blog de CSS/React interactivas.

---

<div align="center">

[⬅️ Anterior: 3.1 Introducción al Lenguaje](3.1.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 3.3 Estructuras de Control](3.3.md) ➡️

</div>
