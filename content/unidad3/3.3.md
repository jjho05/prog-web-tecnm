# 3.3 Estructuras de Control

Sin estructuras de control, el código sería una lista de instrucciones que se ejecutan una tras otra sin inteligencia.
Aquí aprenderás a controlar el flujo de tu aplicación.

---

### Condicionales (`if`, `switch`, Ternario)
*   **`if / else`:** Lo básico.
    *   *Tip Pro:* Usa **Cláusulas de Guarda** (Return Early) para evitar el "Arrow Code" (muchos if anidados).
*   **`switch`:** Útil para muchos casos, pero fácil de romper si olvidas el `break`.
*   **Ternario (`? :`):** `condicion ? "Verdadero" : "Falso"`. Úsalo para asignaciones simples en una línea.

---

## Condicionales Modernos (ES2020+)

Escribir menos código y más seguro.

### Short-Circuiting (`&&`, `||`)
*   **AND (`&&`):** Si el primero es falso, se detiene.
    ```javascript
    // Si usuario existe, imprime el nombre
    user && console.log(user.name);
    ```
*   **OR (`||`):** Valores por defecto.
    ```javascript
    // Si puerto es undefined/null/0/"", usa 3000
    const port = process.env.PORT || 3000;
    ```
    *   **Peligro:** `0` es falsy. Si el puerto válido es `0`, esto lo cambiará a `3000`.

### Nullish Coalescing (`??`)
La versión segura de `||`. Solo actúa si es `null` o `undefined` (ignora `0` o `false`).
```javascript
const score = 0;
const puntaje = score || 10; // 10 (¡Mal! el jugador tiene 0 puntos)
const puntajeReal = score ?? 10; // 0 (¡Bien!)
```

### Optional Chaining (`?.`)
La salvación contra el error "Cannot read property of undefined".
```javascript
// Antes:
if (user && user.address && user.address.street) ...

// Ahora:
const calle = user?.address?.street;
```
Si `user` o `address` no existen, devuelve `undefined` en lugar de explotar.

---

### Tipos de Bucles
1.  **`for (let i=0...)`:** El clásico. Rápido pero verboso.
2.  **`while`:** "Mientras ocurra X". Úsalo cuando no sabes cuántas veces iterarás.
3.  **`for (const item of array)`:** **El moderno.** Úsalo siempre para recorrer arrays. Es limpio y legible.
4.  **`for (const key in obj)`:** Solo para objetos (recorre las claves). No lo uses en arrays.

---

---

### Métodos Funcionales (La forma correcta de iterar)
Olvídate del `for`. Usa esto para Arrays:

*   **`.forEach()`:** "Haz algo con cada elemento". (Efectos secundarios).
*   **`.map()`:** "Transforma cada elemento y dame una lista nueva". (Ej. precios -> precios con IVA).
*   **`.filter()`:** "Filtra la lista según una condición". (Ej. usuarios activos).
*   **`.reduce()`:** "Reduce toda la lista a un solo valor". (Ej. sumar todos los precios).

---

### Control Asíncrono
JS no espera. Si pides datos a una API, el código sigue. ¿Cómo esperas la respuesta?
1.  **Callbacks (Antiguo):** Pasar una función que se ejecuta al terminar. (Causa el "Callback Hell").
2.  **Promesas (2015):** Objetos `.then()` y `.catch()`. Mejor, pero aún verboso.
3.  **Async / Await (Moderno):** "Pausa" la ejecución hasta que la promesa se resuelva. Se lee como código síncrono.
    ```javascript
    async function pedirDatos() {
        const datos = await fetch('/api/user'); // Espera aquí
        console.log(datos);
    }
    ```

---

## Generadores (`function*`)

Funciones que se pueden "pausar" y "reanudar".
Poco usados en apps comunes, muy usados en librerías (Redux Saga).

```javascript
function* contador() {
    yield 1;
    yield 2;
    yield 3;
}

const gen = contador();
console.log(gen.next().value); // 1 (Se pausa)
console.log(gen.next().value); // 2
```
*   **Uso Real:** Streams infinitos de datos o máquinas de estado complejas.

---

---

## Promesas Avanzadas (Paralelismo)

A veces no necesitas esperar una por una (`await`). Puedes lanzar todas a la vez.

### `Promise.all([p1, p2])`
Espera a que TODAS se resuelvan. Si UNA falla, todo falla.
```javascript
const [users, posts] = await Promise.all([
    fetch('/users'),
    fetch('/posts')
]);
// Tiempo total: max(tiempoUsers, tiempoPosts)
// Si fuera secuencial: tiempoUsers + tiempoPosts (Más lento)
```

### `Promise.allSettled()`
Espera a que todas terminen, sin importar si fallaron o no.
*   **Retorna:** Un array de objetos `{ status: 'fulfilled', value: ... }` o `{ status: 'rejected', reason: ... }`.
*   **Uso:** Ideal para dashboards donde si falla un widget, los demás deben cargarse.

### `Promise.race()` y `Promise.any()`
*   **Race:** La primera que termine (gane o pierda). Útil para timeouts.
*   **Any:** La primera que se resuelva (ignore fallos).

---

## Recursividad vs Iteración

Una función que se llama a sí misma.

### El caso base
Siempre define cuándo parar, o tendrás un `Stack Overflow` (Desbordamiento de pila).

```javascript
// Factorial de 5: 5 * 4 * 3 * 2 * 1
function factorial(n) {
    if (n === 0) return 1; // Caso base
    return n * factorial(n - 1); // Llamada recursiva
}
```

### ¿Cuándo usarla?
Para estructuras de datos anidadas (Árboles, carpetas, menús multinivel, JSON anidados).
Para todo lo demás, un loop `for` es más eficiente en memoria.

---

## Iteradores Personalizados (`Symbol.iterator`)

¿Cómo hacer que tu objeto funcione con `for...of`?
Implementando el protocolo Iterator.

```javascript
const rango = {
    inicio: 1,
    fin: 5,
    [Symbol.iterator]() {
        let actual = this.inicio;
        let ultimo = this.fin;
        return {
            next() {
                if (actual <= ultimo) {
                    return { done: false, value: actual++ };
                } else {
                    return { done: true };
                }
            }
        };
    }
};

for (const num of rango) {
    console.log(num); // 1, 2, 3, 4, 5
}
```
*   **Magia:** Ahora `[...rango]` también funciona y genera `[1, 2, 3, 4, 5]`.

---

## Flujo de Errores Avanzado

### Re-throwing Errors
A veces capturas un error pero no puedes manejarlo ahí. Lánzalo de nuevo.
```javascript
try {
    procesarDatos();
} catch (error) {
    if (error instanceof NetworkError) {
        // Esto sí lo sé manejar
        retry();
    } else {
        // Esto no sé qué es. Que lo maneje el padre.
        throw error;
    }
}
```

### Custom Error Classes
```javascript
class ValidationError extends Error {
    constructor(message) {
        super(message);
        this.name = "ValidationError";
    }
}

if (!email) throw new ValidationError("Falta email");
```

---

---

## Patrones de Diseño para Control de Flujo

Escribir `if/else` kilométricos es de novatos.

### Strategy Pattern (Reemplazando Switch)
```javascript
const estrategias = {
    'paypal': () => procesarPaypal(),
    'stripe': () => procesarStripe(),
    'efectivo': () => generarTicket()
};

function pagar(metodo) {
    const estrategia = estrategias[metodo];
    if (!estrategia) throw new Error("Método no soportado");
    estrategia();
}
```
*   **Ventaja:** Cumple el principio Open/Closed. Para agregar un método, no tocas la función `pagar`.

### Guard Clauses (Cláusulas de Guarda)
Invierte la lógica para eliminar el anidamiento (nesting).
```javascript
// Antes (Arrow Code)
if (user) {
    if (active) {
        if (role === 'admin') {
            save();
        }
    }
}

// Después
if (!user) return;
if (!active) return;
if (role !== 'admin') return;
save();
```

---

## Máquinas de Estado Finito (FSM)

A veces un `boolean` (`isLoading`) no basta.
¿Qué pasa si tienes `isLoading`, `isError`, `isSuccess`, `isEmpty`?
Es imposible gestionar eso con `if`.

### Objeto de Transiciones
```javascript
const maquina = {
    idle: { CLICK: 'loading' },
    loading: { SUCCESS: 'success', FAIL: 'error' },
    success: { RESET: 'idle' },
    error: { RETRY: 'loading' }
};

let estado = 'idle';

function transicion(evento) {
    const siguienteEstado = maquina[estado][evento];
    if (siguienteEstado) {
        estado = siguienteEstado;
    }
}
```
*   **Ventaja:** Haces imposible los estados inválidos (ej. pasar de 'success' a 'error' directamente).

---

## Composición Funcional (`pipe` y `compose`)

En lugar de crear variables temporales, pasa los datos por un tubo.

```javascript
const gritar = (str) => str.toUpperCase();
const exclamar = (str) => `${str}!!!`;
const repetir = (str) => `${str} ${str}`;

// Estilo Imperativo
const a = gritar("hola");
const b = exclamar(a);
const c = repetir(b);

// Estilo Funcional (Compose)
const compose = (...fns) => x => fns.reduceRight((v, f) => f(v), x);
const transformar = compose(repetir, exclamar, gritar);

console.log(transformar("hola")); // "HOLA!!! HOLA!!!"
```

---

## El Futuro: Pattern Matching (Proposal)

JS quiere copiarle a Rust/Haskell.
Propuesta `match` (Aún no estándar, requiere Babel).

```javascript
/* Imaginario JS 2026 */
const response = match (res) {
    { status: 200, body } => `Éxito: ${body}`,
    { status: 404 } => 'No encontrado',
    { status: 500 } => 'Error servidor',
    _ => 'Desconocido'
};
```
*   Es mucho más poderoso que un `switch` porque hace destructuring en la condición.

---

---

## Operadores Bitwise (El Arte Olvidado)

¿Cómo guardar 4 permisos (Leer, Escribir, Borrar, Admin) en un solo número?
Bits.

### Banderas (Flags)
```javascript
const READ = 1;   // 0001
const WRITE = 2;  // 0010
const DELETE = 4; // 0100
const ADMIN = 8;  // 1000

// Asignar permisos (OR |)
let user = READ | WRITE; // 0011 (3)

// Verificar permisos (AND &)
const puedeLeer = (user & READ) !== 0; // true
const esAdmin = (user & ADMIN) !== 0;  // false

// Quitar permiso (NOT ~ y AND &)
user = user & ~WRITE; // 0001
```
*   **Uso Real:** React usa esto internamente para "Lanes" de prioridad. Linux usa esto para permisos de archivos (chmod 777).

---

## Generadores Asíncronos (`for await...of`)

¿Qué pasa si tienes un generador que hace peticiones a una API en cada paso?

```javascript
async function* fetchPaginas() {
    let url = '/api/users?page=1';
    while (url) {
        const response = await fetch(url);
        const data = await response.json();
        url = data.nextPage; // La API nos dice la siguiente URL
        yield data.items;
    }
}

// Consumo mágico
(async () => {
    for await (const usuarios of fetchPaginas()) {
        console.log("Nueva página cargada:", usuarios.length);
    }
})();
```
*   **Poder:** Es un "Stream" de datos que tú controlas. Puedes parar de pedir páginas con un `break`.

---

## Rendimiento y Big O Notation

Saber estructuras de control implica saber su costo.

### Complejidad Temporal
*   **O(1):** Acceder a un Mapa/Objeto por clave. `obj[id]`. **Instantáneo.**
*   **O(n):** `map`, `filter`, `forEach`. Recorre todo el array.
*   **O(n^2):** Bucles anidados. `for (i) { for (j) }`. **Lento.** Evítalo.

### Map vs Object
Si vas a agregar/borrar muchas claves constantemente:
*   **Object:** El motor V8 crea "Hidden Classes" y optimiza. Si borras claves (`delete`), rompes la optimización y se vuelve lento.
*   **Map:** Está diseñado para agregar/borrar (`set/delete`). **Mucho más rápido** en escenarios dinámicos.

---

## Proyecto Final: Async Queue (Cola de Tareas)

Controlar el flujo de promesas para no saturar el servidor.

```javascript
class Cola {
    constructor(concurrencia) {
        this.max = concurrencia;
        this.running = 0;
        this.queue = [];
    }

    add(tarea) {
        this.queue.push(tarea);
        this.next();
    }

    next() {
        if (this.running >= this.max || this.queue.length === 0) return;

        const tarea = this.queue.shift();
        this.running++;
        
        tarea().finally(() => {
            this.running--;
            this.next();
        });
    }
}

// Uso: Solo 2 descargas a la vez
const cola = new Cola(2);
cola.add(() => fetch('/archivo1'));
cola.add(() => fetch('/archivo2'));
cola.add(() => fetch('/archivo3')); // Espera a que uno termine
```

---

---

## Anti-patrones de Control de Flujo

Errores que delatan a un Junior.

### "Yoga Code" (Else innecesario)
Estirarse para alcanzar el `else`.
```javascript
// Mal
if (isValid) {
    // 50 líneas de código
} else {
    return error;
}

// Bien (Return Early)
if (!isValid) return error;
// 50 líneas de código (sin indentación extra)
```

### "Poltergeist" (Variables fantasma)
Crear variables solo para control de flujo temporal.
```javascript
// Mal
let flag = false;
for (item of items) {
    if (item.id === 1) flag = true;
}
return flag;

// Bien
return items.some(item => item.id === 1);
```

### "Magic Numbers" en Condiciones
```javascript
// Mal
if (status === 2) ...

// Bien
const STATUS_ACTIVE = 2;
if (status === STATUS_ACTIVE) ...
```

---

<div align="center">

[⬅️ Anterior: 3.2 Manejo de Frameworks](3.2.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 3.4 Manipulación de Objetos](3.4.md) ➡️

</div>
