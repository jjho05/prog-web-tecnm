# 3.1 Introducci칩n al Lenguaje JavaScript

JavaScript (JS) es el lenguaje de programaci칩n de la Web. Originalmente dise침ado para agregar interactividad simple a las p치ginas, ha evolucionado hasta convertirse en un ecosistema masivo que corre en servidores (Node.js), robots, cohetes (SpaceX usa JS en interfaces) y dispositivos m칩viles.

Este documento cubre desde los fundamentos hist칩ricos hasta las entra침as del motor V8.

---

## Historia: De Mocha a ESNext

### Breve Historia
*   **1995:** Nace JS en 10 d칤as (Brendan Eich).
*   **1997:** Se estandariza como **ECMAScript**. (JS es el "idioma", ECMAScript es el "diccionario oficial").
*   **2009 (ES5):** Se agregan cosas 칰tiles como `forEach`, `JSON`.
*   **2015 (ES6):** La revoluci칩n. Nace el JS moderno (`const`, `let`, `Clases`, `M칩dulos`).
*   **Hoy:** Se actualiza cada a침o con peque침as mejoras.

---

## El Motor JavaScript (V8 Engine)

El navegador no "lee" JS l칤nea por l칤nea. Lo **compila**.

### JIT Compilation (Just-In-Time)
El motor V8 (Chrome/Node) usa un compilador JIT.
1.  **Parser:** Convierte tu c칩digo en un AST (Abstract Syntax Tree).
2.  **Ignition (Int칠rprete):** Ejecuta el Bytecode r치pidamente.
3.  **TurboFan (Optimizador):** Observa qu칠 funciones se usan mucho ("Hot functions") y las recompila a C칩digo M치quina optimizado para la CPU.

### Memory Heap y Call Stack
*   **Memory Heap:** Donde se asignan las variables y objetos. (Espacio desordenado).
*   **Call Stack:** Donde se apilan las funciones a ejecutar. (LIFO: Last In, First Out).
    *   JS es **Single Threaded**: Solo tiene un Call Stack. Solo puede hacer una cosa a la vez.

---

## Variables y 츼mbito (Scope)

En JS moderno, `var` est치 muerto. Larga vida a `let` y `const`.

### `var` vs `let` vs `const`
*   **`var`:** (Antiguo) 游 No lo uses. Causa errores porque sus variables se "escapan" de los bloques `if`.
*   **`let`:** (Moderno) 칔sala para valores que **van a cambiar** (ej. un contador).
*   **`const`:** (Moderno) 칔sala **siempre por defecto**. Evita que reasignes la variable por error.

**Ojo:** `const` en un objeto (`const user = {}`) NO congela el contenido, solo proh칤be `user = otroObjeto`.

**Regla de Oro:** Usa `const` por defecto. Usa `let` solo si sabes que el valor va a cambiar (ej. un contador). Nunca uses `var`.

> **游눹 C칩digo en Acci칩n:**
> Mira por qu칠 `var` es peligroso y c칩mo `let/const` arreglaron el scope.
>
> 游늯 **Ver c칩digo:** [01_variables_let_const.js](codigos/01_variables_let_const.js)

---

## Tipos de Datos (Primitivos vs Referencia)

JS es de tipado din치mico.

### Tipos de Datos
*   **Primitivos (Valor):** `string`, `number`, `boolean`, `null`, `undefined`, `symbol`.
*   **Objetos (Referencia):** `object` `{}`, `array` `[]`, `function`.

### Igualdad (`==` vs `===`)
*   `==` (Doble igual): Compara valor pero **ignora el tipo** (`"5" == 5` es `true`). **EV칈TALO.**
*   `===` (Triple igual): Compara valor **Y tipo** (`"5" === 5` es `false`). **칔SALO SIEMPRE.**

---

## Funciones: Ciudadanos de Primera Clase

En JS, las funciones son objetos. Puedes pasarlas como argumentos, retornarlas, y asignarlas a variables.

### Tipos de Funciones
1.  **Function Declaration:** `function suma() { ... }`. Se pueden usar antes de declarar (Hoisting).
2.  **Arrow Function:** `const suma = () => { ... }`. Modernas, cortas, ideales para callbacks. **No tienen `this` propio.**

### Scope (츼mbito)
쮻칩nde vive mi variable?
*   **Global:** Accesible desde cualquier lado.
*   **Function/Block Scope:** Solo accesible dentro de la llave `{}` donde se cre칩. JS busca en el padre si no la encuentra.

---

---

### 쯈u칠 es una Closure?
Es una funci칩n que **recuerda** las variables de afuera, incluso cuando la funci칩n de afuera ya termin칩.
*   *Uso:* Crear variables privadas o f치bricas de funciones.

```javascript
function crearContador() {
    let cuenta = 0; // Privado
    return () => cuenta++; // Recuerda 'cuenta'
}
```

---

## La palabra clave `this`

`this` no se refiere a la funci칩n en s칤, ni a su scope. Se refiere a **c칩mo se llam칩 la funci칩n**.

### Las 4 Reglas de `this`
1.  **Default Binding:** En modo estricto, `undefined`. En modo normal, `window`.
    ```javascript
    function hola() { console.log(this); }
    hola(); // Window
    ```
2.  **Implicit Binding:** El objeto antes del punto.
    ```javascript
    const obj = {
        nombre: "Jes칰s",
        hablar() { console.log(this.nombre); }
    };
    obj.hablar(); // "Jes칰s"
    ```
3.  **Explicit Binding:** `call`, `apply`, `bind`.
    ```javascript
    function saludar() { console.log(this.nombre); }
    const usuario = { nombre: "Ana" };
    saludar.call(usuario); // "Ana"
    ```
4.  **New Binding:** Con el constructor `new`.
    ```javascript
    const auto = new Carro(); // this = nuevo objeto vac칤o
    ```

### El truco de la Arrow Function
Las Arrow Functions **NO** tienen `this`. Toman el `this` de su entorno padre (Lexical `this`).
Por eso son ideales para React y Callbacks.

---

## Modern JavaScript (ES6+ Cheatsheet)

Si no usas esto en 2025, escribes c칩digo legacy.

### Template Literals
Adi칩s a `'Hola ' + nombre + '!'`.
```javascript
const mensaje = `Hola ${nombre}, son las ${Date.now()}`;
// Soporta multil칤nea
const html = `
    <div>
        <h1>T칤tulo</h1>
    </div>
`;
```

### Destructuring (Desestructuraci칩n)
Extraer datos de arrays u objetos.
```javascript
// Objetos
const user = { id: 1, name: "Admin", role: "Super" };
const { name, role } = user;

// Arrays
const coords = [10, 20];
const [x, y] = coords;
```

### Spread Operator (`...`)
Expandir elementos.
```javascript
const frutas = ["Manzana", "Pera"];
const copia = [...frutas]; // Copia real, no referencia
const nuevoArray = [...frutas, "Uva"];

const obj1 = { a: 1 };
const obj2 = { ...obj1, b: 2 }; // Merge de objetos
```

### M칩dulos (ES Modules)
El sistema oficial de JS.
```javascript
// archivo.js
export const pi = 3.14;
export default function sumar(a, b) { return a + b; }

// main.js
import sumar, { pi } from './archivo.js';
```

---

---

### 쮺칩mo funciona la Asincron칤a? (Event Loop)
JS hace una cosa a la vez (Single Thread). Pero el navegador le ayuda.
1.  **Call Stack:** Tu c칩digo JS (s칤ncrono).
2.  **Web APIs:** `setTimeout`, `fetch`, etc. (Las hace el navegador en otro hilo).
3.  **Queue:** Cuando la Web API termina, pone el callback en la fila de espera.
4.  **Event Loop:** Vigila. Si el Stack est치 vac칤o, pasa lo de la Queue al Stack.

---

## Prototipos y Herencia (La verdad sobre las Clases)

En JS las `class` son solo "az칰car sint치ctica". Bajo la capucha, todo son objetos y prototipos.
Todo objeto tiene una propiedad interna llamada `[[Prototype]]` (o `__proto__` en navegadores viejos) que apunta a otro objeto.

### La Cadena de Prototipos
Si buscas `usuario.apellidos` y no existe en `usuario`, JS busca en su prototipo. Y luego en el prototipo del prototipo.
Hasta llegar a `Object.prototype` (el Ad치n de todos los objetos) y finalmente `null`.

```javascript
const animal = { vivo: true };
const perro = Object.create(animal); // perro hereda de animal
perro.ladrar = true;

console.log(perro.ladrar); // true (Propio)
console.log(perro.vivo);   // true (Heredado de animal)
console.log(perro.alas);   // undefined (Lleg칩 al final y no encontr칩 nada)
```

---

## Strict Mode (`'use strict'`)

Una forma de optar por una variante m치s limpia y segura de JS.
Se activa poniendo `'use strict';` al inicio del archivo o funci칩n.

### 쯈u칠 arregla?
1.  **Variables globales:** Error si asignas `x = 10` sin `var/let/const`. (Antes creaba una global por error).
2.  **`this`:** En funciones sueltas, `this` es `undefined` en lugar de `window`.
3.  **Duplicados:** Proh칤be par치metros duplicados `function(a, a)`.
4.  **Palabras reservadas:** Reserva palabras para el futuro (`implements`, `interface`, `package`).

**Nota:** Los M칩dulos ES6 (`import/export`) y las Clases tienen `'use strict'` activado autom치ticamente.

---

---

### M칩dulos (Import / Export)
La forma moderna de organizar c칩digo.
*   **Exportar:** `export const pi = 3.14;`
*   **Importar:** `import { pi } from './math.js';`

Nota: En Node.js antiguo se usaba `require()` (CommonJS), pero el est치ndar hoy es `import` (ES Modules).

---

## Manejo de Errores (Error Handling)

JS explota si no manejas los errores.

### `try...catch...finally`
```javascript
try {
    // C칩digo peligroso (petici칩n API, JSON.parse)
    const user = JSON.parse('{"mal": json');
} catch (error) {
    // Si falla, cae aqu칤
    console.error("Fall칩 el parseo:", error.message);
} finally {
    // Se ejecuta SIEMPRE (haya error o no)
    // Ideal para cerrar conexiones o loaders
    console.log("Limpieza terminada");
}
```

### Tipos de Errores Nativos
*   `ReferenceError`: Variable no existe (`console.log(x)`).
*   `TypeError`: Ejecutar algo que no es funci칩n (`null.f()`).
*   `SyntaxError`: Escribiste mal el c칩digo.

---

## Debugging como un Senior

Deja de usar `console.log('hola')`.

### Console API Power Users
*   `console.table(array)`: Muestra datos en tabla excel.
*   `console.time('Loop')` / `console.timeEnd('Loop')`: Mide cu치nto tarda un bloque.
*   `console.dir(elemento)`: Muestra el objeto JS de un elemento DOM (no el HTML).
*   `console.trace()`: Muestra el Stack Trace (qui칠n llam칩 a la funci칩n).

### La palabra clave `debugger`
Si pones `debugger;` en tu c칩digo y tienes DevTools abierto, la ejecuci칩n se **pausa** ah칤.
Puedes inspeccionar variables paso a paso sin poner breakpoints manuales.

---

## Gesti칩n de Memoria (Garbage Collection)

JS maneja la memoria por ti, pero puedes causar **Memory Leaks**.

### Reachability (Alcanzabilidad)
El Garbage Collector (GC) "Marca y Barre" (Mark and Sweep).
1.  Empieza en la Ra칤z (Window/Global).
2.  Marca todo lo que est치 conectado (variables, funciones activas).
3.  Borra de la memoria todo lo que **NO** est치 marcado.

### Fugas de Memoria Comunes
1.  **Variables Globales:** Nunca se borran.
2.  **Intervalos Olvidados:** `setInterval` que nunca haces `clearInterval`.
3.  **Habilitadores de Eventos en nodos borrados:** Si borras un bot칩n del DOM pero tiene un `onclick` apuntando a una funci칩n gigante, esa funci칩n se queda en memoria.

---

---

## Programaci칩n Funcional en JS

JS no es Haskell, pero ama la programaci칩n funcional.

### Funciones Puras
Salida depende SOLO de la entrada. No efectos secundarios.
```javascript
// Pura
const sumar = (a, b) => a + b;

// Impura (Depende de algo externo)
let total = 0;
const agregar = (n) => total += n;
```

### Inmutabilidad
No modificar objetos originales. Crear copias.
```javascript
const user = { name: "Jes칰s" };
// Mal
user.name = "Paco";

// Bien (Nuevo objeto)
const nuevoUser = { ...user, name: "Paco" };
```

### Higher Order Functions (HOF)
Funciones que reciben funciones o retornan funciones.
*   `map`, `filter`, `reduce`.
    ```javascript
    const nums = [1, 2, 3];
    const dobles = nums.map(n => n * 2); // [2, 4, 6]
    ```

---

## Estructuras de Datos Modernas (ES6)

El objeto `{}` no sirve para todo.

### `Map` (Diccionario Real)
*   **Claves:** Pueden ser cualquier cosa (춰incluso objetos!), no solo strings.
*   **Orden:** Mantiene el orden de inserci칩n.
    ```javascript
    const mapa = new Map();
    mapa.set('clave', 'valor');
    mapa.set({ id: 1 }, 'Objeto como clave');
    console.log(mapa.size); // 2
    ```

### `Set` (Conjunto 칔nico)
Array que no permite duplicados.
```javascript
const unicos = new Set([1, 1, 2, 3]); // {1, 2, 3}
const tieneDos = unicos.has(2); // true (O(1) - Muy r치pido)
```

### `WeakMap` y `WeakSet`
Sus claves son "d칠biles". Si nadie m치s usa el objeto clave, el Garbage Collector lo borra del mapa autom치ticamente. Ideal para cach칠 en librer칤as.

---

## Metaprogramaci칩n: `Proxy` y `Reflect`

Magia negra para interceptar operaciones del lenguaje.

### Proxy (El Interceptor)
Puedes envolver un objeto y "espiar" cuando alguien lo lee o escribe.
```javascript
const target = { mensaje: "Hola" };

const handler = {
    get(obj, prop) {
        if (prop === 'secreto') return 'shhh';
        return obj[prop];
    },
    set(obj, prop, value) {
        if (typeof value !== 'string') throw new TypeError("Solo texto");
        obj[prop] = value;
        return true;
    }
};

const proxy = new Proxy(target, handler);
console.log(proxy.secreto); // "shhh"
proxy.mensaje = 123; // Error: Solo texto
```
*   **Uso Real:** As칤 funciona la reactividad de Vue 3.

---

<div align="center">

[游 Volver al 칈ndice](../../README.md) &nbsp;&nbsp;|&nbsp;&nbsp; [Siguiente: 3.2 Manejo de Frameworks](3.2.md) 俱뫮잺

</div>
